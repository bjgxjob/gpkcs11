<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Cryptoki: A Cryptographic Token Interface</TITLE>
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<FONT FACE="Haettenschweiler" SIZE=7><P>P<A NAME="_Ref383843926"></A>KCS #11: Cryptographic Token Interface Standard</P>
</FONT><FONT FACE="Haettenschweiler" SIZE=4><P>An RSA Laboratories Technical Note<BR>
Version 2.01<BR>
December 22, 1997</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P>Foreword</P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">As cryptography begins to see wide application and acceptance, one thing is increasingly clear: if it is going to be as effective as the underlying technology allows it to be, there must be interoperable standards.  Even though vendors may agree on the basic cryptographic techniques, compatibility between implementations is by no means guaranteed.  Interoperability requires strict adherence to agreed-upon standards.</P>
<P ALIGN="JUSTIFY">Towards that goal, RSA Laboratories has developed, in cooperation with representatives of industry, academia and government, a family of standards called Public-Key Cryptography Standards, or PKCS for short.</P>
<P ALIGN="JUSTIFY">PKCS is offered by RSA Laboratories to developers of computer systems employing public-key and related technology.  It is RSA Laboratories' intention to improve and refine the standards in conjunction with computer system developers, with the goal of producing standards that most if not all developers adopt.</P>
<P ALIGN="JUSTIFY">The role of RSA Laboratories in the standards-making process is four-fold:</P><DIR>
<DIR>

<P ALIGN="JUSTIFY">1.&#9;Publish carefully written documents describing the standards.</P>
<P ALIGN="JUSTIFY">2.&#9;Solicit opinions and advice from developers and users on useful or necessary changes and extensions.</P>
<P ALIGN="JUSTIFY">3.&#9;Publish revised standards when appropriate.</P>
<P ALIGN="JUSTIFY">4.&#9;Provide implementation guides and/or reference implementations.</P></DIR>
</DIR>

<P ALIGN="JUSTIFY">During the process of PKCS development, RSA Laboratories retains final authority on each document, though input from reviewers is clearly influential.  However, RSA Laboratories’ goal is to accelerate the development of formal standards, not to compete with such work.  Thus, when a PKCS document is accepted as a base document for a formal standard, RSA Laboratories relinquishes its &quot;ownership&quot; of the document, giving way to the open standards development process.  RSA Laboratories may continue to develop related documents, of course, under the terms described above.</P>
<P ALIGN="JUSTIFY">The PKCS family currently includes the following documents:</P><DIR>
<DIR>

<I><P ALIGN="JUSTIFY">PKCS #1: RSA Encryption Standard.</I>  Version 1.5, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #3: Diffie-Hellman Key-Agreement Standard.</I>  Version 1.4, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #5: Password-Based Encryption Standard.</I>  Version 1.5, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #6: Extended-Certificate Syntax Standard.</I>  Version 1.5, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #7: Cryptographic Message Syntax Standard.</I>  Version 1.5, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #8: Private-Key Information Syntax Standard.</I>  Version 1.2, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #9: Selected Attribute Types.</I>  Version 1.1, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #10: Certification Request Syntax Standard.</I>  Version 1.0, November 1993.</P>
<I><P ALIGN="JUSTIFY">PKCS #11: Cryptographic Token Interface Standard.</I>  Version 1.0, April 1995.</P>
<I><P ALIGN="JUSTIFY">PKCS #12: Personal Information Exchange Syntax Standard.</I>  Version 1.0 is under construction.</P></DIR>
</DIR>

<P ALIGN="JUSTIFY">PKCS documents and information are available online from RSADSI’s web server.  To get them, go to RSADSI’s homepage (</FONT><FONT FACE="Courier New" SIZE=2>http://www.rsa.com</FONT><FONT FACE="Palatino" SIZE=2>); then go to RSA Laboratories; then go to the PKCS page.  There is an electronic mailing list, &quot;</FONT><FONT FACE="Courier New" SIZE=2>pkcs-tng&quot;,</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2>, for discussion of issues relevant to the &quot;next generation&quot; of the PKCS standards.  To subscribe to this list, send e-mail to </FONT><FONT FACE="Courier New" SIZE=2>majordomo</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2> with the line &quot;</FONT><FONT FACE="Courier New" SIZE=2>subscribe pkcs-tng</FONT><FONT FACE="Palatino" SIZE=2>&quot; in the message body.  To unsubscribe, send e-mail to </FONT><FONT FACE="Courier New" SIZE=2>majordomo</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2> with the line &quot;</FONT><FONT FACE="Courier New" SIZE=2>unsubscribe pkcs-tng</FONT><FONT FACE="Palatino" SIZE=2>&quot; in the message body.</P>
<P ALIGN="JUSTIFY">There is also an electronic mailing list, &quot;</FONT><FONT FACE="Courier New" SIZE=2>cryptoki</FONT><FONT FACE="Palatino" SIZE=2>&quot;, at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2>, specifically for discussion and development of PKCS #11.  To subscribe to this list, send e-mail to </FONT><FONT FACE="Courier New" SIZE=2>majordomo</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2> with the line &quot;</FONT><FONT FACE="Courier New" SIZE=2>subscribe cryptoki</FONT><FONT FACE="Palatino" SIZE=2>&quot; in the message body.  To unsubscribe, send e-mail to </FONT><FONT FACE="Courier New" SIZE=2>majordomo</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2> with the line &quot;</FONT><FONT FACE="Courier New" SIZE=2>unsubscribe cryptoki</FONT><FONT FACE="Palatino" SIZE=2>&quot; in the message body.</P>
<P ALIGN="JUSTIFY">Comments on the PKCS documents, requests to register extensions to the standards, and suggestions for additional standards are welcomed.  Address correspondence to:</P><DIR>
<DIR>

<P>PKCS Editor<BR>
RSA Laboratories<BR>
100 Marine Parkway, Suite 500<BR>
Redwood City, CA 94065<BR>
(650)595-7703<BR>
fax: (650)595-4126<BR>
email: </FONT><FONT FACE="Courier New" SIZE=2>pkcs-editor</FONT><FONT FACE="Palatino" SIZE=2> at </FONT><FONT FACE="Courier New" SIZE=2>rsa.com</FONT><FONT FACE="Palatino" SIZE=2>.</P></DIR>
</DIR>

<P ALIGN="JUSTIFY">It would be difficult to enumerate all the people and organizations who helped to produce Version 2.01 of PKCS #11.  RSA Laboratories is grateful to each and every one of them.  Especial thanks go to Bruno Couillard of Chrysalis-ITS and John Centafont of NSA for the many hours they spent writing up parts of this document.</P>
<P ALIGN="JUSTIFY">For Version 1.0, PKCS #11’s document editor was Aram P&eacute;rez of International Computer Services, under contract to RSA Laboratories; the project coordinator was Burt Kaliski of RSA Laboratories.  For Version 2.01, Ray Sidney served as document editor and project coordinator.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P>Table of Contents</P>
<ul>
<li><A HREF="#_Toc410108930"></FONT><FONT FACE="Palatino" SIZE=2>1.&#9;Scope&#9;</B></FONT></A>
<li><A HREF="#_Toc410108931"><B><FONT FACE="Palatino" SIZE=2>2.&#9;References&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108932"><B><FONT FACE="Palatino" SIZE=2>3.&#9;Definitions&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108933"><B><FONT FACE="Palatino" SIZE=2>4.&#9;Symbols and abbreviations&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108934"><B><FONT FACE="Palatino" SIZE=2>5.&#9;General overview&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108935"><FONT FACE="Palatino" SIZE=2>5.1.&#9;Design goals&#9;</FONT></A><br>
<li><A HREF="#_Toc410108936"><FONT FACE="Palatino" SIZE=2>5.2.&#9;General model&#9;</FONT></A><br>
<li><A HREF="#_Toc410108937"><FONT FACE="Palatino" SIZE=2>5.3.&#9;Logical view of a token&#9;</FONT></A><br>
<li><A HREF="#_Toc410108938"><FONT FACE="Palatino" SIZE=2>5.4.&#9;Users&#9;</FONT></A><br>
<li><A HREF="#_Toc410108939"><FONT FACE="Palatino" SIZE=2>5.5.&#9;Applications and their use of Cryptoki&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108940"><I><FONT FACE="Palatino" SIZE=2>5.5.1.&#9;Applications and processes&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108941"><I><FONT FACE="Palatino" SIZE=2>5.5.2.&#9;Applications and threads&#9;</I></FONT></A><br></UL>
<li><A HREF="#_Toc410108942"><FONT FACE="Palatino" SIZE=2>5.6.&#9;Sessions&#9;</FONT></A><br><UL>
<li><A HREF="#_Toc410108943"><I><FONT FACE="Palatino" SIZE=2>5.6.1.&#9;Read-only session states&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108944"><I><FONT FACE="Palatino" SIZE=2>5.6.2.&#9;Read/write session states&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108945"><I><FONT FACE="Palatino" SIZE=2>5.6.3.&#9;Permitted object accesses by sessions&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108946"><I><FONT FACE="Palatino" SIZE=2>5.6.4.&#9;Session events&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108947"><I><FONT FACE="Palatino" SIZE=2>5.6.5.&#9;Session handles and object handles&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108948"><I><FONT FACE="Palatino" SIZE=2>5.6.6.&#9;Capabilities of sessions&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108949"><I><FONT FACE="Palatino" SIZE=2>5.6.7.&#9;Example of use of sessions&#9;</I></FONT></A><br></UL>
<li><A HREF="#_Toc410108950"><FONT FACE="Palatino" SIZE=2>5.7.&#9;Function overview&#9;</FONT></A><br>
<li><A HREF="#_Toc410108951"><B><FONT FACE="Palatino" SIZE=2>6.&#9;Security considerations&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108952"><B><FONT FACE="Palatino" SIZE=2>7.&#9;Platform- and compiler-dependent ulectives for C or C++&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108953"><FONT FACE="Palatino" SIZE=2>7.1.&#9;Structure packing&#9;</FONT></A><br>
<li><A HREF="#_Toc410108954"><FONT FACE="Palatino" SIZE=2>7.2.&#9;Pointer-related macros&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108955"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108956"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_DEFINE_FUNCTION&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108957"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_DECLARE_FUNCTION&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108958"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_DECLARE_FUNCTION_POINTER&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108959"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_CALLBACK_FUNCTION&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108960"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;NULL_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108961"><FONT FACE="Palatino" SIZE=2>7.3.&#9;Sample platform- and compiler-dependent code&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108962"><I><FONT FACE="Palatino" SIZE=2>7.3.1.&#9;Win32&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108963"><I><FONT FACE="Palatino" SIZE=2>7.3.2.&#9;Win16&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108964"><I><FONT FACE="Palatino" SIZE=2>7.3.3.&#9;Generic UNIX&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108965"><B><FONT FACE="Palatino" SIZE=2>8.&#9;General data types&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410108966"><FONT FACE="Palatino" SIZE=2>8.1.&#9;General information&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108967"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_VERSION; CK_VERSION_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108968"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_INFO; CK_INFO_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108969"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_NOTIFICATION&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108970"><FONT FACE="Palatino" SIZE=2>8.2.&#9;Slot and token types&#9;</FONT></A><br>
<UL>

<li><A HREF="#_Toc410108971"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SLOT_ID; CK_SLOT_ID_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108972"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SLOT_INFO; CK_SLOT_INFO_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108973"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_TOKEN_INFO; CK_TOKEN_INFO_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108974"><FONT FACE="Palatino" SIZE=2>8.3.&#9;Session types&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108975"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SESSION_HANDLE; CK_SESSION_HANDLE_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108976"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_USER_TYPE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108977"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_STATE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108978"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SESSION_INFO; CK_SESSION_INFO_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108979"><FONT FACE="Palatino" SIZE=2>8.4.&#9;Object types&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108980"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_OBJECT_HANDLE; CK_OBJECT_HANDLE_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108981"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_OBJECT_CLASS; CK_OBJECT_CLASS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108982"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_KEY_TYPE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108983"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_CERTIFICATE_TYPE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108984"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_ATTRIBUTE_TYPE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108985"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_ATTRIBUTE; CK_ATTRIBUTE_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108986"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_DATE&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108987"><FONT FACE="Palatino" SIZE=2>8.5.&#9;Data types for mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108988"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_MECHANISM_TYPE; CK_MECHANISM_TYPE_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108989"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_MECHANISM; CK_MECHANISM_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108990"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_MECHANISM_INFO; CK_MECHANISM_INFO_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108991"><FONT FACE="Palatino" SIZE=2>8.6.&#9;Function types&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108992"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RV&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108993"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_NOTIFY&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108994"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_C_XXX&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108995"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_FUNCTION_LIST; CK_FUNCTION_LIST_PTR; CK_FUNCTION_LIST_PTR_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410108996"><FONT FACE="Palatino" SIZE=2>8.7.&#9;Locking-related types&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410108997"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_CREATEMUTEX&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108998"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_DESTROYMUTEX&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410108999"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_LOCKMUTEX and CK_UNLOCKMUTEX&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109000"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_C_INITIALIZE_ARGS; CK_C_INITIALIZE_ARGS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109001"><B><FONT FACE="Palatino" SIZE=2>9.&#9;Objects&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410109002"><FONT FACE="Palatino" SIZE=2>9.1.&#9;Creating, modifying, and copying objects&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109003"><I><FONT FACE="Palatino" SIZE=2>9.1.1.&#9;Creating objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109004"><I><FONT FACE="Palatino" SIZE=2>9.1.2.&#9;Modifying objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109005"><I><FONT FACE="Palatino" SIZE=2>9.1.3.&#9;Copying objects&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109006"><FONT FACE="Palatino" SIZE=2>9.2.&#9;Common attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410109007"><FONT FACE="Palatino" SIZE=2>9.3.&#9;Data objects&#9;</FONT></A><br>
<li><A HREF="#_Toc410109008"><FONT FACE="Palatino" SIZE=2>9.4.&#9;Certificate objects&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109009"><I><FONT FACE="Palatino" SIZE=2>9.4.1.&#9;X.509 certificate objects&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109010"><FONT FACE="Palatino" SIZE=2>9.5.&#9;Key objects&#9;</FONT></A><br>
<li><A HREF="#_Toc410109011"><FONT FACE="Palatino" SIZE=2>9.6.&#9;Public key objects&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109012"><I><FONT FACE="Palatino" SIZE=2>9.6.1.&#9;RSA public key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109013"><I><FONT FACE="Palatino" SIZE=2>9.6.2.&#9;DSA public key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109014"><I><FONT FACE="Palatino" SIZE=2>9.6.3.&#9;ECDSA public key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109015"><I><FONT FACE="Palatino" SIZE=2>9.6.4.&#9;Diffie-Hellman public key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109016"><I><FONT FACE="Palatino" SIZE=2>9.6.5.&#9;KEA public key objects&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109017"><FONT FACE="Palatino" SIZE=2>9.7.&#9;Private key objects&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109018"><I><FONT FACE="Palatino" SIZE=2>9.7.1.&#9;RSA private key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109019"><I><FONT FACE="Palatino" SIZE=2>9.7.2.&#9;DSA private key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109020"><I><FONT FACE="Palatino" SIZE=2>9.7.3.&#9;ECDSA private key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109021"><I><FONT FACE="Palatino" SIZE=2>9.7.4.&#9;Diffie-Hellman private key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109022"><I><FONT FACE="Palatino" SIZE=2>9.7.5.&#9;KEA private key objects&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109023"><FONT FACE="Palatino" SIZE=2>9.8.&#9;Secret key objects&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109024"><I><FONT FACE="Palatino" SIZE=2>9.8.1.&#9;Generic secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109025"><I><FONT FACE="Palatino" SIZE=2>9.8.2.&#9;RC2 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109026"><I><FONT FACE="Palatino" SIZE=2>9.8.3.&#9;RC4 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109027"><I><FONT FACE="Palatino" SIZE=2>9.8.4.&#9;RC5 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109028"><I><FONT FACE="Palatino" SIZE=2>9.8.5.&#9;DES secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109029"><I><FONT FACE="Palatino" SIZE=2>9.8.6.&#9;DES2 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109030"><I><FONT FACE="Palatino" SIZE=2>9.8.7.&#9;DES3 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109031"><I><FONT FACE="Palatino" SIZE=2>9.8.8.&#9;CAST secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109032"><I><FONT FACE="Palatino" SIZE=2>9.8.9.&#9;CAST3 secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109033"><I><FONT FACE="Palatino" SIZE=2>9.8.10.&#9;CAST128 (CAST5) secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109034"><I><FONT FACE="Palatino" SIZE=2>9.8.11.&#9;IDEA secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109035"><I><FONT FACE="Palatino" SIZE=2>9.8.12.&#9;CDMF secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109036"><I><FONT FACE="Palatino" SIZE=2>9.8.13.&#9;SKIPJACK secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109037"><I><FONT FACE="Palatino" SIZE=2>9.8.14.&#9;BATON secret key objects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109038"><I><FONT FACE="Palatino" SIZE=2>9.8.15.&#9;JUNIPER secret key objects&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109039"><B><FONT FACE="Palatino" SIZE=2>10.&#9;Functions&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410109040"><FONT FACE="Palatino" SIZE=2>10.1.&#9;Function return values&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109041"><I><FONT FACE="Palatino" SIZE=2>10.1.1.&#9;Universal Cryptoki function return values&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109042"><I><FONT FACE="Palatino" SIZE=2>10.1.2.&#9;Cryptoki function return values for functions that use a session handle&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109043"><I><FONT FACE="Palatino" SIZE=2>10.1.3.&#9;Cryptoki function return values for functions that use a token&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109044"><I><FONT FACE="Palatino" SIZE=2>10.1.4.&#9;Special return value for application-supplied callbacks&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109045"><I><FONT FACE="Palatino" SIZE=2>10.1.5.&#9;Special return values for mutex-handling functions&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109046"><I><FONT FACE="Palatino" SIZE=2>10.1.6.&#9;All other Cryptoki function return values&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109047"><I><FONT FACE="Palatino" SIZE=2>10.1.7.&#9;More on relative priorities of Cryptoki errors&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109048"><I><FONT FACE="Palatino" SIZE=2>10.1.8.&#9;Error code &quot;gotchas&quot;&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109049"><FONT FACE="Palatino" SIZE=2>10.2.&#9;Conventions for functions returning output in a variable-length buffer&#9;</FONT></A><br>
<li><A HREF="#_Toc410109050"><FONT FACE="Palatino" SIZE=2>10.3.&#9;Disclaimer concerning sample code&#9;</FONT></A><br>
<li><A HREF="#_Toc410109051"><FONT FACE="Palatino" SIZE=2>10.4.&#9;General-purpose functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109052"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Initialize&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109053"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Finalize&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109054"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetInfo&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109055"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetFunctionList&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109056"><FONT FACE="Palatino" SIZE=2>10.5.&#9;Slot and token management functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109057"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetSlotList&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109058"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetSlotInfo&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109059"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetTokenInfo&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109060"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_WaitForSlotEvent&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109061"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetMechanismList&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109062"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetMechanismInfo&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109063"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_InitToken&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109064"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_InitPIN&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109065"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SetPIN&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109066"><FONT FACE="Palatino" SIZE=2>10.6.&#9;Session management functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109067"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_OpenSession&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109068"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_CloseSession&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109069"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_CloseAllSessions&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109070"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetSessionInfo&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109071"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetOperationState&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109072"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SetOperationState&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109073"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Login&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109074"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Logout&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109075"><FONT FACE="Palatino" SIZE=2>10.7.&#9;Object management functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109076"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_CreateObject&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109077"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_CopyObject&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109078"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DestroyObject&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109079"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetObjectSize&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109080"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetAttributeValue&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109081"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SetAttributeValue&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109082"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_FindObjectsInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109083"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_FindObjects&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109084"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_FindObjectsFinal&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109085"><FONT FACE="Palatino" SIZE=2>10.8.&#9;Encryption functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109086"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_EncryptInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109087"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Encrypt&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109088"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_EncryptUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109089"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_EncryptFinal&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109090"><FONT FACE="Palatino" SIZE=2>10.9.&#9;Decryption functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109091"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DecryptInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109092"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Decrypt&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109093"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DecryptUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109094"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DecryptFinal&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109095"><FONT FACE="Palatino" SIZE=2>10.10.&#9;Message digesting functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109096"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DigestInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109097"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Digest&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109098"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DigestUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109099"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DigestKey&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109100"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DigestFinal&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109101"><FONT FACE="Palatino" SIZE=2>10.11.&#9;Signing and MACing functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109102"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109103"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Sign&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109104"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109105"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignFinal&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109106"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignRecoverInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109107"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignRecover&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109108"><FONT FACE="Palatino" SIZE=2>10.12.&#9;Functions for verifying signatures and MACs&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109109"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_VerifyInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109110"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_Verify&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109111"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_VerifyUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109112"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_VerifyFinal&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109113"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_VerifyRecoverInit&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109114"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_VerifyRecover&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109115"><FONT FACE="Palatino" SIZE=2>10.13.&#9;Dual-function cryptographic functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109116"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DigestEncryptUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109117"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DecryptDigestUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109118"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SignEncryptUpdate&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109119"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DecryptVerifyUpdate&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109120"><FONT FACE="Palatino" SIZE=2>10.14.&#9;Key management functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109121"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GenerateKey&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109122"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GenerateKeyPair&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109123"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_WrapKey&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109124"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_UnwrapKey&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109125"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_DeriveKey&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109126"><FONT FACE="Palatino" SIZE=2>10.15.&#9;Random number generation functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109127"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_SeedRandom&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109128"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GenerateRandom&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109129"><FONT FACE="Palatino" SIZE=2>10.16.&#9;Parallel function management functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109130"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_GetFunctionStatus&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109131"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;C_CancelFunction&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109132"><FONT FACE="Palatino" SIZE=2>10.17.&#9;Callback functions&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109133"><I><FONT FACE="Palatino" SIZE=2>10.17.1.&#9;Surrender callbacks&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109134"><I><FONT FACE="Palatino" SIZE=2>10.17.2.&#9;Vendor-defined callbacks&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109135"><B><FONT FACE="Palatino" SIZE=2>11.&#9;Mechanisms&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410109136"><FONT FACE="Palatino" SIZE=2>11.1.&#9;RSA mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109137"><I><FONT FACE="Palatino" SIZE=2>11.1.1.&#9;PKCS #1 RSA key pair generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109138"><I><FONT FACE="Palatino" SIZE=2>11.1.2.&#9;PKCS #1 RSA&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109139"><I><FONT FACE="Palatino" SIZE=2>11.1.3.&#9;ISO/IEC 9796 RSA&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109140"><I><FONT FACE="Palatino" SIZE=2>11.1.4.&#9;X.509 (raw) RSA&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109141"><I><FONT FACE="Palatino" SIZE=2>11.1.5.&#9;PKCS #1 RSA signature with MD2, MD5, or SHA-1&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109142"><FONT FACE="Palatino" SIZE=2>11.2.&#9;DSA mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109143"><I><FONT FACE="Palatino" SIZE=2>11.2.1.&#9;DSA key pair generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109144"><I><FONT FACE="Palatino" SIZE=2>11.2.2.&#9;DSA without hashing&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109145"><I><FONT FACE="Palatino" SIZE=2>11.2.3.&#9;DSA with SHA-1&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109146"><I><FONT FACE="Palatino" SIZE=2>11.2.4.&#9;FORTEZZA timestamp&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109147"><FONT FACE="Palatino" SIZE=2>11.3.&#9;About ECDSA&#9;</FONT></A><br>
<li><A HREF="#_Toc410109148"><FONT FACE="Palatino" SIZE=2>11.4.&#9;ECDSA mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109149"><I><FONT FACE="Palatino" SIZE=2>11.4.1.&#9;ECDSA key pair generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109150"><I><FONT FACE="Palatino" SIZE=2>11.4.2.&#9;ECDSA without hashing&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109151"><I><FONT FACE="Palatino" SIZE=2>11.4.3.&#9;ECDSA with SHA-1&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109152"><FONT FACE="Palatino" SIZE=2>11.5.&#9;Diffie-Hellman mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109153"><I><FONT FACE="Palatino" SIZE=2>11.5.1.&#9;PKCS #3 Diffie-Hellman key pair generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109154"><I><FONT FACE="Palatino" SIZE=2>11.5.2.&#9;PKCS #3 Diffie-Hellman key derivation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109155"><FONT FACE="Palatino" SIZE=2>11.6.&#9;KEA mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109156"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_KEA_DERIVE_PARAMS; CK_KEA_DERIVE_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109157"><FONT FACE="Palatino" SIZE=2>11.7.&#9;KEA mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109158"><I><FONT FACE="Palatino" SIZE=2>11.7.1.&#9;KEA key pair generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109159"><I><FONT FACE="Palatino" SIZE=2>11.7.2.&#9;KEA key derivation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109160"><FONT FACE="Palatino" SIZE=2>11.8.&#9;Generic secret key mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109161"><I><FONT FACE="Palatino" SIZE=2>11.8.1.&#9;Generic secret key generation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109162"><FONT FACE="Palatino" SIZE=2>11.9.&#9;Wrapping/unwrapping private keys (RSA, Diffie-Hellman, and DSA)&#9;</FONT></A><br>
<li><A HREF="#_Toc410109163"><FONT FACE="Palatino" SIZE=2>11.10.&#9;About RC2&#9;</FONT></A><br>
<li><A HREF="#_Toc410109164"><FONT FACE="Palatino" SIZE=2>11.11.&#9;RC2 mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109165"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC2_PARAMS; CK_RC2_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109166"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC2_CBC_PARAMS; CK_RC2_CBC_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109167"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC2_MAC_GENERAL_PARAMS; CK_RC2_MAC_GENERAL_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109168"><FONT FACE="Palatino" SIZE=2>11.12.&#9;RC2 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109169"><I><FONT FACE="Palatino" SIZE=2>11.12.1.&#9;RC2 key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109170"><I><FONT FACE="Palatino" SIZE=2>11.12.2.&#9;RC2-ECB&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109171"><I><FONT FACE="Palatino" SIZE=2>11.12.3.&#9;RC2-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109172"><I><FONT FACE="Palatino" SIZE=2>11.12.4.&#9;RC2-CBC with PKCS padding&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109173"><I><FONT FACE="Palatino" SIZE=2>11.12.5.&#9;General-length RC2-MAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109174"><I><FONT FACE="Palatino" SIZE=2>11.12.6.&#9;RC2-MAC&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109175"><FONT FACE="Palatino" SIZE=2>11.13.&#9;RC4 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109176"><I><FONT FACE="Palatino" SIZE=2>11.13.1.&#9;RC4 key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109177"><I><FONT FACE="Palatino" SIZE=2>11.13.2.&#9;RC4&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109178"><FONT FACE="Palatino" SIZE=2>11.14.&#9;About RC5&#9;</FONT></A><br>
<li><A HREF="#_Toc410109179"><FONT FACE="Palatino" SIZE=2>11.15.&#9;RC5 mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109180"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC5_PARAMS; CK_RC5_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109181"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC5_CBC_PARAMS; CK_RC5_CBC_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109182"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_RC5_MAC_GENERAL_PARAMS; CK_RC5_MAC_GENERAL_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109183"><FONT FACE="Palatino" SIZE=2>11.16.&#9;RC5 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109184"><I><FONT FACE="Palatino" SIZE=2>11.16.1.&#9;RC5 key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109185"><I><FONT FACE="Palatino" SIZE=2>11.16.2.&#9;RC5-ECB&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109186"><I><FONT FACE="Palatino" SIZE=2>11.16.3.&#9;RC5-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109187"><I><FONT FACE="Palatino" SIZE=2>11.16.4.&#9;RC5-CBC with PKCS padding&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109188"><I><FONT FACE="Palatino" SIZE=2>11.16.5.&#9;General-length RC5-MAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109189"><I><FONT FACE="Palatino" SIZE=2>11.16.6.&#9;RC5-MAC&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109190"><FONT FACE="Palatino" SIZE=2>11.17.&#9;General block cipher mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109191"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_MAC_GENERAL_PARAMS; CK_MAC_GENERAL_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109192"><FONT FACE="Palatino" SIZE=2>11.18.&#9;General block cipher mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109193"><I><FONT FACE="Palatino" SIZE=2>11.18.1.&#9;General block cipher key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109194"><I><FONT FACE="Palatino" SIZE=2>11.18.2.&#9;General block cipher ECB&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109195"><I><FONT FACE="Palatino" SIZE=2>11.18.3.&#9;General block cipher CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109196"><I><FONT FACE="Palatino" SIZE=2>11.18.4.&#9;General block cipher CBC with PKCS padding&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109197"><I><FONT FACE="Palatino" SIZE=2>11.18.5.&#9;General-length general block cipher MAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109198"><I><FONT FACE="Palatino" SIZE=2>11.18.6.&#9;General block cipher MAC&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109199"><FONT FACE="Palatino" SIZE=2>11.19.&#9;Double-length DES mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109200"><I><FONT FACE="Palatino" SIZE=2>11.19.1.&#9;Double-length DES key generation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109201"><FONT FACE="Palatino" SIZE=2>11.20.&#9;SKIPJACK mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109202"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SKIPJACK_PRIVATE_WRAP_PARAMS; CK_SKIPJACK_PRIVATE_WRAP_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109203"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SKIPJACK_RELAYX_PARAMS; CK_SKIPJACK_RELAYX_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109204"><FONT FACE="Palatino" SIZE=2>11.21.&#9;SKIPJACK mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109205"><I><FONT FACE="Palatino" SIZE=2>11.21.1.&#9;SKIPJACK key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109206"><I><FONT FACE="Palatino" SIZE=2>11.21.2.&#9;SKIPJACK-ECB64&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109207"><I><FONT FACE="Palatino" SIZE=2>11.21.3.&#9;SKIPJACK-CBC64&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109208"><I><FONT FACE="Palatino" SIZE=2>11.21.4.&#9;SKIPJACK-OFB64&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109209"><I><FONT FACE="Palatino" SIZE=2>11.21.5.&#9;SKIPJACK-CFB64&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109210"><I><FONT FACE="Palatino" SIZE=2>11.21.6.&#9;SKIPJACK-CFB32&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109211"><I><FONT FACE="Palatino" SIZE=2>11.21.7.&#9;SKIPJACK-CFB16&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109212"><I><FONT FACE="Palatino" SIZE=2>11.21.8.&#9;SKIPJACK-CFB8&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109213"><I><FONT FACE="Palatino" SIZE=2>11.21.9.&#9;SKIPJACK-WRAP&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109214"><I><FONT FACE="Palatino" SIZE=2>11.21.10.&#9;SKIPJACK-PRIVATE-WRAP&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109215"><I><FONT FACE="Palatino" SIZE=2>11.21.11.&#9;SKIPJACK-RELAYX&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109216"><FONT FACE="Palatino" SIZE=2>11.22.&#9;BATON mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109217"><I><FONT FACE="Palatino" SIZE=2>11.22.1.&#9;BATON key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109218"><I><FONT FACE="Palatino" SIZE=2>11.22.2.&#9;BATON-ECB128&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109219"><I><FONT FACE="Palatino" SIZE=2>11.22.3.&#9;BATON-ECB96&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109220"><I><FONT FACE="Palatino" SIZE=2>11.22.4.&#9;BATON-CBC128&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109221"><I><FONT FACE="Palatino" SIZE=2>11.22.5.&#9;BATON-COUNTER&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109222"><I><FONT FACE="Palatino" SIZE=2>11.22.6.&#9;BATON-SHUFFLE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109223"><I><FONT FACE="Palatino" SIZE=2>11.22.7.&#9;BATON WRAP&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109224"><FONT FACE="Palatino" SIZE=2>11.23.&#9;JUNIPER mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109225"><I><FONT FACE="Palatino" SIZE=2>11.23.1.&#9;JUNIPER key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109226"><I><FONT FACE="Palatino" SIZE=2>11.23.2.&#9;JUNIPER-ECB128&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109227"><I><FONT FACE="Palatino" SIZE=2>11.23.3.&#9;JUNIPER-CBC128&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109228"><I><FONT FACE="Palatino" SIZE=2>11.23.4.&#9;JUNIPER-COUNTER&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109229"><I><FONT FACE="Palatino" SIZE=2>11.23.5.&#9;JUNIPER-SHUFFLE&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109230"><I><FONT FACE="Palatino" SIZE=2>11.23.6.&#9;JUNIPER WRAP&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109231"><FONT FACE="Palatino" SIZE=2>11.24.&#9;MD2 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109232"><I><FONT FACE="Palatino" SIZE=2>11.24.1.&#9;MD2&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109233"><I><FONT FACE="Palatino" SIZE=2>11.24.2.&#9;General-length MD2-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109234"><I><FONT FACE="Palatino" SIZE=2>11.24.3.&#9;MD2-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109235"><I><FONT FACE="Palatino" SIZE=2>11.24.4.&#9;MD2 key derivation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109236"><FONT FACE="Palatino" SIZE=2>11.25.&#9;MD5 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109237"><I><FONT FACE="Palatino" SIZE=2>11.25.1.&#9;MD5&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109238"><I><FONT FACE="Palatino" SIZE=2>11.25.2.&#9;General-length MD5-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109239"><I><FONT FACE="Palatino" SIZE=2>11.25.3.&#9;MD5-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109240"><I><FONT FACE="Palatino" SIZE=2>11.25.4.&#9;MD5 key derivation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109241"><FONT FACE="Palatino" SIZE=2>11.26.&#9;SHA-1 mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109242"><I><FONT FACE="Palatino" SIZE=2>11.26.1.&#9;SHA-1&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109243"><I><FONT FACE="Palatino" SIZE=2>11.26.2.&#9;General-length SHA-1-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109244"><I><FONT FACE="Palatino" SIZE=2>11.26.3.&#9;SHA-1-HMAC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109245"><I><FONT FACE="Palatino" SIZE=2>11.26.4.&#9;SHA-1 key derivation&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109246"><FONT FACE="Palatino" SIZE=2>11.27.&#9;FASTHASH mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109247"><I><FONT FACE="Palatino" SIZE=2>11.27.1.&#9;FASTHASH&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109248"><FONT FACE="Palatino" SIZE=2>11.28.&#9;Password-based encryption/authentication mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109249"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_PBE_PARAMS; CK_PBE_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109250"><FONT FACE="Palatino" SIZE=2>11.29.&#9;PKCS #5 and PKCS #5-style password-based encryption mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109251"><I><FONT FACE="Palatino" SIZE=2>11.29.1.&#9;MD2-PBE for DES-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109252"><I><FONT FACE="Palatino" SIZE=2>11.29.2.&#9;MD5-PBE for DES-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109253"><I><FONT FACE="Palatino" SIZE=2>11.29.3.&#9;MD5-PBE for CAST-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109254"><I><FONT FACE="Palatino" SIZE=2>11.29.4.&#9;MD5-PBE for CAST3-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109255"><I><FONT FACE="Palatino" SIZE=2>11.29.5.&#9;MD5-PBE for CAST128-CBC (CAST5-CBC)&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109256"><I><FONT FACE="Palatino" SIZE=2>11.29.6.&#9;SHA-1-PBE for CAST128-CBC (CAST5-CBC)&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109257"><FONT FACE="Palatino" SIZE=2>11.30.&#9;PKCS #12 password-based encryption/authentication mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109258"><I><FONT FACE="Palatino" SIZE=2>11.30.1.&#9;SHA-1-PBE for 128-bit RC4&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109259"><I><FONT FACE="Palatino" SIZE=2>11.30.2.&#9;SHA-1-PBE for 40-bit RC4&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109260"><I><FONT FACE="Palatino" SIZE=2>11.30.3.&#9;SHA-1-PBE for 3-key triple-DES-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109261"><I><FONT FACE="Palatino" SIZE=2>11.30.4.&#9;SHA-1-PBE for 2-key triple-DES-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109262"><I><FONT FACE="Palatino" SIZE=2>11.30.5.&#9;SHA-1-PBE for 128-bit RC2-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109263"><I><FONT FACE="Palatino" SIZE=2>11.30.6.&#9;SHA-1-PBE for 40-bit RC2-CBC&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109264"><I><FONT FACE="Palatino" SIZE=2>11.30.7.&#9;SHA-1-PBA for SHA-1-HMAC&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109265"><FONT FACE="Palatino" SIZE=2>11.31.&#9;SET mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109266"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_KEY_WRAP_SET_OAEP_PARAMS; CK_KEY_WRAP_SET_OAEP_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109267"><FONT FACE="Palatino" SIZE=2>11.32.&#9;SET mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109268"><I><FONT FACE="Palatino" SIZE=2>11.32.1.&#9;OAEP key wrapping for SET&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109269"><FONT FACE="Palatino" SIZE=2>11.33.&#9;LYNKS mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109270"><I><FONT FACE="Palatino" SIZE=2>11.33.1.&#9;LYNKS key wrapping&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109271"><FONT FACE="Palatino" SIZE=2>11.34.&#9;SSL mechanism parameters&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109272"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SSL3_RANDOM_DATA&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109273"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SSL3_MASTER_KEY_DERIVE_PARAMS; CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109274"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SSL3_KEY_MAT_OUT; CK_SSL3_KEY_MAT_OUT_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109275"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_SSL3_KEY_MAT_PARAMS; CK_SSL3_KEY_MAT_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109276"><FONT FACE="Palatino" SIZE=2>11.35.&#9;SSL mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109277"><I><FONT FACE="Palatino" SIZE=2>11.35.1.&#9;Pre_master key generation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109278"><I><FONT FACE="Palatino" SIZE=2>11.35.2.&#9;Master key derivation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109279"><I><FONT FACE="Palatino" SIZE=2>11.35.3.&#9;Key and MAC derivation&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109280"><I><FONT FACE="Palatino" SIZE=2>11.35.4.&#9;MD5 MACing in SSL 3.0&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109281"><I><FONT FACE="Palatino" SIZE=2>11.35.5.&#9;SHA-1 MACing in SSL 3.0&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109282"><FONT FACE="Palatino" SIZE=2>11.36.&#9;Parameters for miscellaneous simple key derivation mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109283"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_KEY_DERIVATION_STRING_DATA; CK_KEY_DERIVATION_STRING_DATA_PTR&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109284"><I><FONT FACE="Symbol" SIZE=2>¨</FONT><FONT FACE="Palatino" SIZE=2>&#9;CK_EXTRACT_PARAMS; CK_EXTRACT_PARAMS_PTR&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109285"><FONT FACE="Palatino" SIZE=2>11.37.&#9;Miscellaneous simple key derivation mechanisms&#9;</FONT></A><br><UL>

<li><A HREF="#_Toc410109286"><I><FONT FACE="Palatino" SIZE=2>11.37.1.&#9;Concatenation of a base key and another key&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109287"><I><FONT FACE="Palatino" SIZE=2>11.37.2.&#9;Concatenation of a base key and data&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109288"><I><FONT FACE="Palatino" SIZE=2>11.37.3.&#9;Concatenation of data and a base key&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109289"><I><FONT FACE="Palatino" SIZE=2>11.37.4.&#9;XORing of a key and data&#9;</I></FONT></A><br>
<li><A HREF="#_Toc410109290"><I><FONT FACE="Palatino" SIZE=2>11.37.5.&#9;Extraction of one key from another key&#9;</I></FONT></A><br></UL>

<li><A HREF="#_Toc410109291"><B><FONT FACE="Palatino" SIZE=2>12.&#9;Cryptoki tips and reminders&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410109292"><FONT FACE="Palatino" SIZE=2>12.1.&#9;Operations, sessions, and threads&#9;</FONT></A><br>
<li><A HREF="#_Toc410109293"><FONT FACE="Palatino" SIZE=2>12.2.&#9;Objects, attributes, and templates&#9;</FONT></A><br>
<li><A HREF="#_Toc410109294"><FONT FACE="Palatino" SIZE=2>12.3.&#9;Signing with recovery&#9;</FONT></A><br>
<li><A HREF="#_Toc410109295"><B><FONT FACE="Palatino" SIZE=2>Appendix A: Token Profiles&#9;</B></FONT></A><br>
<li><A HREF="#_Toc410109296"><B><FONT FACE="Palatino" SIZE=2>Appendix B: Comparison of Cryptoki and Other APIs&#9;</B></FONT></A><br>
<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><br></FONT><B><FONT FACE="Palatino" SIZE=4>List of Figures<br>
<ul>
<li><A HREF="#_Toc410108826"></B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Figure 1, General Cryptoki Model&#9;</FONT></A><br>
<li><A HREF="#_Toc410108827"><FONT FACE="Palatino" SIZE=2>Figure 2, Object Hierarchy&#9;</FONT></A><br>
<li><A HREF="#_Toc410108828"><FONT FACE="Palatino" SIZE=2>Figure 3, Read-Only Session States&#9;</FONT></A><br>
<li><A HREF="#_Toc410108829"><FONT FACE="Palatino" SIZE=2>Figure 4, Read/Write Session States&#9;</FONT></A><br>
<li><A HREF="#_Toc410108830"><FONT FACE="Palatino" SIZE=2>Figure 5, Object Attribute Hierarchy&#9;</FONT></A><br>
<li><A HREF="#_Toc410108831"><FONT FACE="Palatino" SIZE=2>Figure 6, Key Attribute Detail&#9;</FONT></A><br>
</ul>
</FONT><B><FONT FACE="Palatino" SIZE=4>List of Tables<br>
<ul>
<li><A HREF="#_Toc410108832"></B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Table 1, Symbols&#9;</FONT></A>
<li><A HREF="#_Toc410108833"><FONT FACE="Palatino" SIZE=2>Table 2, Prefixes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108834"><FONT FACE="Palatino" SIZE=2>Table 3, Character Set&#9;</FONT></A><br>
<li><A HREF="#_Toc410108835"><FONT FACE="Palatino" SIZE=2>Table 4, Read-Only Session States&#9;</FONT></A><br>
<li><A HREF="#_Toc410108836"><FONT FACE="Palatino" SIZE=2>Table 5, Read/Write Session States&#9;</FONT></A><br>
<li><A HREF="#_Toc410108837"><FONT FACE="Palatino" SIZE=2>Table 6, Access to Different Types Objects by Different Types of Sessions&#9;</FONT></A><br>
<li><A HREF="#_Toc410108838"><FONT FACE="Palatino" SIZE=2>Table 7, Session Events&#9;</FONT></A><br>
<li><A HREF="#_Toc410108839"><FONT FACE="Palatino" SIZE=2>Table 8, Summary of Cryptoki Functions&#9;</FONT></A><br>
<li><A HREF="#_Toc410108840"><FONT FACE="Palatino" SIZE=2>Table 9, Slot Information Flags&#9;</FONT></A><br>
<li><A HREF="#_Toc410108841"><FONT FACE="Palatino" SIZE=2>Table 10, Token Information Flags&#9;</FONT></A><br>
<li><A HREF="#_Toc410108842"><FONT FACE="Palatino" SIZE=2>Table 11, Session Information Flags&#9;</FONT></A><br>
<li><A HREF="#_Toc410108843"><FONT FACE="Palatino" SIZE=2>Table 12, Mechanism Information Flags&#9;</FONT></A><br>
<li><A HREF="#_Toc410108844"><FONT FACE="Palatino" SIZE=2>Table 13, C_Initialize Parameter Flags&#9;</FONT></A><br>
<li><A HREF="#_Toc410108845"><FONT FACE="Palatino" SIZE=2>Table 14, Common Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108846"><FONT FACE="Palatino" SIZE=2>Table 15, Data Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108847"><FONT FACE="Palatino" SIZE=2>Table 16, Common Certificate Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108848"><FONT FACE="Palatino" SIZE=2>Table 17, X.509 Certificate Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108849"><FONT FACE="Palatino" SIZE=2>Table 18, Common footnotes for key attribute tables&#9;</FONT></A><br>
<li><A HREF="#_Toc410108850"><FONT FACE="Palatino" SIZE=2>Table 19, Common Key Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108851"><FONT FACE="Palatino" SIZE=2>Table 20, Common Public Key Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108852"><FONT FACE="Palatino" SIZE=2>Table 21, RSA Public Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108853"><FONT FACE="Palatino" SIZE=2>Table 22, DSA Public Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108854"><FONT FACE="Palatino" SIZE=2>Table 23, ECDSA Public Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108855"><FONT FACE="Palatino" SIZE=2>Table 24, Diffie-Hellman Public Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108856"><FONT FACE="Palatino" SIZE=2>Table 25, KEA Public Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108857"><FONT FACE="Palatino" SIZE=2>Table 26, Common Private Key Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108858"><FONT FACE="Palatino" SIZE=2>Table 27, RSA Private Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108859"><FONT FACE="Palatino" SIZE=2>Table 28, DSA Private Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108860"><FONT FACE="Palatino" SIZE=2>Table 29, ECDSA Private Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108861"><FONT FACE="Palatino" SIZE=2>Table 30, Diffie-Hellman Private Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108862"><FONT FACE="Palatino" SIZE=2>Table 31, KEA Private Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108863"><FONT FACE="Palatino" SIZE=2>Table 32, Common Secret Key Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108864"><FONT FACE="Palatino" SIZE=2>Table 33, Generic Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108865"><FONT FACE="Palatino" SIZE=2>Table 34, RC2 Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108866"><FONT FACE="Palatino" SIZE=2>Table 35, RC4 Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108867"><FONT FACE="Palatino" SIZE=2>Table 36, RC4 Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108868"><FONT FACE="Palatino" SIZE=2>Table 37, DES Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108869"><FONT FACE="Palatino" SIZE=2>Table 38, DES2 Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108870"><FONT FACE="Palatino" SIZE=2>Table 39, DES3 Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108871"><FONT FACE="Palatino" SIZE=2>Table 40, CAST Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108872"><FONT FACE="Palatino" SIZE=2>Table 41, CAST3 Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108873"><FONT FACE="Palatino" SIZE=2>Table 42, CAST128 (CAST5) Secret Key Object Attributes&#9;</FONT></A><br>
<li><A HREF="#_Toc410108874"><FONT FACE="Palatino" SIZE=2>Table 43, IDEA Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108875"><FONT FACE="Palatino" SIZE=2>Table 44, CDMF Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108876"><FONT FACE="Palatino" SIZE=2>Table 45, SKIPJACK Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108877"><FONT FACE="Palatino" SIZE=2>Table 46, BATON Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108878"><FONT FACE="Palatino" SIZE=2>Table 47, JUNIPER Secret Key Object&#9;</FONT></A><br>
<li><A HREF="#_Toc410108879"><FONT FACE="Palatino" SIZE=2>Table 48, Mechanisms vs. Functions&#9;</FONT></A><br>
<li><A HREF="#_Toc410108880"><FONT FACE="Palatino" SIZE=2>Table 49, PKCS #1 RSA: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108881"><FONT FACE="Palatino" SIZE=2>Table 50, ISO/IEC 9796 RSA: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108882"><FONT FACE="Palatino" SIZE=2>Table 51, X.509 (Raw) RSA: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108883"><FONT FACE="Palatino" SIZE=2>Table 52, PKCS #1 RSA Signatures with MD2, MD5, or SHA-1: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108884"><FONT FACE="Palatino" SIZE=2>Table 53, DSA: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108885"><FONT FACE="Palatino" SIZE=2>Table 54, DSA with SHA-1: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108886"><FONT FACE="Palatino" SIZE=2>Table 55, FORTEZZA Timestamp: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108887"><FONT FACE="Palatino" SIZE=2>Table 56, ECDSA: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108888"><FONT FACE="Palatino" SIZE=2>Table 57, ECDSA with SHA-1: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108889"><FONT FACE="Palatino" SIZE=2>Table 58, RC2-ECB: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108890"><FONT FACE="Palatino" SIZE=2>Table 59, RC2-CBC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108891"><FONT FACE="Palatino" SIZE=2>Table 60, RC2-CBC with PKCS Padding: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108892"><FONT FACE="Palatino" SIZE=2>Table 61, General-length RC2-MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108893"><FONT FACE="Palatino" SIZE=2>Table 62, RC2-MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108894"><FONT FACE="Palatino" SIZE=2>Table 63, RC4: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108895"><FONT FACE="Palatino" SIZE=2>Table 64, RC5-ECB: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108896"><FONT FACE="Palatino" SIZE=2>Table 65, RC5-CBC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108897"><FONT FACE="Palatino" SIZE=2>Table 66, RC5-CBC with PKCS Padding: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108898"><FONT FACE="Palatino" SIZE=2>Table 67, General-length RC2-MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108899"><FONT FACE="Palatino" SIZE=2>Table 68, RC5-MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108900"><FONT FACE="Palatino" SIZE=2>Table 69, General Block Cipher ECB: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108901"><FONT FACE="Palatino" SIZE=2>Table 70, General Block Cipher CBC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108902"><FONT FACE="Palatino" SIZE=2>Table 71, General Block Cipher CBC with PKCS Padding: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108903"><FONT FACE="Palatino" SIZE=2>Table 72, General-length General Block Cipher MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108904"><FONT FACE="Palatino" SIZE=2>Table 73, General Block Cipher MAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108905"><FONT FACE="Palatino" SIZE=2>Table 74, SKIPJACK-ECB64: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108906"><FONT FACE="Palatino" SIZE=2>Table 75, SKIPJACK-CBC64: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108907"><FONT FACE="Palatino" SIZE=2>Table 76, SKIPJACK-OFB64: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108908"><FONT FACE="Palatino" SIZE=2>Table 77, SKIPJACK-CFB64: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108909"><FONT FACE="Palatino" SIZE=2>Table 78, SKIPJACK-CFB32: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108910"><FONT FACE="Palatino" SIZE=2>Table 79, SKIPJACK-CFB16: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108911"><FONT FACE="Palatino" SIZE=2>Table 80, SKIPJACK-CFB8: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108912"><FONT FACE="Palatino" SIZE=2>Table 81, BATON-ECB128: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108913"><FONT FACE="Palatino" SIZE=2>Table 82, BATON-ECB96: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108914"><FONT FACE="Palatino" SIZE=2>Table 83, BATON-CBC128: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108915"><FONT FACE="Palatino" SIZE=2>Table 84, BATON-COUNTER: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108916"><FONT FACE="Palatino" SIZE=2>Table 85, BATON-SHUFFLE: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108917"><FONT FACE="Palatino" SIZE=2>Table 86, JUNIPER-ECB128: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108918"><FONT FACE="Palatino" SIZE=2>Table 87, JUNIPER-CBC128: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108919"><FONT FACE="Palatino" SIZE=2>Table 88, JUNIPER-COUNTER: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108920"><FONT FACE="Palatino" SIZE=2>Table 89, JUNIPER-SHUFFLE: Data and Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108921"><FONT FACE="Palatino" SIZE=2>Table 90, MD2: Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108922"><FONT FACE="Palatino" SIZE=2>Table 91, General-length MD2-HMAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108923"><FONT FACE="Palatino" SIZE=2>Table 92, MD5: Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108924"><FONT FACE="Palatino" SIZE=2>Table 93, General-length MD5-HMAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108925"><FONT FACE="Palatino" SIZE=2>Table 94, SHA-1: Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108926"><FONT FACE="Palatino" SIZE=2>Table 95, General-length SHA-1-HMAC: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108927"><FONT FACE="Palatino" SIZE=2>Table 96, FASTHASH: Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108928"><FONT FACE="Palatino" SIZE=2>Table 97, MD5 MACing in SSL 3.0: Key And Data Length&#9;</FONT></A><br>
<li><A HREF="#_Toc410108929"><FONT FACE="Palatino" SIZE=2>Table 98, SHA-1 MACing in SSL 3.0: Key And Data Length&#9;</FONT></A><br>
</ul>
</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc322855256"><A NAME="_Toc322945052"><A NAME="_Toc323000665"><A NAME="_Toc323024025"><A NAME="_Toc323205356"><A NAME="_Toc323610785"><A NAME="_Toc383864796"><A NAME="_Toc385057783"><A NAME="_Ref399824728"><A NAME="_Toc405794604"><A NAME="_Toc410108930">1.&#9;Scope</A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This standard specifies an application programming interface (API), called &quot;Cryptoki,&quot; to devices which hold cryptographic information and perform cryptographic functions.  Cryptoki, pronounced &quot;crypto-key&quot; and short for &quot;cryptographic token interface,&quot; follows a simple object-based approach, addressing the goals of technology independence (any kind of device) and resource sharing (multiple applications accessing multiple devices), presenting to applications a common, logical view of the device called a &quot;cryptographic token&quot;.</P>
<P ALIGN="JUSTIFY">This document specifies the data types and functions available to an application requiring cryptographic services using the ANSI C programming language.  These data types and functions will typically be provided via C header files by the supplier of a Cryptoki library.  Generic ANSI C header files for Cryptoki are available from RSADSI’s webserver.  To get them, go to RSADSI’s homepage (</FONT><FONT FACE="Courier New" SIZE=2>http://www.rsa.com</FONT><FONT FACE="Palatino" SIZE=2>); then go to RSA Laboratories; then go to the PKCS page.  This document and up-to-date errata for Cryptoki will also be available from the same place.</P>
<P ALIGN="JUSTIFY">Additional documents may provide a generic, language-independent Cryptoki interface and/or bindings between Cryptoki and other programming languages.</P>
<P ALIGN="JUSTIFY">Cryptoki isolates an application from the details of the cryptographic device.  The application does not have to change to interface to a different type of device or to run in a different environment; thus, the application is portable.  How Cryptoki provides this isolation is beyond the scope of this document, although some conventions for the support of multiple types of device will be addressed here and possibly in a separate document.</P>
<P ALIGN="JUSTIFY">A number of  cryptographic mechanisms (algorithms) are supported in this version.  In addition, new mechanisms can be added later without changing the general interface.  It is possible that additional mechanisms will be published from time to time in separate documents; it is also possible for token vendors to define their own mechanisms (although, for the sake of interoperability, registration through the PKCS process is preferable).</P>
<P ALIGN="JUSTIFY">Cryptoki Version 2.01 is intended for cryptographic devices associated with a single user, so some features that might be included in a general-purpose interface are omitted.  For example, Cryptoki Version 2.01 does not have a means of distinguishing multiple users.  The focus is on a single user’s keys and perhaps a small number of public-key certificates related to them. Moreover, the emphasis is on cryptography.  While the device may perform useful non-cryptographic functions, such functions are left to other interfaces.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc319287633"><A NAME="_Toc319313474"><A NAME="_Toc319313667"><A NAME="_Toc319315660"><A NAME="_Ref320326962"><A NAME="_Toc322855257"><A NAME="_Toc322945053"><A NAME="_Toc323000666"><A NAME="_Toc323024026"><A NAME="_Toc323205357"><A NAME="_Toc323610786"><A NAME="_Toc383864797"><A NAME="_Toc385057784"><A NAME="_Toc405794605"><A NAME="_Toc410108931">2.&#9;References</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P><UL>

<UL>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">ANSI C&#9;ANSI/ISO.  <I>ANSI/ISO 9899: American National Standard for Programming Languages – C</I>.  1990.</P>
<P ALIGN="JUSTIFY">ANSI X9.9&#9;ANSI.  <I>American National Standard X9.9: Financial Institution Message Authentication Code</I>.  1982<I>.</P>
</I><P ALIGN="JUSTIFY">ANSI X9.17&#9;ANSI.  <I>American National Standard X9.17: Financial Institution Key Management (Wholesale)</I>.  1985<I>.</P>
</I><P ALIGN="JUSTIFY">ANSI X9.31&#9;Accredited Standards Committee X9.  <I>Public Key Cryptography Using Reversible Algorithms for the Financial Services Industry: Part 1: The RSA Signature Algorithm.</I>  Working draft, March 7, 1993.</P>
<P ALIGN="JUSTIFY">ANSI X9.42&#9;Accredited Standards Committee X9<I>.  Public Key Cryptography for the Financial Services Industry: Management of Symmetric Algorithm Keys Using Diffie-Hellman</I>.  Working draft, September 21, 1994.</P>
<P ALIGN="JUSTIFY">ANSI X9.62&#9;Accredited Standards Committee X9.  <I>Public Key Cryptography for the Financial Services Industry: the Elliptic Curve Digital Signature Algorithm (ECDSA)&copy;</I>.  Working draft, November 17, 1997.</P>
<P ALIGN="JUSTIFY">CDPD&#9;Ameritech Mobile Communications et al.  <I>Cellular Digital Packet Data System Specifications: Part 406: Airlink Security.  </I>1993.</P>
<P ALIGN="JUSTIFY">FIPS PUB 46–2&#9;National Institute of Standards and Technology (formerly National Bureau of Standards).  <I>FIPS PUB 46-2: Data Encryption Standard.  </I>December 30, 1993.</P>
<P ALIGN="JUSTIFY">FIPS PUB 74&#9;National Institute of Standards and Technology (formerly National Bureau of Standards).  <I>FIPS PUB 74: Guidelines for Implementing and Using the NBS Data Encryption Standard.  </I>April 1, 1981.</P>
<P ALIGN="JUSTIFY">FIPS PUB 81&#9;National Institute of Standards and Technology (formerly National Bureau of Standards).  <I>FIPS PUB 81: DES Modes of Operation.  </I>December 1980.</P>
<P ALIGN="JUSTIFY">FIPS PUB 113&#9;National Institute of Standards and Technology (formerly National Bureau of Standards).  <I>FIPS PUB 113: Computer Data Authentication.  </I>May 30, 1985.</P>
<P ALIGN="JUSTIFY">FIPS PUB 180-1&#9;National Institute of Standards and Technology.  <I>FIPS PUB 180-1: Secure Hash Standard.</I>  April 17, 1995.</P>
<P ALIGN="JUSTIFY">FIPS PUB 186&#9;National Institute of Standards and Technology.  <I>FIPS PUB 186: Digital Signature Standard.  </I>May 19, 1994.</P>
<P ALIGN="JUSTIFY">FORTEZZA CIPG&#9;NSA, Workstation Security Products.  <I>FORTEZZA Cryptologic Interface Programmers Guide, Revision 1.52</I>.  November 1995.</P>
<P ALIGN="JUSTIFY">GCS-API&#9;X/Open Company Ltd.  <I>Generic Cryptographic Service API (GCS-API), Base - Draft 2</I>.  February 14, 1995.</P>
<P ALIGN="JUSTIFY">ISO 7816-1&#9;ISO.  <I>International Standard 7816-1: Identification Cards — Integrated Circuit(s) with Contacts — Part 1: Physical Characteristics.  </I>1987.</P>
<P ALIGN="JUSTIFY">ISO 7816-4&#9;ISO.  <I>Identification Cards — Integrated Circuit(s) with Contacts — Part 4: Inter-industry Commands for Interchange.</I>  Committee draft, 1993.</P>
<P ALIGN="JUSTIFY">ISO/IEC 9796&#9;ISO/IEC.  <I>International Standard 9796: Digital Signature Scheme Giving Message Recovery.  </I>July 1991.</P>
<P ALIGN="JUSTIFY">PCMCIA&#9;Personal Computer Memory Card International Association.  <I>PC Card Standard. </I> Release 2.1, July 1993.</P>
<P ALIGN="JUSTIFY">PKCS #1&#9;RSA Laboratories.  <I>RSA Encryption Standard. </I> Version 1.5, November 1993.</P>
<P ALIGN="JUSTIFY">PKCS #3&#9;RSA Laboratories.  <I>Diffie-Hellman Key-Agreement Standard.</I>  Version 1.4, November 1993.</P>
<P ALIGN="JUSTIFY">PKCS #5&#9;RSA Laboratories.  <I>Password-Based Encryption Standard</I>.  Version 1.5, November 1993.</P>
<P ALIGN="JUSTIFY">PKCS #7&#9;RSA Laboratories.  <I>Cryptographic Message Syntax Standard.</I>  Version 1.5, November 1993.</P>
<P ALIGN="JUSTIFY">PKCS #8&#9;RSA Laboratories.  <I>Private-Key Information Syntax Standard</I>.  Version 1.2, November 1993.</P>
<P ALIGN="JUSTIFY">PKCS #12 draft&#9;RSA Laboratories.  <I>Personal Information Exchange Syntax Standard</I>.  Version 1.0 draft, April 1997.</P>
<P ALIGN="JUSTIFY">RFC 1319&#9;B. Kaliski.  <I>RFC 1319: The MD2 Message-Digest Algorithm.</I>  RSA Laboratories, April 1992.</P>
<P ALIGN="JUSTIFY">RFC 1321&#9;R. Rivest.  <I>RFC 1321: The MD5 Message-Digest Algorithm.</I>  MIT Laboratory for Computer Science and RSA Data Security, Inc., April 1992.</P>
<P ALIGN="JUSTIFY">RFC 1421&#9;J. Linn.  <I>RFC 1421: Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures.</I>  IAB IRTF PSRG, IETF PEM WG, February 1993.</P>
<P ALIGN="JUSTIFY">RFC 1423&#9;D. Balenson.  <I>RFC 1423: Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers.</I>  TIS and IAB IRTF PSRG, IETF PEM WG, February 1993.</P>
<P ALIGN="JUSTIFY">RFC 1508&#9;J. Linn.  <I>RFC 1508: Generic Security Services Application Programming Interface.</I>  Geer Zolot Associates, September 1993.</P>
<P ALIGN="JUSTIFY">RFC 1509&#9;J. Wray.  <I>RFC 1509: Generic Security Services API: C-bindings. </I> Digital Equipment Corporation, September 1993.</P>
<P ALIGN="JUSTIFY">X.500&#9;ITU-T (formerly CCITT).  <I>Recommendation X.500: The Directory—Overview of Concepts and Services.</I>  1988.</P>
<P ALIGN="JUSTIFY">X.509<I>&#9;</I>ITU-T (formerly CCITT).  <I>Recommendation X.509: The Directory—Authentication Framework.</I>  1993.  (Proposed extensions to X.509 are given in <I>ISO/IEC 9594-8 PDAM 1: Information Technology—Open Systems Interconnection—The Directory: Authentication Framework—Amendment 1: Certificate Extensions.  1994</I>.)</P>
<P ALIGN="JUSTIFY">X.680&#9;ITU-T (formerly CCITT).  <I>Recommendation X.680: Information Technology-- Abstract Syntax Notation One (ASN.1): Specification of Basic Notation. </I> July 1994.</P>
<P ALIGN="JUSTIFY">X.690&#9;ITU-T (formerly CCITT).  <I>Recommendation X.690: Information Technology—ASN.1 Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER).</I>  July 1994.</P></UL>
</UL>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc319287634"><A NAME="_Toc319313475"><A NAME="_Toc319313668"><A NAME="_Toc319315661"><A NAME="_Ref320327131"><A NAME="_Toc322855258"><A NAME="_Toc322945054"><A NAME="_Toc323000667"><A NAME="_Toc323024027"><A NAME="_Toc323205358"><A NAME="_Toc323610787"><A NAME="_Toc383864798"><A NAME="_Toc385057785"><A NAME="_Toc405794606"><A NAME="_Toc410108932">3.&#9;Definitions</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For the purposes of this standard, the following definitions apply:</P><ul>

<B><P>&#9;API</B>&#9;Application programming interface.</P>
<B><P>&#9;Application</B>&#9;Any computer program that calls the Cryptoki interface.</P>
<B><P>&#9;ASN.1</B>&#9;Abstract Syntax Notation One, as defined in X.680.</P>
<B><P>&#9;Attribute&#9;</B>A characteristic of an object.</P>
<P>&#9;<B>BATON</B>&#9;MISSI’s BATON block cipher.</P>
<B><P>&#9;BER</B>&#9;Basic Encoding Rules, as defined in X.690.</P>
<P>&#9;<B>CAST</B>&#9;Entrust Technologies’ proprietary symmetric block cipher.</P>
<P>&#9;<B>CAST3</B>&#9;Entrust Technologies’ proprietary symmetric block cipher.</P>
<P>&#9;<B>CAST5</B>&#9;Another name for Entrust Technologies’ symmetric block cipher CAST128.  CAST128 is the preferred name.</P>
<P>&#9;<B>CAST128</B>&#9;Entrust Technologies’ symmetric block cipher.</P>
<B><P>&#9;CBC&#9;</B>Cipher-Block Chaining mode, as defined in FIPS PUB 81.</P>
<B><P>&#9;CDMF&#9;</B>Commercial Data Masking Facility, a block encipherment method specified by International Business Machines Corporation and based on DES.</P>
<B><P>&#9;Certificate</B>&#9;A signed message binding a subject name and a public key.</P>
<B><P>&#9;Cryptographic Device</B>&#9;A device storing cryptographic information and possibly performing cryptographic functions.  May be implemented as a smart card, smart disk, PCMCIA card, or with some other technology, including software-only.</P>
<B><P>&#9;Cryptoki&#9;</B>The Cryptographic Token Interface defined in this standard.</P>
<B><P>&#9;Cryptoki library</B>&#9;A library that implements the functions specified in this standard.</P>
<B><P>&#9;DER</B>&#9;Distinguished Encoding Rules, as defined in X.690.</P>
<B><P>&#9;DES&#9;</B>Data Encryption Standard, as defined in FIPS PUB 46-2.</P>
<B><P>&#9;DSA&#9;</B>Digital Signature Algorithm, as defined in FIPS PUB 186.</P>
<B><P>&#9;ECB</B>&#9;Electronic Codebook mode, as defined in FIPS PUB 81.</P>
<P>&#9;<B>ECDSA</B>&#9;Elliptic Curve DSA, as in ANSI X9.62.</P>
<P>&#9;<B>FASTHASH</B>&#9;MISSI’s FASTHASH message-digesting algorithm.</P>
<B><P>&#9;IDEA&#9;</B>Ascom Systec’s symmetric block cipher.</P>
<P>&#9;<B>JUNIPER</B>&#9;MISSI’s JUNIPER block cipher.</P>
<P>&#9;<B>KEA</B>&#9;MISSI’s Key Exchange Algorithm.</P>
<B><P>&#9;LYNKS&#9;</B>A smart card manufactured by SPYRUS.</P>
<B><P>&#9;MAC</B>&#9;Message Authentication Code, as defined in ANSI X9.9.</P>
<B><P>&#9;MD2&#9;</B>RSA Data Security, Inc.'s MD2 message-digest algorithm, as defined in RFC 1319.</P>
<B><P>&#9;MD5&#9;</B>RSA Data Security, Inc.'s MD5 message-digest algorithm, as defined in RFC 1321.</P>
<B><P>&#9;Mechanism</B>&#9;A process for implementing a cryptographic operation.</P>
<P>&#9;<B>OAEP</B>&#9;Optimal Asymmetric Encryption Padding for RSA.</P>
<B><P>&#9;Object</B>&#9;An item that is stored on a token.  May be data, a certificate, or a key.</P>
<B><P>&#9;PIN</B>&#9;Personal Identification Number.</P>
<B><P>&#9;RSA</B>&#9;The RSA public-key cryptosystem.</P>
<B><P>&#9;RC2</B>&#9;RSA Data Security’s RC2 symmetric block cipher.</P>
<B><P>&#9;RC4</B>&#9;RSA Data Security’s proprietary RC4 symmetric stream cipher.</P>
<P>&#9;<B>RC5</B>&#9;RSA Data Security’s RC5 symmetric block cipher.</P>
<B><P>&#9;Reader</B>&#9;The means by which information is exchanged with a device.</P>
<B><P>&#9;Session</B>&#9;A logical connection between an application and a token.</P>
<P>&#9;<B>SET</B>&#9;The Secure Electronic Transaction protocol.</P>
<P>&#9;<B>SHA-1</B>&#9;The (revised) Secure Hash Algorithm, as defined in FIPS PUB 180-1.</P>
<B><P>&#9;Slot</B>&#9;A logical reader that potentially contains a token.</P>
<P>&#9;<B>SKIPJACK</B>&#9;MISSI’s SKIPJACK block cipher.</P>
<P>&#9;<B>SSL</B>&#9;The Secure Sockets Layer 3.0 protocol.</P>
<P>&#9;<B>Subject Name</B>&#9;The X.500 distinguished name of the entity to which a key is assigned.</P>
<B><P>&#9;SO</B>&#9;A Security Officer user.</P>
<B><P>&#9;Token</B>&#9;The logical view of a cryptographic device defined by Cryptoki.</P>
<B><P>&#9;User</B>&#9;The person using an application that interfaces to Cryptoki.</P>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc319287635"><A NAME="_Toc319313476"><A NAME="_Toc319313669"><A NAME="_Toc319315662"><A NAME="_Ref320327683"><A NAME="_Toc322855259"><A NAME="_Toc322945055"><A NAME="_Toc323000668"><A NAME="_Toc323024028"><A NAME="_Toc323205359"><A NAME="_Toc323610788"><A NAME="_Toc383864799"><A NAME="_Toc385057786"><A NAME="_Toc405794607"><A NAME="_Toc410108933">4.&#9;Symbols and abbreviations</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following symbols are used in this standard:</P>
<B><P><A NAME="_Toc405794963"><A NAME="_Toc410108832">Table 1, Symbols</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=178>
<TR><TD WIDTH="36%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Symbol</B></FONT></TD>
<TD WIDTH="64%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Definition</B></FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>N/A</FONT></TD>
<TD WIDTH="64%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Not applicable</FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/O</FONT></TD>
<TD WIDTH="64%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Read-only</FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/W</FONT></TD>
<TD WIDTH="64%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Read/write</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The following prefixes are used in this standard:</P>
<B><P><A NAME="_Toc405794964"><A NAME="_Toc410108833">Table 2, Prefixes</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=252>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Prefix</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Description</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Function</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Data type or general constant</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Attribute</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKC_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Certificate type</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Bit flag</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKK_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key type</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKM_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Mechanism type</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKN_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Notification</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKO_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Object class</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKS_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Session state</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKR_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Return value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKU_</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>User type</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>h</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a handle</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ul</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a CK_ULONG</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>p</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a pointer</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>pb</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a pointer to a CK_BYTE</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ph</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a pointer to a handle</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>pul</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>a pointer to a CK_ULONG</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">Cryptoki is based on ANSI C types, and defines the following data types:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P><A NAME="CK_BYTE"></A>/* an unsigned 8-bit value */</P>
<P>typedef unsigned char CK_BYTE;</P>

<P>/* an unsigned 8-bit character */</P>
<P>typedef CK_BYTE CK_CHAR;</P>

<P>/* a BYTE-sized Boolean flag */</P>
<P>typedef CK_BYTE CK_BBOOL;</P>

<P>/* an unsigned value, at least 32 bits long */</P>
<P>typedef unsigned long int CK_ULONG;</P>

<P>/* a signed value, the same size as a CK_ULONG */</P>
<P>typedef long int CK_LONG;</P>

<P>/* at least 32 bits; each bit is a Boolean flag */</P>
<P>typedef CK_ULONG CK_FLAGS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki also uses pointers to some of these data types, as well as to the type </FONT><FONT FACE="Courier New" SIZE=2>void</FONT><FONT FACE="Palatino" SIZE=2>, which are implementation-dependent.  These pointer types are:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_BYTE_PTR      /* Pointer to a CK_BYTE */</P>
<P>CK_CHAR_PTR      /* Pointer to a CK_CHAR */</P>
<P>CK_ULONG_PTR     /* Pointer to a CK_ULONG */</P>
<P>CK_VOID_PTR      /* Pointer to a void */</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki also defines a pointer to a CK_VOID_PTR, which is implementation-dependent:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_VOID_PTR_PTR  /* Pointer to a CK_VOID_PTR */</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In addition, Cryptoki defines a C-style NULL pointer, which is distinct from any valid pointer:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>NULL_PTR         /* A NULL pointer */</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">It follows that many of the data and pointer types will vary somewhat from one environment to another (<I>e.g.</I>, a CK_ULONG will sometimes be 32 bits, and sometimes perhaps 64 bits).  However, these details should not affect an application, assuming it is compiled with Cryptoki header files consistent with the Cryptoki library to which the application is linked.</P>
<P ALIGN="JUSTIFY">All numbers and values expressed in this document are decimal, unless they are preceded by &quot;0x&quot;, in which case they are hexadecimal values.</P>
<P ALIGN="JUSTIFY">The <B>CK_CHAR</B> data type holds characters from the following table, taken from ANSI C:</P>
<B><P><A NAME="_Ref383947636"><A NAME="_Ref320504353"><A NAME="_Toc323204874"><A NAME="_Toc383864504"><A NAME="_Toc405794965"><A NAME="_Toc410108834">Table 3</A>, Character Set</A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=480>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Category</B></FONT></TD>
<TD WIDTH="73%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Characters</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Letters</FONT></TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Numbers</FONT></TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0 1 2 3 4 5 6 7 8 9</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Graphic characters</FONT></TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>! &quot; # % &amp; ‘ ( ) * + , - . / : ; &lt; = &gt; ? [ \ ] ^ _ { | } ~</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Blank character</FONT></TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>‘ ‘</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">In Cryptoki, a flag is a Boolean flag that can be TRUE or FALSE.  A zero value means the flag is FALSE, and a nonzero value means the flag is TRUE.  Cryptoki defines these macros, if needed:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#ifndef FALSE</P>
<P>#define FALSE 0</P>
<P>#endif</P>

<P>#ifndef TRUE</P>
<P>#define TRUE (!FALSE)</P>
<P>#endif</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Portable computing devices such as smart cards, PCMCIA cards, and smart diskettes are ideal tools for implementing public-key cryptography, as they provide a way to store the private-key component of a public-key/private-key pair securely, under the control of a single user.  With such a device, a cryptographic application, rather than performing cryptographic operations itself, utilizes the device to perform the operations, with sensitive information such as private keys never being revealed.  As more applications are developed for public-key cryptography, a standard programming interface for these devices becomes increasingly valuable.  This standard addresses this need.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc410108934">5.&#9;General overview</A></P><ul>
<ul>

</FONT><FONT FACE="Palatino"><P><A NAME="_Toc319287638"><A NAME="_Toc319313479"><A NAME="_Toc319313672"><A NAME="_Toc319315665"><A NAME="_Toc322855261"><A NAME="_Toc322945057"><A NAME="_Toc323000670"><A NAME="_Toc323024030"><A NAME="_Toc323205361"><A NAME="_Toc323610790"><A NAME="_Toc383864801"><A NAME="_Toc385057788"><A NAME="_Toc405794609"><A NAME="_Toc410108935">5.1.&#9;Design goals</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki was intended from the beginning to be an interface between applications and all kinds of portable cryptographic devices, such as those based on smart cards, PCMCIA cards, and smart diskettes.  There are already standards (de facto or official) for interfacing to these devices at some level.  For instance, the mechanical characteristics and electrical connections are well-defined, as are the methods for supplying commands and receiving results.  (See, for example, ISO 7816, or the PCMCIA specifications.)</P>
<P ALIGN="JUSTIFY">What remained to be defined were particular commands for performing cryptography.  It would not be enough simply to define command sets for each kind of device, as that would not solve the general problem of an <I>application</I> interface independent of the device.  To do so is still a long-term goal, and would certainly contribute to interoperability.  The primary goal of Cryptoki was a lower-level programming interface that abstracts the details of the devices, and presents to the application a common model of the cryptographic device, called a &quot;cryptographic token&quot; (or simply &quot;token&quot;).</P>
<P ALIGN="JUSTIFY">A secondary goal was resource-sharing.  As desktop multi-tasking operating systems become more popular, a single device should be shared between more than one application.  In addition, an application should be able to interface to more than one device at a given time.</P>
<P ALIGN="JUSTIFY">It is not the goal of Cryptoki to be a generic interface to cryptographic operations or security services, although one certainly could build such operations and services with the functions that Cryptoki provides.  Cryptoki is intended to complement, not compete with, such emerging and evolving interfaces as &quot;Generic Security Services Application Programming Interface&quot; (RFC 1508 and RFC 1509) and &quot;Generic Cryptographic Service API&quot; (GCS-API) from X/Open.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287639"><A NAME="_Toc319313480"><A NAME="_Toc319313673"><A NAME="_Toc319315666"><A NAME="_Toc322855262"><A NAME="_Toc322945058"><A NAME="_Toc323000671"><A NAME="_Toc323024031"><A NAME="_Toc323205362"><A NAME="_Toc323610791"><A NAME="_Toc383864802"><A NAME="_Toc385057789"><A NAME="_Toc405794610"><A NAME="_Toc410108936">5.2.&#9;General model</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki's general model is illustrated in the following figure. The model begins with one or more applications that need to perform certain cryptographic operations, and ends with one or more cryptographic devices, on which some or all of the operations are actually performed.  A user may or may not be associated with an application.</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image1.gif" WIDTH=576 HEIGHT=420></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108826">Figure 1, General Cryptoki Model</A></P>
</B><P ALIGN="JUSTIFY">Cryptoki provides an interface to one or more cryptographic devices that are active in the system through a number of &quot;slots&quot;.  Each slot, which corresponds to a physical reader or other device interface, may contain a token.  A token is typically &quot;present in the slot&quot; when a cryptographic device is present in the reader.  Of course, since Cryptoki provides a logical view of slots and tokens, there may be other physical interpretations.  It is possible that multiple slots may share the same physical reader.  The point is that a system has some number of slots, and applications can connect to tokens in any or all of those slots.</P>
<P ALIGN="JUSTIFY">A cryptographic device can perform some cryptographic operations, following a certain command set; these commands are typically passed through standard device drivers, for instance PCMCIA card services or socket services.  Cryptoki makes each cryptographic device look logically like every other device, regardless of the implementation technology.  Thus the application need not interface directly to the device drivers (or even know which ones are involved); Cryptoki hides these details.  Indeed, the underlying &quot;device&quot; may be implemented entirely in software (for instance, as a process running on a server)—no special hardware is necessary.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287640"><A NAME="_Toc319313481"><A NAME="_Toc319313674"><A NAME="_Toc319315667">Cryptoki is likely to be implemented as a library supporting the functions in the interface, and applications will be linked to the library.  An application may be linked to Cryptoki directly; alternatively, Cryptoki can be a so-called &quot;shared&quot; library (or dynamic link library), in which case the application would link the library dynamically.  Shared libraries are fairly straightforward to produce in operating systems such as Microsoft Windows and OS/2, and can be achieved without too much difficulty in UNIX and DOS systems.</P>
<P ALIGN="JUSTIFY">The dynamic approach certainly has advantages as new libraries are made available, but from a security perspective, there are some drawbacks.  In particular, if a library is easily replaced, then there is the possibility that an attacker can substitute a rogue library that intercepts a user’s PIN.  From a security perspective, therefore, direct linking is generally preferable, although code-signing techniques can prevent many of the security risks of dynamic linking.  In any case, whether the linking is direct or dynamic, the programming interface between the application and a Cryptoki library remains the same.</P>
<P ALIGN="JUSTIFY">The kinds of devices and capabilities supported will depend on the particular Cryptoki library.  This standard specifies only the interface to the library, not its features.  In particular, not all libraries will support all the mechanisms (algorithms) defined in this interface (since not all tokens are expected to support all the mechanisms), and libraries will likely support only a subset of all the kinds of cryptographic devices that are available.  (The more kinds, the better, of course, and it is anticipated that libraries will be developed supporting multiple kinds of token, rather than just those from a single vendor.) It is expected that as applications are developed that interface to Cryptoki, standard library and token &quot;profiles&quot; will emerge.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855263"><A NAME="_Toc322945059"><A NAME="_Toc323000672"><A NAME="_Toc323024032"><A NAME="_Toc323205363"><A NAME="_Toc323610792"><A NAME="_Toc383864803"><A NAME="_Toc385057790"><A NAME="_Toc405794611"><A NAME="_Toc410108937">5.3.&#9;Logical view of a token</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki’s logical view of a token is a device that stores objects and can perform cryptographic functions.  Cryptoki defines three classes of object:  data, certificates, and keys. A data object is defined by an application. A certificate object stores a public-key certificate. A key object stores a cryptographic key. The key may be a public key, a private key, or a secret key; each of these types of keys has subtypes for use in specific mechanisms.  This view is illustrated in the following figure:</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image2.gif" WIDTH=576 HEIGHT=192></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108827">Figure 2, Object Hierarchy</A></P>
</B><P ALIGN="JUSTIFY">Objects are also classified according to their lifetime and visibility.  &quot;Token objects&quot; are visible to all applications connected to the token that have sufficient permission, and remain on the token even after the &quot;sessions&quot; (connections between an application and the token) are closed and the token is removed from its slot.  &quot;Session objects&quot; are more temporary: whenever a session is closed by any means, all session objects created by that session are automatically destroyed.  In addition, session objects are only visible to the application which created them.</P>
<P ALIGN="JUSTIFY">Further classification defines access requirements.  Applications are not required to log into the token to view &quot;public objects&quot;; however, to view &quot;private objects&quot;, a user must be authenticated to the token by a PIN or some other token-dependent method (for example, a biometric device).</P>
<P ALIGN="JUSTIFY">See Table 6 on page </FONT><A HREF="#_Ref398548479">*</A><FONT FACE="Palatino" SIZE=2> for further clarification on access to objects.</P>
<P ALIGN="JUSTIFY">A token can create and destroy objects, manipulate them, and search for them.  It can also perform cryptographic functions with objects.  A token may have an internal random number generator.</P>
<P ALIGN="JUSTIFY">It is important to distinguish between the logical view of a token and the actual implementation, because not all cryptographic devices will have this concept of &quot;objects,&quot; or be able to perform every kind of cryptographic function.  Many devices will simply have fixed storage places for keys of a fixed algorithm, and be able to do a limited set of operations.  Cryptoki's role is to translate this into the logical view, mapping attributes to fixed storage elements and so on. Not all Cryptoki libraries and tokens need to support every object type.  It is expected that standard &quot;profiles&quot; will be developed, specifying sets of algorithms to be supported.</P>
<P ALIGN="JUSTIFY">&quot;Attributes&quot; are characteristics that distinguish an instance of an object.  In Cryptoki, there are general attributes, such as whether the object is private or public.  There are also attributes that are specific to a particular type of object, such as a modulus or exponent for RSA keys.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287644"><A NAME="_Toc319313485"><A NAME="_Toc319313678"><A NAME="_Toc319315671"><A NAME="_Toc322855264"><A NAME="_Toc322945066"><A NAME="_Toc323000673"><A NAME="_Toc323024033"><A NAME="_Ref323103126"><A NAME="_Toc323205364"><A NAME="_Toc323610793"><A NAME="_Toc383864804"><A NAME="_Toc385057791"><A NAME="_Toc405794612"><A NAME="_Toc410108938"><A NAME="_Toc319287642"><A NAME="_Toc319313483"><A NAME="_Toc319313676"><A NAME="_Toc319315669">5.4.&#9;Users</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This version of Cryptoki recognizes two token user types.  One type is a Security Officer (SO).  The other type is the normal user. Only the normal user is allowed access to private objects on the token, and that access is granted only after the normal user has been authenticated.  Some tokens may also require that a user be authenticated before any cryptographic function can be performed on the token, whether or not it involves private objects. The role of the SO is to initialize a token and to set the normal user’s PIN (or otherwise define, by some method outside the scope of this version of Cryptoki, how the normal user may be authenticated), and possibly to manipulate some public objects.  The normal user cannot log in until the SO has set the normal user’s PIN.</P>
<P ALIGN="JUSTIFY">Other than the support for two types of user, Cryptoki does not address the relationship between the SO and a community of users.  In particular, the SO and the normal user may be the same person or may be different, but such matters are outside the scope of this standard.</P>
<P ALIGN="JUSTIFY">With respect to PINs that are entered through an application, Cryptoki assumes only that they are variable-length strings of characters from the set in Table 3.  Any translation to the device’s requirements is left to the Cryptoki library. The following issues are beyond the scope of Cryptoki:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Any padding of PINs.</LI></P>
<P ALIGN="JUSTIFY"><LI>How the PINs are generated (by the user, by the application, or by some other means).</LI></P></UL>

<P ALIGN="JUSTIFY"><A NAME="_Toc319287646"><A NAME="_Toc319313487"><A NAME="_Toc319313680"><A NAME="_Toc319315673"><A NAME="_Toc322855265"><A NAME="_Toc322945091"><A NAME="_Toc323000674"><A NAME="_Toc323024034"><A NAME="_Toc323205365"><A NAME="_Toc323610794"><A NAME="_Toc383864805"><A NAME="_Toc385057792">PINs that are supplied by some means other than through an application (<I>e.g.</I>, PINs entered via a PINpad on the token) are even more abstract.  Cryptoki knows how to wait (if need be) for such a PIN to be supplied and used, and little more.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref399916915"><A NAME="_Toc405794613"><A NAME="_Toc410108939"><A NAME="_Ref388878037"><A NAME="_Ref388878179">5.5.&#9;Applications and their use of Cryptoki</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">To Cryptoki, an application consists of a single address space and all the threads of control running in it.  An application becomes a &quot;Cryptoki application&quot; by calling the Cryptoki function <B>C_Initialize</B> (see Section 10.4) from one of its threads; after this call is made, the application can call other Cryptoki functions.  When the application is done using Cryptoki, it calls the Cryptoki function <B>C_Finalize</B> (see Section 10.4) and ceases to be a Cryptoki application.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794614"><A NAME="_Toc410108940">5.5.1.&#9;Applications and processes</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In general, on most platforms, the previous paragraph means that an application consists of a single process.</P>
<P ALIGN="JUSTIFY">Consider a UNIX process <B>P</B> which becomes a Cryptoki application by calling <B>C_Initialize</B>, and then uses the </FONT><FONT FACE="Courier New" SIZE=2>fork()</FONT><FONT FACE="Palatino" SIZE=2> system call to create a child process <B>C</B>.  Since <B>P</B> and <B>C</B> have separate address spaces (or will when one of them performs a write operation, if the operating system follows the copy-on-write paradigm), they are not part of the same application.  Therefore, if <B>C</B> needs to use Cryptoki, it needs to perform its own <B>C_Initialize</B> call.  Furthermore, if <B>C</B> needs to be logged into the token(s) that it will access via Cryptoki, it needs to log into them <I>even if <B>P</B> already logged in</I>, since <B>P</B> and <B>C</B> are completely separate applications.</P>
<P ALIGN="JUSTIFY">In this particular case (when <B>C</B> is the child of a process which is a Cryptoki application), the behavior of Cryptoki is undefined if <B>C</B> tries to use it without its own <B>C_Initialize</B> call.  Ideally, such an attempt would return the value CKR_CRYPTOKI_NOT_INITIALIZED; however, because of the way </FONT><FONT FACE="Courier New" SIZE=2>fork()</FONT><FONT FACE="Palatino" SIZE=2> works, insisting on this return value might have a bad impact on the performance of libraries.  Therefore, the behavior of Cryptoki in this situation is left undefined.  Applications should definitely <I>not</I> attempt to take advantage of any potential &quot;shortcuts&quot; which might (or might not!) be available because of this.</P>
<P ALIGN="JUSTIFY">In the scenario specified above, <B>C</B> should actually call <B>C_Initialize</B> whether or not it needs to use Cryptoki; if it has no need to use Cryptoki, it should then call <B>C_Finalize</B> immediately thereafter.  This (having the child immediately call <B>C_Initialize</B> and then call <B>C_Finalize</B> if the parent is using Cryptoki) is considered to be good Cryptoki programming practice, since it can prevent the existence of dangling duplicate resources that were created at the time of the </FONT><FONT FACE="Courier New" SIZE=2>fork()</FONT><FONT FACE="Palatino" SIZE=2> call; however, it is not required by Cryptoki.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794615"><A NAME="_Toc410108941">5.5.2.&#9;Applications and threads</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Some applications will access a Cryptoki library in a multi-threaded fashion.  Cryptoki Version 2.01 enables applications to provide information to libraries so that they can give appropriate support for multi-threading.  In particular, when an application initializes a Cryptoki library with a call to <B>C_Initialize</B>, it can specify one of four possible multi-threading behaviors for the library:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>The application can specify that it will not be accessing the library concurrently from multiple threads, and so the library need not worry about performing any type of locking for the sake of thread-safety.</LI></P>
<P ALIGN="JUSTIFY"><LI>The application can specify that it <I>will</I> be accessing the library concurrently from multiple threads, and the library must be able to use native operation system synchronization primitives to ensure proper thread-safe behavior.</LI></P>
<P ALIGN="JUSTIFY"><LI>The application can specify that it <I>will</I> be accessing the library concurrently from multiple threads, and the library must use a set of application-supplied synchronization primitives to ensure proper thread-safe behavior.</LI></P>
<P ALIGN="JUSTIFY"><LI>The application can specify that it <I>will</I> be accessing the library concurrently from multiple threads, and the library must use either the native operation system synchronization primitives or a set of application-supplied synchronization primitives to ensure proper thread-safe behavior.</LI></P></OL>

<P ALIGN="JUSTIFY">The 3<SUP>rd</SUP> and 4<SUP>th</SUP> types of behavior listed above are appropriate for multi-threaded applications which are not using the native operating system thread model.  The application-supplied synchronization primitives consist of four functions for handling mutex (<I>mut</I>ual <I>ex</I>clusion) objects in the application’s threading model.  Mutex objects are simple objects which can be in either of two states at any given time: unlocked or locked.  If a call is made by a thread to lock a mutex which is already locked, that thread blocks (waits) until the mutex is unlocked; then it locks it and the call returns.  If more than one thread is blocking on a particular mutex, and that mutex becomes unlocked, then exactly one of those threads will get the lock on the mutex and return control to the caller (the other blocking threads will continue to block and wait for their turn).</P>
<P ALIGN="JUSTIFY">See Section 8.7 for more information on Cryptoki’s view of mutex objects.</P>
<P ALIGN="JUSTIFY">In addition to providing the above thread-handling information to a Cryptoki library at initialization time, an application can also specify whether or not application threads executing library calls may use native operating system calls to spawn new threads.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794616"><A NAME="_Toc410108942">5.6.&#9;Sessions</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki requires that an application open one or more sessions with a token to gain access to the token’s objects and functions.  A session provides a logical connection between the application and the token.  A session can be a read/write (R/W) session or a read-only (R/O) session.  Read/write and read-only refer to the access to token objects, not to session objects.  In both session types, an application can create, read, write and destroy session objects, and read token objects.  However, only in a read/write session can an application create, modify, and destroy token objects.</P>
<P ALIGN="JUSTIFY">After it opens a session, an application has access to the token’s public objects.  All threads of a given application have access to exactly the same sessions and the same session objects.  To gain access to the token’s private objects, the normal user must log in and be authenticated.</P>
<P ALIGN="JUSTIFY">When a session is closed, any session objects which were created in that session are destroyed.  This holds even for session objects which are &quot;being used&quot; by other sessions.  That is, if a single application has multiple sessions open with a token, and it uses one of them to create a session object, then that session object is visible through any of that application’s sessions.  However, as soon as the session that was used to create the object is closed, that object is destroyed.</P>
<P ALIGN="JUSTIFY">Cryptoki supports multiple sessions on multiple tokens.  An application may have one or more sessions with one or more tokens.  In general, a token may have multiple sessions with one or more applications.  A particular token may allow an application to have only a limited number of sessions—or only a limited number of read/write sessions-- however.</P>
<P ALIGN="JUSTIFY">An open session can be in one of several states.  The session state determines allowable access to objects and functions that can be performed on them.  The session states are described in Section 5.6.1 and Section 5.6.2.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287647"><A NAME="_Toc319313488"><A NAME="_Toc319313681"><A NAME="_Toc319315674"><A NAME="_Toc322855266"><A NAME="_Toc322945092"><A NAME="_Toc323000675"><A NAME="_Toc323024035"><A NAME="_Ref323102929"><A NAME="_Ref323102936"><A NAME="_Toc323205366"><A NAME="_Toc323610795"><A NAME="_Toc383864806"><A NAME="_Ref384482971"><A NAME="_Toc385057793"><A NAME="_Toc405794617"><A NAME="_Toc410108943">5.6.1.&#9;Read-only session states</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A read-only session can be in one of two states, as illustrated in the following figure.  When the session is initially opened, it is in either the &quot;R/O Public Session&quot; state (if the application has no previously open sessions that are logged in) or the &quot;R/O User Functions&quot; state (if the application already has an open session that is logged in).  Note that read-only SO sessions do not exist.</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image3.gif" WIDTH=576 HEIGHT=228></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108828">Figure 3, Read-Only Session States</A></P>
</B><P ALIGN="JUSTIFY">The following table describes the session states:</P>
<B><P><A NAME="_Toc383864505"><A NAME="_Toc405794966"><A NAME="_Toc410108835">Table 4, Read-Only Session States</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>State</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Description</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/O Public Session</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>The application has opened a read-only session.  The application has read-only access to public token objects and read/write access to public session objects.</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/O User Functions</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>The normal user has been authenticated to the token. The application has read-only access to all token objects (public or private) and read/write access to all session objects (public or private).</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc322855267"><A NAME="_Toc322945093"><A NAME="_Toc323000676"><A NAME="_Toc323024036"><A NAME="_Ref323102939"><A NAME="_Toc323205367"><A NAME="_Toc323610796"><A NAME="_Toc383864807"><A NAME="_Ref384482978"><A NAME="_Toc385057794"><A NAME="_Toc405794618"><A NAME="_Toc410108944">5.6.2.&#9;Read/write session states</A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A read/write session can be in one of three states, as illustrated in the following figure.  When the session is opened, it is in either the &quot;R/W Public Session&quot; state (if the application has no previously open sessions that are logged in), the &quot;R/W User Functions&quot; state (if the application already has an open session that the normal user is logged into), or the &quot;R/W SO Functions&quot; state (if the application already has an open session that the SO is logged into).</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image4.gif" WIDTH=576 HEIGHT=378></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108829">Figure 4, Read/Write Session States</A></P>
</B><P ALIGN="JUSTIFY">The following table describes the session states:</P>
<B><P><A NAME="_Toc319314005"><A NAME="_Toc319314547"><A NAME="_Toc319314962"><A NAME="_Toc319315834"><A NAME="_Toc323204876"><A NAME="_Toc383864506"><A NAME="_Toc405794967"><A NAME="_Toc410108836">Table 5, Read/Write Session States</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>State</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Description</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/W Public Session</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>The application has opened a read/write session. The application has read/write access to all public objects.</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/W SO Functions</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>The Security Officer has been authenticated to the token. The application has read/write access only to public objects on the token, not to private objects.  The SO can set the normal user’s PIN.</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>R/W User Functions</FONT></TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>The normal user has been authenticated to the token. The application has read/write access to all objects.</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc383864808"><A NAME="_Toc385057795"><A NAME="_Toc405794619"><A NAME="_Toc410108945">5.6.3.&#9;Permitted object accesses by sessions</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following table summarizes the kind of access each type of session has to each type of object.  A given type of session has either read-only access, read/write access, or no access whatsoever to a given type of object.</P>
<P ALIGN="JUSTIFY">Note that creating or deleting an object requires read/write access to it, <I>e.g.</I>, a &quot;R/O User Functions&quot; session cannot create or delete a token object.</P>
<B><P><A NAME="_Ref398085875"><A NAME="_Toc383864507"><A NAME="_Ref398548479"><A NAME="_Toc405794968"><A NAME="_Toc410108837">Table 6</A>, Access to Different Types Objects by Different Types of Sessions</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=492>
<TR><TD WIDTH="33%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="67%" VALIGN="TOP" COLSPAN=5>
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Type of session</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2>
<P>Type of object</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/O Public</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W Public</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/O User</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W User</B></FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W SO</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public session object</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private session object</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="14%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public token object</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/O</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/O</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private token object</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="14%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/O</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">R/W</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc322855268"><A NAME="_Toc322945094"><A NAME="_Toc323000677"><A NAME="_Toc323024037"><A NAME="_Toc323205368"><A NAME="_Toc323610797"><A NAME="_Toc383864809"><A NAME="_Toc385057796"></P>
<P ALIGN="JUSTIFY">As previously indicated, the access to a given session object which is shown in Table 6 is limited to sessions belonging to the application which owns that object (<I>i.e.</I>, which created that object).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794620"><A NAME="_Toc410108946">5.6.4.&#9;Session events</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Session events cause the session state to change. The following table describes the events:</P>
<B><P><A NAME="_Toc319314006"><A NAME="_Toc319314548"><A NAME="_Toc319314963"><A NAME="_Toc319315835"><A NAME="_Toc323204877"><A NAME="_Toc383864508"><A NAME="_Toc405794969"><A NAME="_Toc410108838">Table 7, Session Events</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Event</B></FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Occurs when...</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Log In SO</FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>the SO is authenticated to the token.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Log In User</FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>the normal user is authenticated to the token.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Log Out</FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>the application logs out the current user (SO or normal user).</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Close Session</FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>the application closes the session or closes all sessions.</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Device Removed</FONT></TD>
<TD WIDTH="77%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>the device underlying the token has been removed from its slot.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">When the device is removed, all sessions of all applications are automatically logged out.  Furthermore, all sessions any applications have with the device are closed (this latter behavior was not present in Version 1.0 of Cryptoki)—an application cannot have a session with a token which is not present. Realistically, Cryptoki may not be constantly monitoring whether or not the token is present, and so the token’s absence could conceivably not be noticed until a Cryptoki function is executed.  If the token is re-inserted into the slot before that, Cryptoki might never know that it was missing.</P>
<P ALIGN="JUSTIFY">In Cryptoki Version 2.01, all sessions that an application has with a token must have the same login/logout status (<I>i.e.</I>, for a given application and token, one of the following holds: all sessions are public sessions; all sessions are SO sessions; or all sessions are user sessions).  When an application’s session logs into a token, <I>all</I> of that application’s sessions with that token become logged in, and when an application’s session logs out of a token, <I>all</I> of that application’s sessions with that token become logged out.  Similarly, for example, if an application already has a R/O user session open with a token, and then opens a R/W session with that token, the R/W session is automatically logged in.</P>
<P ALIGN="JUSTIFY">This implies that a given application may not simultaneously have SO sessions and user sessions open with a given token.  It also implies that if an application has a R/W SO session with a token, then it may not open a R/O session with that token, since R/O SO sessions do not exist.  For the same reason, if an application has a R/O session open, then it may not log any other session into the token as the SO.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc383864810"><A NAME="_Ref384830223"><A NAME="_Toc385057797"><A NAME="_Toc405794621"><A NAME="_Toc410108947">5.6.5.&#9;Session handles and object handles</A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A session handle is a Cryptoki-assigned value that identifies a session.  It is in many ways akin to a file handle, and is specified to functions to indicate which session the function should act on. All threads of an application have equal access to all session handles.  That is, anything that can be accomplished with a given file handle by one thread can also be accomplished with that file handle by any other thread of the same application.</P>
<P ALIGN="JUSTIFY">Cryptoki also has object handles, which are identifiers used to manipulate Cryptoki objects.  Object handles are similar to session handles in the sense that visibility of a given object through an object handle is the same among all threads of a given application.  R/O sessions, of course, only have read-only access to token objects, whereas R/W sessions have read/write access to token objects.</P>
<I><P ALIGN="JUSTIFY">Valid session handles and object handles in Cryptoki always have nonzero values.</I>  For developers’ convenience, Cryptoki defines the following symbolic value:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CK_INVALID_HANDLE     0</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057798"><A NAME="_Toc405794622"><A NAME="_Ref406906797"><A NAME="_Toc410108948">5.6.6.&#9;Capabilities of sessions</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Very roughly speaking, there are three broad types of operations an open session can be used to perform: administrative operations (such as logging in); object management operations (such as creating or destroying an object on the token); and cryptographic operations (such as computing a message digest).  Cryptographic operations sometimes require more than one function call to the Cryptoki API to complete.  In general, a single session can perform only one operation at a time; for this reason, it may be desirable for a single application to open multiple sessions with a single token.  For efficiency’s sake, however, a single session on some tokens can perform the following pairs of operation types simultaneously: message digesting and encryption; decryption and message digesting; signature or MACing and encryption; and decryption and verifying signatures or MACs.  Details on performing simultaneous cryptographic operations in one session are provided in Section 10.13.</P>
<P ALIGN="JUSTIFY">A consequence of the fact that a single session can, in general, perform only one operation at a time is that <I>an application should never make multiple simultaneous function calls to Cryptoki which use a common session</I>.  If multiple threads of an application attempt to use a common session concurrently in this fashion, Cryptoki does not define what happens.  This means that if multiple threads of an application all need to use Cryptoki to access a particular token, it might be appropriate for each thread to have its own session with the token, unless the application can ensure by some other means (<I>e.g.</I>, by some locking mechanism) that no sessions are ever used by multiple threads simultaneously.  This is true regardless of whether or not the Cryptoki library was initialized in a fashion which permits safe multi-threaded access to it.  Even if it is safe to access the library from multiple threads simultaneously, it is still not necessarily safe to use <I>a particular session</I> from multiple threads simultaneously.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc383864811"><A NAME="_Ref384459188"><A NAME="_Ref384459212"><A NAME="_Ref384459229"><A NAME="_Ref384484147"><A NAME="_Toc385057800"><A NAME="_Toc405794623"><A NAME="_Toc410108949">5.6.7.&#9;Example of use of sessions</A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">We give here a detailed and lengthy example of how multiple applications can make use of sessions in a Cryptoki library.  Despite the somewhat painful level of detail, we highly recommend reading through this example carefully to understand session handles and object handles.</P>
<P ALIGN="JUSTIFY">We caution that our example is decidedly <I>not</I> meant to indicate how multiple applications <I>should</I> use Cryptoki simultaneously; rather, it is meant to clarify what uses of Cryptoki’s sessions and objects and handles are permissible.  In other words, instead of demonstrating good technique here, we demonstrate &quot;pushing the envelope&quot;.</P>
<P ALIGN="JUSTIFY">For our example, we suppose that two applications, <B>A</B> and <B>B</B>, are using a Cryptoki library to access a single token <B>T</B>.  Each application has two threads running: <B>A</B> has threads <B>A1</B> and <B>A2</B>, and <B>B</B> has threads <B>B1</B> and <B>B2</B>.  We assume in what follows that there are no instances where multiple threads of a single application simultaneously use the same session, and that the events of our example occur in the order specified, without overlapping each other in time.</P>
<OL>

<B><P ALIGN="JUSTIFY"><LI>A1</B> and <B>B1</B> each initialize the Cryptoki library by calling <B>C_Initialize</B> (the specifics of Cryptoki functions will be explained in Section 10).  Note that exactly one call to <B>C_Initialize</B> should be made for each application (as opposed to one call for every thread, for example).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> opens a R/W session and receives the session handle 7 for the session.  Since this is the first session to be opened for <B>A</B>, it is a public session.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> opens a R/O session and receives the session handle 4.  Since all of <B>A</B>’s existing sessions are public sessions, session 4 is also a public session.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> attempts to log the SO into session 7.  The attempt fails, because if session 7 becomes an SO session, then session 4 does, as well, and R/O SO sessions do not exist.  <B>A1</B> receives an error code indicating that the existence of a R/O session has blocked this attempt to log in (CKR_SESSION_READ_ONLY_EXISTS).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> logs the normal user into session 7.  This turns session 7 into a R/W user session, and turns session 4 into a R/O user session.  Note that because <B>A1</B> and <B>A2</B> belong to the same application, they have equal access to all sessions, and therefore, <B>A2</B> is able to perform this action.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> opens a R/W session and receives the session handle 9.  Since all of <B>A</B>’s existing sessions are user sessions, session 9 is also a user session.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> closes session 9.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> attempts to log out session 4.  The attempt fails, because <B>A</B> and <B>B</B> have no access rights to each other’s sessions or objects.  <B>B1</B> receives an error message which indicates that there is no such session handle (CKR_SESSION_HANDLE_INVALID).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B2</B> attempts to close session 4.  The attempt fails in precisely the same way as <B>B1</B>’s attempt to log out session 4 failed (<I>i.e.</I>, <B>B2</B> receives a CKR_SESSION_HANDLE_INVALID error code).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> opens a R/W session and receives the session handle 7.  Note that, as far as <B>B</B> is concerned, this is the first occurrence of session handle 7.  <B>A</B>’s session 7 and <B>B</B>’s session 7 are completely different sessions.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> logs the SO into [<B>B</B>’s] session 7.  This turns <B>B</B>’s session 7 into a R/W SO session, and has no effect on either of <B>A</B>’s sessions.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B2</B> attempts to open a R/O session.  The attempt fails, since <B>B</B> already has an SO session open, and R/O SO sessions do not exist.  <B>B1</B> receives an error message indicating that the existence of an SO session has blocked this attempt to open a R/O session (CKR_SESSION_READ_WRITE_SO_EXISTS).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> uses [<B>A</B>’s] session 7 to create a session object <B>O1</B> of some sort and receives the object handle 7.  Note that a Cryptoki implementation may or may not support separate spaces of handles for sessions and objects.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> uses [<B>B</B>’s] session 7 to create a token object <B>O2</B> of some sort and receives the object handle 7.  As with session handles, different applications have no access rights to each other’s object handles, and so <B>B</B>’s object handle 7 is entirely different from <B>A</B>’s object handle 7.  Of course, since <B>B1</B> is an SO session, it cannot create private objects, and so <B>O2</B> must be a public object (if <B>B1</B> attempted to create a private object, the attempt would fail with error code CKR_USER_NOT_LOGGED_IN or CKR_TEMPLATE_INCONSISTENT).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B2</B> uses [<B>B</B>’s] session 7 to perform some operation to modify the object associated with [<B>B</B>’s] object handle 7.  This modifies <B>O2</B>.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> uses [<B>A</B>’s] session 4 to perform an object search operation to get a handle for <B>O2</B>.  The search returns object handle 1.  Note that <B>A</B>’s object handle 1 and <B>B</B>’s object handle 7 now point to the same object.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> attempts to use [<B>A</B>’s] session 4 to modify the object associated with [<B>A</B>’s] object handle 1.  The attempt fails, because <B>A</B>’s session 4 is a R/O session, and is therefore incapable of modifying <B>O2</B>, which is a token object.  <B>A1</B> receives an error message indicating that the session is a R/O session (CKR_SESSION_READ_ONLY).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> uses [<B>A</B>’s] session 7 to modify the object associated with [<B>A</B>’s] object handle 1.  This time, since <B>A</B>’s session 7 is a R/W session,  the attempt succeeds in modifying <B>O2</B>.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> uses [<B>B</B>’s] session 7 to perform an object search operation to find <B>O1</B>.  Since <B>O1</B> is a session object belonging to <B>A</B>, however, the search does not succeed.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> uses [<B>A</B>’s] session 4 to perform some operation to modify the object associated with [<B>A</B>’s] object handle 7.  This operation modifies <B>O1</B>.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> uses [<B>A</B>’s] session 7 to destroy the object associated with [<B>A</B>’s] object handle 1.  This destroys <B>O2</B>.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B1</B> attempts to perform some operation with the object associated with [<B>B</B>’s] object handle 7.  The attempt fails, since there is no longer any such object.  <B>B1</B> receives an error message indicating that its object handle is invalid (CKR_OBJECT_HANDLE_INVALID).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> logs out [<B>A</B>’s] session 4.  This turns <B>A</B>’s session 4 into a R/O public session, and turns <B>A</B>’s session 7 into a R/W public session.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A1</B> closes [<B>A</B>’s] session 7.  This destroys the session object <B>O1</B>, which was created by <B>A</B>’s session 7.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> attempt to use [<B>A</B>’s] session 4 to perform some operation with the object associated with [<B>A</B>’s] object handle 7.  The attempt fails, since there is no longer any such object.  It returns a CKR_OBJECT_HANDLE_INVALID.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A2</B> executes a call to <B>C_CloseAllSessions</B>.  This closes [<B>A</B>’s] session 4.  At this point, if <B>A</B> were to open a new session, the session would not be logged in (<I>i.e.</I>, it would be a public session).</LI></P>
<B><P ALIGN="JUSTIFY"><LI>B2</B> closes [<B>B</B>’s] session 7.  At this point, if <B>B</B> were to open a new session, the session would not be logged in.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>A</B> and <B>B</B> each call <B>C_Finalize</B> to indicate that they are done with the Cryptoki library.</LI></P></OL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855269"><A NAME="_Toc322945095"><A NAME="_Toc323000678"><A NAME="_Toc323024038"><A NAME="_Toc323205369"><A NAME="_Toc323610798"><A NAME="_Ref372962872"><A NAME="_Toc383864812"><A NAME="_Toc385057801"><A NAME="_Toc405794624"><A NAME="_Toc410108950">5.7.&#9;Function overview</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The Cryptoki API consists of a number of functions, spanning slot and token management and object management, as well as cryptographic functions.  These functions are presented in the following table:</P>
<B><P><A NAME="Functions"><A NAME="_Toc319314002"><A NAME="_Toc319314543"><A NAME="_Toc319314958"><A NAME="_Toc319315828"><A NAME="_Toc323204878"><A NAME="_Toc383864509"><A NAME="_Toc405794970"><A NAME="_Toc410108839"></A>Table 8, Summary of Cryptoki Functions</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=582>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Category</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Description</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>General</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Initialize</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes Cryptoki</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>purpose functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Finalize</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>clean up miscellaneous Cryptoki-associated resources</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetInfo</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains general information about Cryptoki</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetFunctionList</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains entry points of Cryptoki library functions</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Slot and token</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetSlotList</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains a list of slots in the system</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>management</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetSlotInfo</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains information about a particular slot</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetTokenInfo</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains information about a particular token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WaitForSlotEvent</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>waits for a slot event (token insertion, removal, etc.) to occur</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetMechanismList</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains a list of mechanisms supported by a token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetMechanismInfo</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains information about a particular mechanism</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_InitToken</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_InitPIN</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes the normal user’s PIN</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SetPIN</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>modifies the PIN of the current user</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Session management functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_OpenSession</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>opens a connection between an application and a particular token or sets up an application callback for token insertion</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CloseSession</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>closes a session</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CloseAllSessions</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>closes all sessions with a token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetSessionInfo</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains information about the session</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetOperationState</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains the cryptographic operations state of a session</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SetOperationState</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>sets the cryptographic operations state of a session</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Login</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>logs into a token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Logout</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>logs out from a token</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Object</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>creates an object</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>management</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CopyObject</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>creates a copy of an object</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DestroyObject</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>destroys an object</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetObjectSize</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains the size of an object in bytes</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetAttributeValue</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>obtains an attribute value of an object</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SetAttributeValue</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>modifies an attribute value of an object</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_FindObjectsInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes an object search operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_FindObjects</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues an object search operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_FindObjectsFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes an object search operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Encryption</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes an encryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>encrypts single-part data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues a multiple-part encryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes a multiple-part encryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Decryption</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a decryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>decrypts single-part encrypted data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues a multiple-part decryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes a multiple-part decryption operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Message</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a message-digesting operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>digesting</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Digest</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>digests single-part data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues a multiple-part digesting operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestKey</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>digests a key</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes a multiple-part digesting operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Signing</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a signature operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>and MACing</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>signs single-part data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues a multiple-part signature operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes a multiple-part signature operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignRecoverInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a signature operation, where the data can be recovered from the signature</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignRecover</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>signs single-part data, where the data can be recovered from the signature</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Functions for verifying</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a verification operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>signatures</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>verifies a signature on single-part data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>and MACs</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues a multiple-part verification operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyFinal</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>finishes a multiple-part verification operation</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyRecoverInit</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initializes a verification operation where the data is recovered from the signature</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP" HEIGHT=36><P></P></TD>
<TD WIDTH="27%" VALIGN="TOP" HEIGHT=36>
<FONT FACE="Palatino" SIZE=2><P>C_VerifyRecover</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP" HEIGHT=36>
<FONT FACE="Palatino" SIZE=2><P>verifies a signature on single-part data, where the data is recovered from the signature</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Dual-purpose cryptographic</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestEncryptUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues simultaneous multiple-part digesting and encryption operations</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptDigestUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues simultaneous multiple-part decryption and digesting operations</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignEncryptUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues simultaneous multiple-part signature and encryption operations</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptVerifyUpdate</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>continues simultaneous multiple-part decryption and verification operations</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKey</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generates a secret key</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>management</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKeyPair</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generates a public-key/private-key pair</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>wraps (encrypts) a key</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>unwraps (decrypts) a key</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DeriveKey</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>derives a key from a base key</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Random number generation</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SeedRandom</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>mixes in additional seed material to the random number generator</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateRandom</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generates random data</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Parallel function management</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetFunctionStatus</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>legacy function which always returns CKR_FUNCTION_NOT_PARALLEL</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>functions</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CancelFunction</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>legacy function which always returns CKR_FUNCTION_NOT_PARALLEL</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Callback function</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>application-supplied function to process notifications from Cryptoki</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc319287643"><A NAME="_Toc319313484"><A NAME="_Toc319313677"><A NAME="_Toc319315670"><A NAME="_Toc322855270"><A NAME="_Toc322945096"><A NAME="_Toc323000679"><A NAME="_Toc323024039"><A NAME="_Toc323205370"><A NAME="_Toc323610799"><A NAME="_Toc383864813"><A NAME="_Toc385057802"><A NAME="_Toc405794625"><A NAME="_Toc410108951">6.&#9;Security</A></A></A></A> considerations</A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">As an interface to cryptographic devices, Cryptoki provides a basis for security in a computer or communications system.  Two of the particular features of the interface that facilitate such security are the following:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>Access to private objects on the token, and possibly to cryptographic functions and/or certificates on the token as well, requires a PIN. Thus, possessing the cryptographic device that implements the token may not be sufficient to use it; the PIN may also be needed.</LI></P>
<P ALIGN="JUSTIFY"><LI>Additional protection can be given to private keys and secret keys by marking them as &quot;sensitive&quot; or &quot;unextractable&quot;.  Sensitive keys cannot be revealed in plaintext off the token, and unextractable keys cannot be revealed off the token even when encrypted (though they can still be used as keys).</LI></P></OL>

<P ALIGN="JUSTIFY">It is expected that access to private, sensitive, or unextractable objects by means other than Cryptoki (<I>e.g.</I>, other programming interfaces, or reverse engineering of the device) would be difficult.</P>
<P ALIGN="JUSTIFY">If a device does not have a tamper-proof environment or protected memory in which to store private and sensitive objects, the device may encrypt the objects with a master key which is perhaps derived from the user’s PIN.  The particular mechanism for protecting private objects is left to the device implementation, however.</P>
<P ALIGN="JUSTIFY">Based on these features it should be possible to design applications in such a way that the token can provide adequate security for the objects the applications manage.</P>
<P ALIGN="JUSTIFY">Of course, cryptography is only one element of security, and the token is only one component in a system. While the token itself may be secure, one must also consider the security of the operating system by which the application interfaces to it, especially since the PIN may be passed through the operating system. This can make it easy for a rogue application on the operating system to obtain the PIN; it is also possible that other devices monitoring communication lines to the cryptographic device can obtain the PIN. Rogue applications and devices may also change the commands sent to the cryptographic device to obtain services other than what the application requested.</P>
<P ALIGN="JUSTIFY">It is important to be sure that the system is secure against such attack. Cryptoki may well play a role here; for instance, a token may be involved in the &quot;booting up&quot; of the system.</P>
<P ALIGN="JUSTIFY">We note that none of the attacks just described can compromise keys marked &quot;sensitive,&quot; since a key that is sensitive will always remain sensitive.  Similarly, a key that is unextractable cannot be modified to be extractable.</P>
<P ALIGN="JUSTIFY">An application may also want to be sure that the token is &quot;legitimate&quot; in some sense (for a variety of reasons, including export restrictions and basic security). This is outside the scope of the present standard, but it can be achieved by distributing the token with a built-in, certified public/private-key pair, by which the token can prove its identity. The certificate would be signed by an authority (presumably the one indicating that the token is &quot;legitimate&quot;) whose public key is known to the application. The application would verify the certificate and challenge the token to prove its identity by signing a time-varying message with its built-in private key.</P>
<P ALIGN="JUSTIFY">Once a normal user has been authenticated to the token, Cryptoki does not restrict which cryptographic operations the user may perform; the user may perform any operation supported by the token.  Some tokens may not even require any type of authentication to make use of its cryptographic functions.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Ref406237056"><A NAME="_Toc410108952"><A NAME="_Toc319287648"><A NAME="_Toc319313489"><A NAME="_Toc319313682"><A NAME="_Toc319315675"><A NAME="_Toc322855271"><A NAME="_Toc322945097"><A NAME="_Toc323000680"><A NAME="_Toc323024040"><A NAME="_Toc323205371"><A NAME="_Toc323610800"><A NAME="_Toc383864814"><A NAME="_Toc385057803"><A NAME="_Toc405794626">7.&#9;Platform- and compiler-dependent directives</A> for C or C++</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">There is a large array of Cryptoki-related data types which are defined in the Cryptoki header files. Certain packing- and pointer-related aspects of these types are platform- and compiler-dependent; these aspects are therefore resolved on a platform-by-platform (or compiler-by-compiler) basis outside of the Cryptoki header files by means of preprocessor directives.</P>
<P ALIGN="JUSTIFY">This means that when writing C or C++ code, certain preprocessor directives must be issued before including a Cryptoki header file.  These directives are described in the remainder of Section 7.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108953">7.1.&#9;Structure packing</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki structures are packed to occupy as little space as is possible.  In particular, on the Win32 and Win16 platforms, Cryptoki structures should be packed with 1-byte alignment.  In a UNIX environment, it may or may not be necessary (or even possible) to alter the byte-alignment of structures.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108954">7.2.&#9;Pointer-related macros</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Because different platforms and compilers have different ways of dealing with different types of pointers, Cryptoki requires the following 6 macros to be set outside the scope of Cryptoki:</P>

<UL>
<LI><A NAME="_Toc410108955"></FONT><B><FONT FACE="Palatino">CK_PTR</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">CK_PTR</FONT><FONT FACE="Palatino" SIZE=2> is the &quot;indirection string&quot; a given platform and compiler uses to make a pointer to an object.  It is used in the following fashion:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_BYTE CK_PTR CK_BYTE_PTR;</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc410108956"></FONT><B><FONT FACE="Palatino">CK_DEFINE_FUNCTION</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">CK_DEFINE_FUNCTION(returnType, name)</FONT><FONT FACE="Palatino" SIZE=2>, when followed by a parentheses-enclosed list of arguments and a function definition, defines a Cryptoki API function in a Cryptoki library.  </FONT><FONT FACE="Courier New" SIZE=2>returnType</FONT><FONT FACE="Palatino" SIZE=2> is the return type of the function, and </FONT><FONT FACE="Courier New" SIZE=2>name</FONT><FONT FACE="Palatino" SIZE=2> is its name.  It is used in the following fashion:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Initialize)(</P>
<P>  CK_VOID_PTR pReserved</P>
<P>)</P>
<P>{</P>
<P>  ...</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc410108957"></FONT><B><FONT FACE="Palatino">CK_DECLARE_FUNCTION</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">CK_DECLARE_FUNCTION(returnType, name)</FONT><FONT FACE="Palatino" SIZE=2>, when followed by a parentheses-enclosed list of arguments and a semicolon, declares a Cryptoki API function in a Cryptoki library.  </FONT><FONT FACE="Courier New" SIZE=2>returnType</FONT><FONT FACE="Palatino" SIZE=2> is the return type of the function, and </FONT><FONT FACE="Courier New" SIZE=2>name</FONT><FONT FACE="Palatino" SIZE=2> is its name.  It is used in the following fashion:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(</P>
<P>  CK_VOID_PTR pReserved</P>
<P>);</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc410108958"></FONT><B><FONT FACE="Palatino">CK_DECLARE_FUNCTION_POINTER</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">CK_DECLARE_FUNCTION_POINTER(returnType, name)</FONT><FONT FACE="Palatino" SIZE=2>, when followed by a parentheses-enclosed list of arguments and a semicolon, declares a variable or type which is a pointer to a Cryptoki API function in a Cryptoki library.  </FONT><FONT FACE="Courier New" SIZE=2>returnType</FONT><FONT FACE="Palatino" SIZE=2> is the return type of the function, and </FONT><FONT FACE="Courier New" SIZE=2>name</FONT><FONT FACE="Palatino" SIZE=2> is its name.  It can be used in either of the following fashions to define a function pointer variable, </FONT><FONT FACE="Courier New" SIZE=2>myC_Initialize</FONT><FONT FACE="Palatino" SIZE=2>, which can point to a <B>C_Initialize</B> function in a Cryptoki library (note that neither of the following code snippets actually <I>assigns</I> a value to </FONT><FONT FACE="Courier New" SIZE=2>myC_Initialize</FONT><FONT FACE="Palatino" SIZE=2>):</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_DECLARE_FUNCTION_POINTER(CK_RV, myC_Initialize)(</P>
<P>  CK_VOID_PTR pReserved</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">or:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, myC_InitializeType)(</P>
<P>  CK_VOID_PTR pReserved</P>
<P>);</P>
<P>myC_InitializeType myC_Initialize;</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc410108959"></FONT><B><FONT FACE="Palatino">CK_CALLBACK_FUNCTION</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">CK_CALLBACK_FUNCTION(returnType, name)</FONT><FONT FACE="Palatino" SIZE=2>, when followed by a parentheses-enclosed list of arguments and a semicolon, declares a variable or type which is a pointer to an application callback function that can be used by a Cryptoki API function in a Cryptoki library.  </FONT><FONT FACE="Courier New" SIZE=2>returnType</FONT><FONT FACE="Palatino" SIZE=2> is the return type of the function, and </FONT><FONT FACE="Courier New" SIZE=2>name</FONT><FONT FACE="Palatino" SIZE=2> is its name.  It can be used in either of the following fashions to define a function pointer variable, </FONT><FONT FACE="Courier New" SIZE=2>myCallback</FONT><FONT FACE="Palatino" SIZE=2>, which can point to an application callback which takes arguments </FONT><FONT FACE="Courier New" SIZE=2>args</FONT><FONT FACE="Palatino" SIZE=2> and returns a <B>CK_RV</B> (note that neither of the following code snippets actually <I>assigns</I> a value to </FONT><FONT FACE="Courier New" SIZE=2>myCallback</FONT><FONT FACE="Palatino" SIZE=2>):</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">or:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);</P>
<P>myCallbackType myCallback;</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc410108960"></FONT><B><FONT FACE="Palatino">NULL_PTR</A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P ALIGN="JUSTIFY">NULL_PTR</FONT><FONT FACE="Palatino" SIZE=2> is the value of a NULL pointer.  In any ANSI C environment—and in many others as well—</FONT><FONT FACE="Courier New" SIZE=2>NULL_PTR</FONT><FONT FACE="Palatino" SIZE=2> should be defined simply as 0.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108961">7.3.&#9;Sample platform- and compiler-dependent code</A></P>
<P><A NAME="_Toc410108962">7.3.1.&#9;Win32</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Developers using Microsoft Developer Studio 5.0 to produce C or C++ code which implements or makes use of a Win32 Cryptoki .dll might issue the following directives before including any Cryptoki header files:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#pragma pack(push, cryptoki, 1)</P>

<P>#define CK_PTR *</P>

<P>#define CK_DEFINE_FUNCTION(returnType, name) \</P>
<P>  returnType __declspec(dllexport) name</P>

<P>#define CK_DECLARE_FUNCTION(returnType, name) \</P>
<P>  returnType __declspec(dllimport) name</P>

<P>#define CK_DECLARE_FUNCTION_POINTER(returnType, name) \</P>
<P>  returnType __declspec(dllimport) (* name)</P>

<P>#define CK_CALLBACK_FUNCTION(returnType, name) \</P>
<P>  returnType (* name)</P>

<P>#ifndef NULL_PTR</P>
<P>#define NULL_PTR 0</P>
<P>#endif</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">After including any Cryptoki header files, they might issue the following directives to reset the structure packing to its earlier value:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#pragma pack(pop, cryptoki)</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108963">7.3.2.&#9;Win16</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Developers using a pre-5.0 version of Microsoft Developer Studio to produce C or C++ code which implements or makes use of a Win16 Cryptoki .dll might issue the following directives before including any Cryptoki header files:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#pragma pack(1)</P>

<P>#define CK_PTR far *</P>

<P>#define CK_DEFINE_FUNCTION(returnType, name) \</P>
<P>  returnType __export _far _pascal name</P>

<P>#define CK_DECLARE_FUNCTION(returnType, name) \</P>
<P>  returnType __export _far _pascal name</P>

<P>#define CK_DECLARE_FUNCTION_POINTER(returnType, name) \</P>
<P>  returnType __export _far _pascal (* name)</P>

<P>#define CK_CALLBACK_FUNCTION(returnType, name) \</P>
<P>  returnType _far _pascal (* name)</P>

<P>#ifndef NULL_PTR</P>
<P>#define NULL_PTR 0</P>
<P>#endif</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108964">7.3.3.&#9;Generic UNIX</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Developers performing generic UNIX development might issue the following directives before including any Cryptoki header files:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CK_PTR *</P>

<P>#define CK_DEFINE_FUNCTION(returnType, name) \</P>
<P>  returnType name</P>

<P>#define CK_DECLARE_FUNCTION(returnType, name) \</P>
<P>  returnType name</P>

<P>#define CK_DECLARE_FUNCTION_POINTER(returnType, name) \</P>
<P>  returnType (* name)</P>

<P>#define CK_CALLBACK_FUNCTION(returnType, name) \</P>
<P>  returnType (* name)</P>

<P>#ifndef NULL_PTR</P>
<P>#define NULL_PTR 0</P>
<P>#endif</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc410108965">8.&#9;General data types</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The general Cryptoki data types are described in the following subsections.  The data types for holding parameters for various mechanisms, and the pointers to those parameters, are not described here; these types are described with the information on the mechanisms themselves, in Section 10.17.2.</P>
<P ALIGN="JUSTIFY">A C or C++ source file in a Cryptoki application or library can define all these types (the types described here and the types that are specifically used for particular mechanism parameters) by including the top-level Cryptoki include file, </FONT><FONT FACE="Courier New" SIZE=2>pkcs11.h</FONT><FONT FACE="Palatino" SIZE=2>.  </FONT><FONT FACE="Courier New" SIZE=2>pkcs11.h</FONT><FONT FACE="Palatino" SIZE=2>, in turn, includes the other Cryptoki include files, </FONT><FONT FACE="Courier New" SIZE=2>pkcs11t.h</FONT><FONT FACE="Palatino" SIZE=2> and </FONT><FONT FACE="Courier New" SIZE=2>pkcs11f.h</FONT><FONT FACE="Palatino" SIZE=2>.  A source file can also include just </FONT><FONT FACE="Courier New" SIZE=2>pkcs11t.h</FONT><FONT FACE="Palatino" SIZE=2> (instead of </FONT><FONT FACE="Courier New" SIZE=2>pkcs11.h</FONT><FONT FACE="Palatino" SIZE=2>); this defines most (but not all) of the types specified here.</P>
<P ALIGN="JUSTIFY">When including either of these header files, a source file must specify the preprocessor directives indicated in Section 7.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287649"><A NAME="_Toc319313490"><A NAME="_Toc319313683"><A NAME="_Toc319315676"><A NAME="_Toc322855272"><A NAME="_Toc322945098"><A NAME="_Toc323000681"><A NAME="_Toc323024041"><A NAME="_Toc323205372"><A NAME="_Toc323610801"><A NAME="_Toc383864815"><A NAME="_Toc385057804"><A NAME="_Toc405794627"><A NAME="_Toc410108966">8.1.&#9;General information</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki represents general information with the following types:</P>

<UL>
<LI><A NAME="_Toc323024042"><A NAME="_Toc323205373"><A NAME="_Toc323610802"><A NAME="_Toc383864816"><A NAME="_Toc385057805"><A NAME="_Toc405794628"><A NAME="_Toc410108967"></FONT><B><FONT FACE="Palatino">CK_VERSION</A></A></A></A></A>; CK_VERSION_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_VERSION</B> is a structure that describes the version of a Cryptoki interface, a Cryptoki library, or an SSL implementation, or the hardware or firmware version of a slot or token.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_VERSION {</P>
<P>  CK_BYTE major;</P>
<P>  CK_BYTE minor;</P>
<P>} CK_VERSION;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>major</I>&#9;major version number (the integer portion of the version)</P>
<P>&#9;<I>minor</I>&#9;minor version number (the hundredths portion of the version)</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">For version 1.0, <I>major</I> = 1 and <I>minor</I> = 0.  For version 2.1, <I>major</I> = 2 and <I>minor</I> = 10.  Minor revisions of the Cryptoki standard are always upwardly compatible within the same major version number.</P>
<B><P ALIGN="JUSTIFY">CK_VERSION_PTR</B> is a pointer to a <B>CK_VERSION</B>.</P>

<UL>
<LI><A NAME="_Toc323024043"><A NAME="_Toc323205374"><A NAME="_Toc323610803"><A NAME="_Toc383864817"><A NAME="_Toc385057807"><A NAME="_Toc405794629"><A NAME="_Toc410108968"></FONT><B><FONT FACE="Palatino">CK_INFO</A></A></A></A></A>; CK_INFO_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_INFO</B> provides general information about Cryptoki.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_INFO {</P>
<P>  CK_VERSION cryptokiVersion;</P>
<P>  CK_CHAR manufacturerID[32];</P>
<P>  CK_FLAGS flags;</P>
<P>  CK_CHAR libraryDescription[32];</P>
<P>  CK_VERSION libraryVersion;</P>
<P>} CK_INFO;<BR>
</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>cryptokiVersion</I>&#9;Cryptoki interface version number, for compatibility with future revisions of this interface</P>
<P>&#9;<I>manufacturerID</I>&#9;ID of the Cryptoki library manufacturer.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>flags</I>&#9;bit flags reserved for future versions.  Must be zero for this version</P>
<P>&#9;<I>libraryDescription</I>&#9;character-string description of the library.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>libraryVersion</I>&#9;Cryptoki library version number</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">For libraries written to this document, the value of <I>cryptokiVersion</I> should be 2.01; the value of <I>libraryVersion</I> is the version number of the library software itself.</P>
<B><P ALIGN="JUSTIFY">CK_INFO_PTR</B> is a pointer to a <B>CK_INFO</B>.</P>

<UL>
<LI><A NAME="_Toc323024045"><A NAME="_Toc323205376"><A NAME="_Toc323610805"><A NAME="_Toc383864819"><A NAME="_Toc385057809"><A NAME="_Toc405794630"><A NAME="_Toc410108969"></FONT><B><FONT FACE="Palatino">CK_NOTIFICATION</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_NOTIFICATION</B> holds the types of notifications that Cryptoki provides to an application.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_NOTIFICATION;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following types of notifications are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKN_SURRENDER 0</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The notifications have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>CKN_SURRENDER</I>&#9;Cryptoki is surrendering the execution of a function executing in a session so that the application may perform other operations.  After performing any desired operations, the application should indicate to Cryptoki whether to continue or cancel the function (see Section 10.17.1).</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410108970">8.2.&#9;Slot and token types</A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki represents slot and token information with the following types:</P>

<UL>
<LI><A NAME="_Toc323024047"><A NAME="_Toc323205378"><A NAME="_Toc323610807"><A NAME="_Toc383864821"><A NAME="_Toc385057811"><A NAME="_Toc405794632"><A NAME="_Toc410108971"></FONT><B><FONT FACE="Palatino">CK_SLOT_ID</A></A></A></A></A>; CK_SLOT_ID_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SLOT_ID</B> is a Cryptoki-assigned value that identifies a slot.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_SLOT_ID;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A list of <B>CK_SLOT_ID</B>s is returned by <B>C_GetSlotList</B>.  A priori, <I>any</I> value of <B>CK_SLOT_ID</B> can be a valid slot identifier—in particular, a system may have a slot identified by the value 0.  It need not have such a slot, however.</P>
<B><P ALIGN="JUSTIFY">CK_SLOT_ID_PTR</B> is a pointer to a <B>CK_SLOT_ID</B>.</P>

<UL>
<LI><A NAME="_Toc323024049"><A NAME="_Toc323205380"><A NAME="_Toc323610809"><A NAME="_Toc383864823"><A NAME="_Toc385057813"><A NAME="_Toc405794633"><A NAME="_Toc410108972"></FONT><B><FONT FACE="Palatino">CK_SLOT_INFO</A></A></A></A></A>; CK_SLOT_INFO_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SLOT_INFO</B> provides information about a slot.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SLOT_INFO {</P>
<P>  CK_CHAR slotDescription[64];</P>
<P>  CK_CHAR manufacturerID[32];</P>
<P>  CK_FLAGS flags;</P>
<P>  CK_VERSION hardwareVersion;</P>
<P>  CK_VERSION firmwareVersion;</P>
<P>} CK_SLOT_INFO;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>slotDescription</I>&#9;character-string description of the slot.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>manufacturerID</I>&#9;ID of the slot manufacturer.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>flags</I>&#9;bits flags that provide capabilities of the slot.  The flags are defined below</P>
<I><P>&#9;hardwareVersion&#9;</I>version number of the slot’s hardware</P>
<I><P>&#9;firmwareVersion&#9;</I>version number of the slot’s firmware</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">The following table defines the <I>flags</I> field:</P>
<B><P><A NAME="_Toc383864510"><A NAME="_Toc405794971"><A NAME="_Toc410108840">Table 9, Slot Information Flags</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=582>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Bit Flag</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Mask</B></FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_TOKEN_PRESENT</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000001</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if a token is present in the slot (<I>e.g.</I>, a device is in the reader)</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_REMOVABLE_DEVICE</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000002</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the reader supports removable devices</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_HW_SLOT</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000004</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the slot is a hardware slot, as opposed to a software slot implementing a &quot;soft token&quot;</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For a given slot, the value of the <B>CKF_REMOVABLE_DEVICE</B> flag <I>never changes</I>.  In addition, if this flag is not set for a given slot, then the <B>CKF_TOKEN_PRESENT</B> flag for that slot is <I>always</I> set.  That is, if a slot does not support a removable device, then that slot always has a token in it.</P>
<B><P ALIGN="JUSTIFY">CK_SLOT_INFO_PTR</B> is a pointer to a <B>CK_SLOT_INFO</B>.</P>

<UL>
<LI><A NAME="_Toc323024051"><A NAME="_Toc323205382"><A NAME="_Toc323610811"><A NAME="_Toc383864825"><A NAME="_Toc385057815"><A NAME="_Toc405794634"><A NAME="_Toc410108973"></FONT><B><FONT FACE="Palatino">CK_TOKEN_INFO</A></A></A></A></A>; CK_TOKEN_INFO_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_TOKEN_INFO</B> provides information about a token.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_TOKEN_INFO {</P>
<P>  CK_CHAR label[32];</P>
<P>  CK_CHAR manufacturerID[32];</P>
<P>  CK_CHAR model[16];</P>
<P>  CK_CHAR serialNumber[16];</P>
<P>  CK_FLAGS flags;</P>
<P>  CK_ULONG ulMaxSessionCount;</P>
<P>  CK_ULONG ulSessionCount;</P>
<P>  CK_ULONG ulMaxRwSessionCount;</P>
<P>  CK_ULONG ulRwSessionCount;</P>
<P>  CK_ULONG ulMaxPinLen;</P>
<P>  CK_ULONG ulMinPinLen;</P>
<P>  CK_ULONG ulTotalPublicMemory;</P>
<P>  CK_ULONG ulFreePublicMemory;</P>
<P>  CK_ULONG ulTotalPrivateMemory;</P>
<P>  CK_ULONG ulFreePrivateMemory;</P>
<P>  CK_VERSION hardwareVersion;</P>
<P>  CK_VERSION firmwareVersion;</P>
<P>  CK_CHAR utcTime[16];</P>
<P>} CK_TOKEN_INFO;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>label</I>&#9;application-defined label, assigned during token initialization.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>manufacturerID</I>&#9;ID of the device manufacturer.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>model</I>&#9;model of the device.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>serialNumber</I>&#9;character-string serial number of the device.  Must be padded with the blank character (‘ ‘).  Should <I>not</I> be null-terminated.</P>
<P>&#9;<I>flags</I>&#9;bit flags indicating capabilities and status of the device as defined below</P>
<I><P>&#9;ulMaxSessionCount</I>&#9;maximum number of sessions that can be opened with the token at one time by a single application (see note below)</P>
<I><P>&#9;ulSessionCount</I>&#9;number of sessions that this application currently has open with the token (see note below)</P>
<I><P>&#9;ulMaxRwSessionCount</I>&#9;maximum number of read/write sessions that can be opened with the token at one time by a single application (see note below)</P>
<I><P>&#9;ulRwSessionCount</I>&#9;number of read/write sessions that this application currently has open with the token (see note below)</P>
<I><P>&#9;ulMaxPinLen</I>&#9;maximum length in bytes of the PIN</P>
<I><P>&#9;ulMinPinLen</I>&#9;minimum length in bytes of the PIN</P>
<P>&#9;<I>ulTotalPublicMemory</I>&#9;the total amount of memory on the token in bytes in which public objects may be stored (see note below)</P>
<P>&#9;<I>ulFreePublicMemory</I>&#9;the amount of free (unused) memory on the token in bytes for public objects (see note below)</P>
<P>&#9;<I>ulTotalPrivateMemory</I>&#9;the total amount of memory on the token in bytes in which private objects may be stored (see note below)</P>
<P>&#9;<I>ulFreePrivateMemory</I>&#9;the amount of free (unused) memory on the token in bytes for private objects (see note below)</P>
<I><P>&#9;hardwareVersion&#9;</I>version number of hardware</P>
<I><P>&#9;firmwareVersion&#9;</I>version number of firmware</P>
<I><P>&#9;utcTime&#9;</I>current time as a character-string of length 16, represented in the format YYYYMMDDhhmmssxx (4 characters for the year;  2 characters each for the month, the day, the hour, the minute, and the second; and 2 additional reserved ‘0’ characters).  The value of this field only makes sense for tokens equipped with a clock, as indicated in the token information flags (see Table 10)</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">The following table defines the <I>flags</I> field:</P>
<B><P><A NAME="_Ref398089151"><A NAME="_Toc383864511"><A NAME="_Toc405794972"><A NAME="_Toc410108841">Table 10</A>, Token Information Flags</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=582>
<TR><TD WIDTH="54%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Bit Flag</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Mask</B></FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_RNG</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000001</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the token has its own random number generator</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_WRITE_PROTECTED</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000002</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the token is write-protected (see below)</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_LOGIN_REQUIRED</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000004</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if there are some cryptographic functions that a user must be logged in to perform</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_USER_PIN_INITIALIZED</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000008</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the normal user’s PIN has been initialized</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_RESTORE_KEY_NOT_NEEDED</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000020</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if a successful save of a session’s cryptographic operations state <I>always</I> contains all keys needed to restore the state of the session</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_CLOCK_ON_TOKEN</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000040</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if token has its own hardware clock</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_PROTECTED_AUTHENTICATION_PATH</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000100</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if token has a &quot;protected authentication path&quot;, whereby a user can log into the token without passing a PIN through the Cryptoki library</FONT></TD>
</TR>
<TR><TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_DUAL_CRYPTO_OPERATIONS</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000200</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if a single session with the token can perform dual cryptographic operations (see Section 10.13)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">Exactly what the <B>CKF_WRITE_PROTECTED</B> flag means is not specified in Cryptoki.  An application may be unable to perform certain actions on a write-protected token; these actions can include any of the following, among others:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Creating/modifying/deleting any object on the token.</LI></P>
<P ALIGN="JUSTIFY"><LI>Creating/modifying/deleting a token object on the token.</LI></P>
<P ALIGN="JUSTIFY"><LI>Changing the SO’s PIN.</LI></P>
<P ALIGN="JUSTIFY"><LI>Changing the normal user’s PIN.</LI></P></UL>

<P ALIGN="JUSTIFY">Note: The fields <I>ulMaxSessionCount</I>, <I>ulSessionCount</I>, <I>ulMaxRwSessionCount</I>, <I>ulRwSessionCount</I>, <I>ulTotalPublicMemory</I>, <I>ulFreePublicMemory</I>, <I>ulTotalPrivateMemory</I>, and <I>ulFreePrivateMemory</I> can have the special value CK_UNAVAILABLE_INFORMATION, which means that the token and/or library is unable or unwilling to provide that information.  In addition, the fields <I>ulMaxSessionCount</I> and <I>ulMaxRwSessionCount</I> can have the special value CK_EFFECTIVELY_INFINITE, which means that there is no practical limit on the number of sessions (resp. R/W sessions) an application can have open with the token.</P>
<P ALIGN="JUSTIFY">These values are defined as</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CK_UNAVAILABLE_INFORMATION     (~0UL)</P>
<P>#define CK_EFFECTIVELY_INFINITE        0</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">It is important to check these fields for these special values.  This is particularly true for CK_EFFECTIVELY_INFINITE, since an application seeing this value in the <I>ulMaxSessionCount</I> or <I>ulMaxRwSessionCount</I> field would otherwise conclude that it can’t open <I>any</I> sessions with the token, which is far from being the case.</P>
<P ALIGN="JUSTIFY">The upshot of all this is that the correct way to interpret (for example) the <I>ulMaxSessionCount</I> field is something along the lines of the following:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_TOKEN_INFO info;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>if ((CK_LONG) info.ulMaxSessionCount</P>
<P>    == CK_UNAVAILABLE_INFORMATION) {</P>
<P>  /* Token refuses to give value of ulMaxSessionCount */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>} else if (info.ulMaxSessionCount == CK_EFFECTIVELY_INFINITE) {</P>
<P>  /* Application can open as many sessions as it wants */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>} else {</P>
<P>  /* ulMaxSessionCount really does contain what it should */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_TOKEN_INFO_PTR</B> is a pointer to a <B>CK_TOKEN_INFO</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287652"><A NAME="_Toc319313493"><A NAME="_Toc319313686"><A NAME="_Toc319315679"><A NAME="_Toc322855274"><A NAME="_Toc322945100"><A NAME="_Toc323000683"><A NAME="_Toc323024053"><A NAME="_Toc323205384"><A NAME="_Toc323610813"><A NAME="_Toc383864827"><A NAME="_Toc385057817"><A NAME="_Toc405794635"><A NAME="_Toc410108974">8.3.&#9;Session types</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki represents session information with the following types:</P>

<UL>
<LI><A NAME="_Toc323024054"><A NAME="_Toc323205385"><A NAME="_Toc323610814"><A NAME="_Toc383864828"><A NAME="_Toc385057818"><A NAME="_Toc405794636"><A NAME="_Toc410108975"></FONT><B><FONT FACE="Palatino">CK_SESSION_HANDLE</A></A></A></A></A>; CK_SESSION_HANDLE_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SESSION_HANDLE</B> is a Cryptoki-assigned value that identifies a session.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_SESSION_HANDLE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><I><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024055"><A NAME="_Toc323205386"><A NAME="_Toc323610815"><A NAME="_Toc383864829"><A NAME="_Toc385057819">Valid session handles in Cryptoki always have nonzero values.</I>  For developers’ convenience, Cryptoki defines the following symbolic value:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CK_INVALID_HANDLE     0</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SESSION_HANDLE_PTR</B> is a pointer to a <B>CK_SESSION_HANDLE</B>.</P>

<UL>
<LI><A NAME="_Toc323024057"><A NAME="_Toc323205387"><A NAME="_Toc323610816"><A NAME="_Toc383864830"><A NAME="_Toc385057820"><A NAME="_Toc405794637"><A NAME="_Toc410108976"></A></A></A></A></A></FONT><B><FONT FACE="Palatino">CK_USER_TYPE</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_USER_TYPE</B> holds the types of Cryptoki users described in Section 5.4.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_USER_TYPE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following types of users are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKU_SO   0</P>
<P>#define CKU_USER 1</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024056"><A NAME="_Toc323205388"><A NAME="_Toc323610817"><A NAME="_Toc383864831"><A NAME="_Toc385057821"><A NAME="_Toc405794638"><A NAME="_Toc410108977"><A NAME="_Toc323024058"></FONT><B><FONT FACE="Palatino">CK_STATE</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_STATE</B> holds the session state, as described in Sections 5.6.1 and 5.6.2. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_STATE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following session states are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKS_RO_PUBLIC_SESSION 0</P>
<P>#define CKS_RO_USER_FUNCTIONS 1</P>
<P>#define CKS_RW_PUBLIC_SESSION 2</P>
<P>#define CKS_RW_USER_FUNCTIONS 3</P>
<P>#define CKS_RW_SO_FUNCTIONS   4</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323205389"><A NAME="_Toc323610818"><A NAME="_Toc383864832"><A NAME="_Toc385057822"><A NAME="_Toc405794639"><A NAME="_Toc410108978"></FONT><B><FONT FACE="Palatino">CK_SESSION_INFO</A></A></A></A></A>; CK_SESSION_INFO_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SESSION_INFO</B> provides information about a session.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SESSION_INFO {</P>
<P>  CK_SLOT_ID slotID;</P>
<P>  CK_STATE state;</P>
<P>  CK_FLAGS flags;</P>
<P>  CK_ULONG ulDeviceError;</P>
<P>} CK_SESSION_INFO;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>slotID</I>&#9;ID of the slot that interfaces with the token</P>
<I><P>&#9;state</I>&#9;the state of the session</P>
<I><P>&#9;flags</I>&#9;bit flags that define the type of session; the flags are defined below</P>
<P>&#9;<I>ulDeviceError</I>&#9;an error code defined by the cryptographic device.  Used for errors not covered by Cryptoki.</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">The following table defines the <I>flags</I> field:</P>
<B><P><A NAME="_Toc383864512"><A NAME="_Toc405794973"><A NAME="_Toc410108842">Table 11, Session Information Flags</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=582>
<TR><TD WIDTH="36%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P><A NAME="_Toc319287653"><A NAME="_Toc319313494"><A NAME="_Toc319313687"><A NAME="_Toc319315680">Bit Flag</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Mask</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_RW_SESSION</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000002</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the session is read/write; FALSE if the session is read-only</FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_SERIAL_SESSION</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000004</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>This flag is provided for backward compatibility, and should always be set to TRUE</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024059"><A NAME="_Toc323205390"><A NAME="_Toc323610819"><A NAME="_Toc383864833"><A NAME="_Toc385057823"></P>
<B><P ALIGN="JUSTIFY">CK_SESSION_INFO_PTR</B> is a pointer to a <B>CK_SESSION_INFO</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855275"><A NAME="_Toc322945101"><A NAME="_Toc323000684"><A NAME="_Toc323024060"><A NAME="_Toc323205391"><A NAME="_Toc323610820"><A NAME="_Toc383864834"><A NAME="_Toc385057824"><A NAME="_Toc405794640"><A NAME="_Toc410108979"></A></A></A></A></A>8.4.&#9;Object types</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki represents object information with the following types:</P>

<UL>
<LI><A NAME="_Toc323024061"><A NAME="_Toc323205392"><A NAME="_Toc323610821"><A NAME="_Toc383864835"><A NAME="_Toc385057825"><A NAME="_Toc405794641"><A NAME="_Toc410108980"></FONT><B><FONT FACE="Palatino">CK_OBJECT_HANDLE</A></A></A></A></A>; CK_OBJECT_HANDLE_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_OBJECT_HANDLE</B> is a token-specific identifier for an object.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_OBJECT_HANDLE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">When an object is created or found on a token by an application, Cryptoki assigns it an object handle for that application’s sessions to use to access it.  A particular object on a token does not necessarily have a handle which is fixed for the lifetime of the object; however, if a particular session can use a particular handle to access a particular object, then that session will continue to be able to use that handle to access that object as long as the session continues to exist, the object continues to exist, and the object continues to be accessible to the session.</P>
<I><P ALIGN="JUSTIFY"><A NAME="_Toc323024062"><A NAME="_Toc323205393"><A NAME="_Toc323610822"><A NAME="_Toc383864836"><A NAME="_Toc385057826">Valid object handles in Cryptoki always have nonzero values.</I>  For developers’ convenience, Cryptoki defines the following symbolic value:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CK_INVALID_HANDLE     0</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_OBJECT_HANDLE_PTR</B> is a pointer to a <B>CK_OBJECT_HANDLE</B>.</P>

<UL>
<LI><A NAME="_Toc323024063"><A NAME="_Toc323205394"><A NAME="_Toc323610823"><A NAME="_Toc383864837"><A NAME="_Toc385057827"><A NAME="_Toc405794642"><A NAME="_Toc410108981"></A></A></A></A></A></FONT><B><FONT FACE="Palatino">CK_OBJECT_CLASS</A></A></A></A></A>; CK_OBJECT_CLASS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_OBJECT_CLASS</B> is a value that identifies the classes (or types) of objects that Cryptoki recognizes.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_OBJECT_CLASS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following classes of objects are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKO_DATA            0x00000000</P>
<P>#define CKO_CERTIFICATE     0x00000001</P>
<P>#define CKO_PUBLIC_KEY      0x00000002</P>
<P>#define CKO_PRIVATE_KEY     0x00000003</P>
<P>#define CKO_SECRET_KEY      0x00000004</P>
<P>#define CKO_VENDOR_DEFINED  0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Object classes <B>CKO_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their object classes through the PKCS process.</P>
<B><P ALIGN="JUSTIFY">CK_OBJECT_CLASS_PTR</B> is a pointer to a <B>CK_OBJECT_CLASS</B>.</P>

<UL>
<LI><A NAME="_Toc323610825"><A NAME="_Toc383864839"><A NAME="_Toc385057829"><A NAME="_Toc405794643"><A NAME="_Toc410108982"><A NAME="_Toc323024065"><A NAME="_Toc323205396"></FONT><B><FONT FACE="Palatino">CK_KEY_TYPE</A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_KEY_TYPE</B> is a value that identifies a key type. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_KEY_TYPE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following key types are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKK_RSA             0x00000000</P>
<P>#define CKK_DSA             0x00000001</P>
<P>#define CKK_DH              0x00000002</P>
<P>#define CKK_ECDSA           0x00000003</P>
<P>#define CKK_KEA             0x00000005</P>
<P>#define CKK_GENERIC_SECRET  0x00000010</P>
<P>#define CKK_RC2             0x00000011</P>
<P>#define CKK_RC4             0x00000012</P>
<P>#define CKK_DES             0x00000013</P>
<P>#define CKK_DES2            0x00000014</P>
<P>#define CKK_DES3            0x00000015</P>
<P>#define CKK_CAST            0x00000016</P>
<P>#define CKK_CAST3           0x00000017</P>
<P>#define CKK_CAST5           0x00000018</P>
<P>#define CKK_CAST128         0x00000018</P>
<P>#define CKK_RC5             0x00000019</P>
<P>#define CKK_IDEA            0x0000001A</P>
<P>#define CKK_SKIPJACK        0x0000001B</P>
<P>#define CKK_BATON           0x0000001C</P>
<P>#define CKK_JUNIPER         0x0000001D</P>
<P>#define CKK_CDMF            0x0000001E</P>
<P>#define CKK_VENDOR_DEFINED  0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Key types <B>CKK_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their key types through the PKCS process.</P>

<UL>
<LI><A NAME="_Toc323610826"><A NAME="_Toc383864840"><A NAME="_Toc385057830"><A NAME="_Toc405794644"><A NAME="_Toc410108983"></FONT><B><FONT FACE="Palatino">CK_CERTIFICATE_TYPE</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_CERTIFICATE_TYPE</B> is a value that identifies a certificate type. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_CERTIFICATE_TYPE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following certificate types are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKC_X_509           0x00000000</P>
<P>#define CKC_VENDOR_DEFINED  0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024066">Certificate types <B>CKC_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their certificate types through the PKCS process.</P>

<UL>
<LI><A NAME="_Toc323205397"><A NAME="_Toc323610827"><A NAME="_Toc383864841"><A NAME="_Toc385057831"><A NAME="_Toc405794645"><A NAME="_Toc410108984"></FONT><B><FONT FACE="Palatino">CK_ATTRIBUTE_TYPE</A></A></A></A></A></A></A> </LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_ATTRIBUTE_TYPE</B> is a value that identifies an attribute type. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_ATTRIBUTE_TYPE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following attribute types are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKA_CLASS              0x00000000</P>
<P>#define CKA_TOKEN              0x00000001</P>
<P>#define CKA_PRIVATE            0x00000002</P>
<P>#define CKA_LABEL              0x00000003</P>
<P>#define CKA_APPLICATION        0x00000010</P>
<P>#define CKA_VALUE              0x00000011</P>
<P>#define CKA_CERTIFICATE_TYPE   0x00000080</P>
<P>#define CKA_ISSUER             0x00000081</P>
<P>#define CKA_SERIAL_NUMBER      0x00000082</P>
<P>#define CKA_KEY_TYPE           0x00000100</P>
<P>#define CKA_SUBJECT            0x00000101</P>
<P>#define CKA_ID                 0x00000102</P>
<P>#define CKA_SENSITIVE          0x00000103</P>
<P>#define CKA_ENCRYPT            0x00000104</P>
<P>#define CKA_DECRYPT            0x00000105</P>
<P>#define CKA_WRAP               0x00000106</P>
<P>#define CKA_UNWRAP             0x00000107</P>
<P>#define CKA_SIGN               0x00000108</P>
<P>#define CKA_SIGN_RECOVER       0x00000109</P>
<P>#define CKA_VERIFY             0x0000010A</P>
<P>#define CKA_VERIFY_RECOVER     0x0000010B</P>
<P>#define CKA_DERIVE             0x0000010C</P>
<P>#define CKA_START_DATE         0x00000110</P>
<P>#define CKA_END_DATE           0x00000111</P>
<P>#define CKA_MODULUS            0x00000120</P>
<P>#define CKA_MODULUS_BITS       0x00000121</P>
<P>#define CKA_PUBLIC_EXPONENT    0x00000122</P>
<P>#define CKA_PRIVATE_EXPONENT   0x00000123</P>
<P>#define CKA_PRIME_1            0x00000124</P>
<P>#define CKA_PRIME_2            0x00000125</P>
<P>#define CKA_EXPONENT_1         0x00000126</P>
<P>#define CKA_EXPONENT_2         0x00000127</P>
<P>#define CKA_COEFFICIENT        0x00000128</P>
<P>#define CKA_PRIME              0x00000130</P>
<P>#define CKA_SUBPRIME           0x00000131</P>
<P>#define CKA_BASE               0x00000132</P>
<P>#define CKA_VALUE_BITS         0x00000160</P>
<P>#define CKA_VALUE_LEN          0x00000161</P>
<P>#define CKA_EXTRACTABLE        0x00000162</P>
<P>#define CKA_LOCAL              0x00000163</P>
<P>#define CKA_NEVER_EXTRACTABLE  0x00000164</P>
<P>#define CKA_ALWAYS_SENSITIVE   0x00000165</P>
<P>#define CKA_MODIFIABLE         0x00000170</P>
<P>#define CKA_ECDSA_PARAMS       0x00000180</P>
<P>#define CKA_EC_POINT           0x00000181</P>
<P>#define CKA_VENDOR_DEFINED     0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Section 8.7 defines the attributes for each object class. Attribute types <B>CKA_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their attribute types through the PKCS process.</P>

<UL>
<LI><A NAME="_Toc323024067"><A NAME="_Toc323205398"><A NAME="_Toc323610828"><A NAME="_Toc383864842"><A NAME="_Toc385057832"><A NAME="_Toc405794646"><A NAME="_Toc410108985"></FONT><B><FONT FACE="Palatino">CK_ATTRIBUTE</A></A></A></A></A>; CK_ATTRIBUTE_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_ATTRIBUTE </B>is a structure that includes the type, value, and length of an attribute.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_ATTRIBUTE {</P>
<P>  CK_ATTRIBUTE_TYPE type;</P>
<P>  CK_VOID_PTR pValue;</P>
<P>  CK_ULONG ulValueLen;</P>
<P>} CK_ATTRIBUTE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>type</I>&#9;the attribute type</P>
<P>&#9;<I>pValue</I>&#9;pointer to the value of the attribute</P>
<P>&#9;<I>ulValueLen</I>&#9;length in bytes of the value</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">If an attribute has no value, then <I>ulValueLen</I> = 0, and the value of <I>pValue</I> is irrelevant. An array of <B>CK_ATTRIBUTE</B>s is called a &quot;template&quot; and is used for creating, manipulating and searching for objects.  The order of the attributes in a template <I>never</I> matters, even if the template contains vendor-specific attributes.  Note that <I>pValue</I> is a &quot;void&quot; pointer, facilitating the passing of arbitrary values.  Both the application and Cryptoki library must ensure that the pointer can be safely cast to the expected type (<I>i.e.</I>, without word-alignment errors).</P>
<B><P ALIGN="JUSTIFY">CK_ATTRIBUTE_PTR</B> is a pointer to a <B>CK_ATTRIBUTE</B>.</P>

<UL>
<LI><A NAME="_Toc323024069"><A NAME="_Toc323205400"><A NAME="_Toc323610830"><A NAME="_Toc383864844"><A NAME="_Toc385057834"><A NAME="_Toc405794647"><A NAME="_Toc410108986"><A NAME="_Toc319287654"><A NAME="_Toc319313495"><A NAME="_Toc319313688"><A NAME="_Toc319315681"><A NAME="_Toc322855276"></FONT><B><FONT FACE="Palatino">CK_DATE</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_DATE </B>is a structure that defines a date. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_DATE {</P>
<P>  CK_CHAR year[4];</P>
<P>  CK_CHAR month[2];</P>
<P>  CK_CHAR day[2];</P>
<P>} CK_DATE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>year</I>&#9;the year (&quot;1900&quot; - &quot;9999&quot;)</P>
<P>&#9;<I>month</I>&#9;the month (&quot;01&quot; - &quot;12&quot;)</P>
<P>&#9;<I>day</I>&#9;the day (&quot;01&quot; - &quot;31&quot;)</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY"><A NAME="_Toc322945102"><A NAME="_Toc323000685"><A NAME="_Toc323024070">The fields hold numeric characters from the character set in Table 3, not the literal byte values.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323205401"><A NAME="_Toc323610831"><A NAME="_Toc383864940"><A NAME="_Toc385057835"><A NAME="_Toc405794648"><A NAME="_Toc410108987"><A NAME="_Toc322855277"><A NAME="_Toc322945103"><A NAME="_Toc323000686"><A NAME="_Toc323024078"><A NAME="_Toc323205409"><A NAME="_Toc323610839"><A NAME="_Ref372962897"><A NAME="_Toc383864845"><A NAME="_Toc319287655"><A NAME="_Toc319313496"><A NAME="_Toc319313689"><A NAME="_Toc319315682"><A NAME="_Ref319978509"></A></A></A></A></A></A></A></A>8.5.&#9;Data types for mechanisms</A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki supports the following types for describing mechanisms and parameters to them:</P>

<UL>
<LI><A NAME="_Toc323024071"><A NAME="_Toc323205402"><A NAME="_Toc323610832"><A NAME="_Toc383864941"><A NAME="_Toc385057836"><A NAME="_Toc405794649"><A NAME="_Toc410108988"></FONT><B><FONT FACE="Palatino">CK_MECHANISM_TYPE</A></A></A></A></A>; CK_MECHANISM_TYPE_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_MECHANISM_TYPE </B>is a value that identifies a mechanism type. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_MECHANISM_TYPE;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For Cryptoki Version 2.01, the following mechanism types are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKM_RSA_PKCS_KEY_PAIR_GEN      0x00000000</P>
<P>#define CKM_RSA_PKCS                   0x00000001</P>
<P>#define CKM_RSA_9796                   0x00000002</P>
<P>#define CKM_RSA_X_509                  0x00000003</P>
<P>#define CKM_MD2_RSA_PKCS               0x00000004</P>
<P>#define CKM_MD5_RSA_PKCS               0x00000005</P>
<P>#define CKM_SHA1_RSA_PKCS              0x00000006</P>
<P>#define CKM_DSA_KEY_PAIR_GEN           0x00000010</P>
<P>#define CKM_DSA                        0x00000011</P>
<P>#define CKM_DSA_SHA1                   0x00000012</P>
<P>#define CKM_DH_PKCS_KEY_PAIR_GEN       0x00000020</P>
<P>#define CKM_DH_PKCS_DERIVE             0x00000021</P>
<P>#define CKM_RC2_KEY_GEN                0x00000100</P>
<P>#define CKM_RC2_ECB                    0x00000101</P>
<P>#define CKM_RC2_CBC                    0x00000102</P>
<P>#define CKM_RC2_MAC                    0x00000103</P>
<P>#define CKM_RC2_MAC_GENERAL            0x00000104</P>
<P>#define CKM_RC2_CBC_PAD                0x00000105</P>
<P>#define CKM_RC4_KEY_GEN                0x00000110</P>
<P>#define CKM_RC4                        0x00000111</P>
<P>#define CKM_DES_KEY_GEN                0x00000120</P>
<P>#define CKM_DES_ECB                    0x00000121</P>
<P>#define CKM_DES_CBC                    0x00000122</P>
<P>#define CKM_DES_MAC                    0x00000123</P>
<P>#define CKM_DES_MAC_GENERAL            0x00000124</P>
<P>#define CKM_DES_CBC_PAD                0x00000125</P>
<P>#define CKM_DES2_KEY_GEN               0x00000130</P>
<P>#define CKM_DES3_KEY_GEN               0x00000131</P>
<P>#define CKM_DES3_ECB                   0x00000132</P>
<P>#define CKM_DES3_CBC                   0x00000133</P>
<P>#define CKM_DES3_MAC                   0x00000134</P>
<P>#define CKM_DES3_MAC_GENERAL           0x00000135</P>
<P>#define CKM_DES3_CBC_PAD               0x00000136</P>
<P>#define CKM_CDMF_KEY_GEN               0x00000140</P>
<P>#define CKM_CDMF_ECB                   0x00000141</P>
<P>#define CKM_CDMF_CBC                   0x00000142</P>
<P>#define CKM_CDMF_MAC                   0x00000143</P>
<P>#define CKM_CDMF_MAC_GENERAL           0x00000144</P>
<P>#define CKM_CDMF_CBC_PAD               0x00000145</P>
<P>#define CKM_MD2                        0x00000200</P>
<P>#define CKM_MD2_HMAC                   0x00000201</P>
<P>#define CKM_MD2_HMAC_GENERAL           0x00000202</P>
<P>#define CKM_MD5                        0x00000210</P>
<P>#define CKM_MD5_HMAC                   0x00000211</P>
<P>#define CKM_MD5_HMAC_GENERAL           0x00000212</P>
<P>#define CKM_SHA_1                      0x00000220</P>
<P>#define CKM_SHA_1_HMAC                 0x00000221</P>
<P>#define CKM_SHA_1_HMAC_GENERAL         0x00000222</P>
<P>#define CKM_CAST_KEY_GEN               0x00000300</P>
<P>#define CKM_CAST_ECB                   0x00000301</P>
<P>#define CKM_CAST_CBC                   0x00000302</P>
<P>#define CKM_CAST_MAC                   0x00000303</P>
<P>#define CKM_CAST_MAC_GENERAL           0x00000304</P>
<P>#define CKM_CAST_CBC_PAD               0x00000305</P>
<P>#define CKM_CAST3_KEY_GEN              0x00000310</P>
<P>#define CKM_CAST3_ECB                  0x00000311</P>
<P>#define CKM_CAST3_CBC                  0x00000312</P>
<P>#define CKM_CAST3_MAC                  0x00000313</P>
<P>#define CKM_CAST3_MAC_GENERAL          0x00000314</P>
<P>#define CKM_CAST3_CBC_PAD              0x00000315</P>
<P>#define CKM_CAST5_KEY_GEN              0x00000320</P>
<P>#define CKM_CAST128_KEY_GEN            0x00000320</P>
<P>#define CKM_CAST5_ECB                  0x00000321</P>
<P>#define CKM_CAST128_ECB                0x00000321</P>
<P>#define CKM_CAST5_CBC                  0x00000322</P>
<P>#define CKM_CAST128_CBC                0x00000322</P>
<P>#define CKM_CAST5_MAC                  0x00000323</P>
<P>#define CKM_CAST128_MAC                0x00000323</P>
<P>#define CKM_CAST5_MAC_GENERAL          0x00000324</P>
<P>#define CKM_CAST128_MAC_GENERAL        0x00000324</P>
<P>#define CKM_CAST5_CBC_PAD              0x00000325</P>
<P>#define CKM_CAST128_CBC_PAD            0x00000325</P>
<P>#define CKM_RC5_KEY_GEN                0x00000330</P>
<P>#define CKM_RC5_ECB                    0x00000331</P>
<P>#define CKM_RC5_CBC                    0x00000332</P>
<P>#define CKM_RC5_MAC                    0x00000333</P>
<P>#define CKM_RC5_MAC_GENERAL            0x00000334</P>
<P>#define CKM_RC5_CBC_PAD                0x00000335</P>
<P>#define CKM_IDEA_KEY_GEN               0x00000340</P>
<P>#define CKM_IDEA_ECB                   0x00000341</P>
<P>#define CKM_IDEA_CBC                   0x00000342</P>
<P>#define CKM_IDEA_MAC                   0x00000343</P>
<P>#define CKM_IDEA_MAC_GENERAL           0x00000344</P>
<P>#define CKM_IDEA_CBC_PAD               0x00000345</P>
<P>#define CKM_GENERIC_SECRET_KEY_GEN     0x00000350</P>
<P>#define CKM_CONCATENATE_BASE_AND_KEY   0x00000360</P>
<P>#define CKM_CONCATENATE_BASE_AND_DATA  0x00000362</P>
<P>#define CKM_CONCATENATE_DATA_AND_BASE  0x00000363</P>
<P>#define CKM_XOR_BASE_AND_DATA          0x00000364</P>
<P>#define CKM_EXTRACT_KEY_FROM_KEY       0x00000365</P>
<P>#define CKM_SSL3_PRE_MASTER_KEY_GEN    0x00000370</P>
<P>#define CKM_SSL3_MASTER_KEY_DERIVE     0x00000371</P>
<P>#define CKM_SSL3_KEY_AND_MAC_DERIVE    0x00000372</P>
<P>#define CKM_SSL3_MD5_MAC               0x00000380</P>
<P>#define CKM_SSL3_SHA1_MAC              0x00000381</P>
<P>#define CKM_MD5_KEY_DERIVATION         0x00000390</P>
<P>#define CKM_MD2_KEY_DERIVATION         0x00000391</P>
<P>#define CKM_SHA1_KEY_DERIVATION        0x00000392</P>
<P>#define CKM_PBE_MD2_DES_CBC            0x000003A0</P>
<P>#define CKM_PBE_MD5_DES_CBC            0x000003A1</P>
<P>#define CKM_PBE_MD5_CAST_CBC           0x000003A2</P>
<P>#define CKM_PBE_MD5_CAST3_CBC          0x000003A3</P>
<P>#define CKM_PBE_MD5_CAST5_CBC          0x000003A4</P>
<P>#define CKM_PBE_MD5_CAST128_CBC        0x000003A4</P>
<P>#define CKM_PBE_SHA1_CAST5_CBC         0x000003A5</P>
<P>#define CKM_PBE_SHA1_CAST128_CBC       0x000003A5</P>
<P>#define CKM_PBE_SHA1_RC4_128           0x000003A6</P>
<P>#define CKM_PBE_SHA1_RC4_40            0x000003A7</P>
<P>#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003A8</P>
<P>#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003A9</P>
<P>#define CKM_PBE_SHA1_RC2_128_CBC       0x000003AA</P>
<P>#define CKM_PBE_SHA1_RC2_40_CBC        0x000003AB</P>
<P>#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003C0</P>
<P>#define CKM_KEY_WRAP_LYNKS             0x00000400</P>
<P>#define CKM_KEY_WRAP_SET_OAEP          0x00000401</P>
<P>#define CKM_SKIPJACK_KEY_GEN           0x00001000</P>
<P>#define CKM_SKIPJACK_ECB64             0x00001001</P>
<P>#define CKM_SKIPJACK_CBC64             0x00001002</P>
<P>#define CKM_SKIPJACK_OFB64             0x00001003</P>
<P>#define CKM_SKIPJACK_CFB64             0x00001004</P>
<P>#define CKM_SKIPJACK_CFB32             0x00001005</P>
<P>#define CKM_SKIPJACK_CFB16             0x00001006</P>
<P>#define CKM_SKIPJACK_CFB8              0x00001007</P>
<P>#define CKM_SKIPJACK_WRAP              0x00001008</P>
<P>#define CKM_SKIPJACK_PRIVATE_WRAP      0x00001009</P>
<P>#define CKM_SKIPJACK_RELAYX            0x0000100a</P>
<P>#define CKM_KEA_KEY_PAIR_GEN           0x00001010</P>
<P>#define CKM_KEA_KEY_DERIVE             0x00001011</P>
<P>#define CKM_FORTEZZA_TIMESTAMP         0x00001020</P>
<P>#define CKM_BATON_KEY_GEN              0x00001030</P>
<P>#define CKM_BATON_ECB128               0x00001031</P>
<P>#define CKM_BATON_ECB96                0x00001032</P>
<P>#define CKM_BATON_CBC128               0x00001033</P>
<P>#define CKM_BATON_COUNTER              0x00001034</P>
<P>#define CKM_BATON_SHUFFLE              0x00001035</P>
<P>#define CKM_BATON_WRAP                 0x00001036</P>
<P>#define CKM_ECDSA_KEY_PAIR_GEN         0x00001040</P>
<P>#define CKM_ECDSA                      0x00001041</P>
<P>#define CKM_ECDSA_SHA1                 0x00001042</P>
<P>#define CKM_JUNIPER_KEY_GEN            0x00001060</P>
<P>#define CKM_JUNIPER_ECB128             0x00001061</P>
<P>#define CKM_JUNIPER_CBC128             0x00001062</P>
<P>#define CKM_JUNIPER_COUNTER            0x00001063</P>
<P>#define CKM_JUNIPER_SHUFFLE            0x00001064</P>
<P>#define CKM_JUNIPER_WRAP               0x00001065</P>
<P>#define CKM_FASTHASH                   0x00001070</P>
<P>#define CKM_VENDOR_DEFINED             0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024072">Mechanism types <B>CKM_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their mechanism types through the PKCS process.</P>
<B><P ALIGN="JUSTIFY">CK_MECHANISM_TYPE_PTR</B> is a pointer to a <B>CK_MECHANISM_TYPE</B>.</P>

<UL>
<LI><A NAME="_Toc323024073"><A NAME="_Toc323205404"><A NAME="_Toc323610834"><A NAME="_Toc383864943"><A NAME="_Toc385057838"><A NAME="_Toc405794650"><A NAME="_Toc410108989"></A></FONT><B><FONT FACE="Palatino">CK_MECHANISM</A></A></A></A></A>; CK_MECHANISM_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_MECHANISM</B> is a structure that specifies a particular mechanism and any parameters it requires.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_MECHANISM {</P>
<P>  CK_MECHANISM_TYPE mechanism;</P>
<P>  CK_VOID_PTR pParameter;</P>
<P>  CK_ULONG ulParameterLen;</P>
<P>} CK_MECHANISM;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>mechanism</I>&#9;the type of mechanism</P>
<P>&#9;<I>pParameter</I>&#9;pointer to the parameter if required by the mechanism</P>
<P>&#9;<I>ulParameterLen</I>&#9;length in bytes of the parameter</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY"><A NAME="_Toc323024074">Note that <I>pParameter</I> is a &quot;void&quot; pointer, facilitating the passing of arbitrary values.  Both the application and the Cryptoki library must ensure that the pointer can be safely cast to the expected type (<I>i.e.</I>, without word-alignment errors).</P>
<B><P ALIGN="JUSTIFY">CK_MECHANISM_PTR</B> is a pointer to a <B>CK_MECHANISM</B>.</P>

<UL>
<LI><A NAME="_Toc323024075"><A NAME="_Toc323205406"><A NAME="_Toc323610836"><A NAME="_Toc383864945"><A NAME="_Toc385057840"><A NAME="_Toc405794651"><A NAME="_Toc410108990"></A></FONT><B><FONT FACE="Palatino">CK_MECHANISM_INFO</A></A></A></A></A>; CK_MECHANISM_INFO_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_MECHANISM_INFO</B> is a structure that provides information about a particular mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_MECHANISM_INFO {</P>
<P>  CK_ULONG ulMinKeySize;</P>
<P>  CK_ULONG ulMaxKeySize;</P>
<P>  CK_FLAGS flags;</P>
<P>} CK_MECHANISM_INFO;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulMinKeySize</I>&#9;the minimum size of the key for the mechanism (whether this is measured in bits or in bytes is mechanism-dependent)</P>
<P>&#9;<I>ulMaxKeySize</I>&#9;the maximum size of the key for the mechanism (whether this is measured in bits or in bytes is mechanism-dependent)</P>
<P>&#9;<I>flags</I>&#9;bit flags specifying mechanism capabilities</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">For some mechanisms, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields have meaningless values.</P>
<P ALIGN="JUSTIFY">The following table defines the <I>flags</I> field:</P>
<B><P><A NAME="_Toc383864547"><A NAME="_Toc405794974"><A NAME="_Toc410108843">Table 12, Mechanism Information Flags</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Bit Flag</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Mask</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_HW</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000001</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism is performed by the device; FALSE if the mechanism is performed in software</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_ENCRYPT</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000100</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_EncryptInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_DECRYPT</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000200</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_DecryptInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_DIGEST</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000400</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_DigestInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_SIGN</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000800</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_SignInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_SIGN_RECOVER</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00001000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_SignRecoverInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_VERIFY</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00002000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_VerifyInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_VERIFY_RECOVER</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00004000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_VerifyRecoverInit</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_GENERATE</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00008000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_GenerateKey</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_GENERATE_KEY_PAIR</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00010000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_GenerateKeyPair</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_WRAP</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00020000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_WrapKey</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_UNWRAP</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00040000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_UnwrapKey</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_DERIVE</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00080000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the mechanism can be used with <B>C_DeriveKey</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_EXTENSION</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x80000000</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if there is an extension to the flags; FALSE if no extensions.  Must be FALSE for this version.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024076"><A NAME="_Toc323205407"><A NAME="_Toc323610837"><A NAME="_Toc383864946"><A NAME="_Toc385057841"></P>
<B><P ALIGN="JUSTIFY">CK_MECHANISM_INFO_PTR</B> is a pointer to a <B>CK_MECHANISM_INFO</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384634468"><A NAME="_Toc385057842"><A NAME="_Toc405794652"><A NAME="_Toc410108991"></A></A></A></A></A>8.6.&#9;Function</A></A></A></A></A></A></A></A> types</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki represents information about functions with the following data types:</P>

<UL>
<LI><A NAME="_Toc323024080"><A NAME="_Toc323205411"><A NAME="_Toc323610841"><A NAME="_Toc383864847"><A NAME="_Toc385057844"><A NAME="_Toc405794654"><A NAME="_Toc410108992"></FONT><B><FONT FACE="Palatino">CK_RV</A></A></A></A></A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RV</B> is a value that identifies the return value of a Cryptoki function. It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_RV;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For this version of Cryptoki, the following return values are defined:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKR_OK                                0x00000000</P>
<P>#define CKR_CANCEL                            0x00000001</P>
<P>#define CKR_HOST_MEMORY                       0x00000002</P>
<P>#define CKR_SLOT_ID_INVALID                   0x00000003</P>
<P>#define CKR_GENERAL_ERROR                     0x00000005</P>
<P>#define CKR_FUNCTION_FAILED                   0x00000006</P>
<P>#define CKR_ARGUMENTS_BAD                     0x00000007</P>
<P>#define CKR_NO_EVENT                          0x00000008</P>
<P>#define CKR_NEED_TO_CREATE_THREADS            0x00000009</P>
<P>#define CKR_CANT_LOCK                         0x0000000A</P>
<P>#define CKR_ATTRIBUTE_READ_ONLY               0x00000010</P>
<P>#define CKR_ATTRIBUTE_SENSITIVE               0x00000011</P>
<P>#define CKR_ATTRIBUTE_TYPE_INVALID            0x00000012</P>
<P>#define CKR_ATTRIBUTE_VALUE_INVALID           0x00000013</P>
<P>#define CKR_DATA_INVALID                      0x00000020</P>
<P>#define CKR_DATA_LEN_RANGE                    0x00000021</P>
<P>#define CKR_DEVICE_ERROR                      0x00000030</P>
<P>#define CKR_DEVICE_MEMORY                     0x00000031</P>
<P>#define CKR_DEVICE_REMOVED                    0x00000032</P>
<P>#define CKR_ENCRYPTED_DATA_INVALID            0x00000040</P>
<P>#define CKR_ENCRYPTED_DATA_LEN_RANGE          0x00000041</P>
<P>#define CKR_FUNCTION_CANCELED                 0x00000050</P>
<P>#define CKR_FUNCTION_NOT_PARALLEL             0x00000051</P>
<P>#define CKR_FUNCTION_NOT_SUPPORTED            0x00000054</P>
<P>#define CKR_KEY_HANDLE_INVALID                0x00000060</P>
<P>#define CKR_KEY_SIZE_RANGE                    0x00000062</P>
<P>#define CKR_KEY_TYPE_INCONSISTENT             0x00000063</P>
<P>#define CKR_KEY_NOT_NEEDED                    0x00000064</P>
<P>#define CKR_KEY_CHANGED                       0x00000065</P>
<P>#define CKR_KEY_NEEDED                        0x00000066</P>
<P>#define CKR_KEY_INDIGESTIBLE                  0x00000067</P>
<P>#define CKR_KEY_FUNCTION_NOT_PERMITTED        0x00000068</P>
<P>#define CKR_KEY_NOT_WRAPPABLE                 0x00000069</P>
<P>#define CKR_KEY_UNEXTRACTABLE                 0x0000006A</P>
<P>#define CKR_MECHANISM_INVALID                 0x00000070</P>
<P>#define CKR_MECHANISM_PARAM_INVALID           0x00000071</P>
<P>#define CKR_OBJECT_HANDLE_INVALID             0x00000082</P>
<P>#define CKR_OPERATION_ACTIVE                  0x00000090</P>
<P>#define CKR_OPERATION_NOT_INITIALIZED         0x00000091</P>
<P>#define CKR_PIN_INCORRECT                     0x000000A0</P>
<P>#define CKR_PIN_INVALID                       0x000000A1</P>
<P>#define CKR_PIN_LEN_RANGE                     0x000000A2</P>
<P>#define CKR_PIN_EXPIRED                       0x000000A3</P>
<P>#define CKR_PIN_LOCKED                        0x000000A4</P>
<P>#define CKR_SESSION_CLOSED                    0x000000B0</P>
<P>#define CKR_SESSION_COUNT                     0x000000B1</P>
<P>#define CKR_SESSION_HANDLE_INVALID            0x000000B3</P>
<P>#define CKR_SESSION_PARALLEL_NOT_SUPPORTED    0x000000B4</P>
<P>#define CKR_SESSION_READ_ONLY                 0x000000B5</P>
<P>#define CKR_SESSION_EXISTS                    0x000000B6</P>
<P>#define CKR_SESSION_READ_ONLY_EXISTS          0x000000B7</P>
<P>#define CKR_SESSION_READ_WRITE_SO_EXISTS      0x000000B8</P>
<P>#define CKR_SIGNATURE_INVALID                 0x000000C0</P>
<P>#define CKR_SIGNATURE_LEN_RANGE               0x000000C1</P>
<P>#define CKR_TEMPLATE_INCOMPLETE               0x000000D0</P>
<P>#define CKR_TEMPLATE_INCONSISTENT             0x000000D1</P>
<P>#define CKR_TOKEN_NOT_PRESENT                 0x000000E0</P>
<P>#define CKR_TOKEN_NOT_RECOGNIZED              0x000000E1</P>
<P>#define CKR_TOKEN_WRITE_PROTECTED             0x000000E2</P>
<P>#define CKR_UNWRAPPING_KEY_HANDLE_INVALID     0x000000F0</P>
<P>#define CKR_UNWRAPPING_KEY_SIZE_RANGE         0x000000F1</P>
<P>#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT  0x000000F2</P>
<P>#define CKR_USER_ALREADY_LOGGED_IN            0x00000100</P>
<P>#define CKR_USER_NOT_LOGGED_IN                0x00000101</P>
<P>#define CKR_USER_PIN_NOT_INITIALIZED          0x00000102</P>
<P>#define CKR_USER_TYPE_INVALID                 0x00000103</P>
<P>#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN    0x00000104</P>
<P>#define CKR_USER_TOO_MANY_TYPES               0x00000105</P>
<P>#define CKR_WRAPPED_KEY_INVALID               0x00000110</P>
<P>#define CKR_WRAPPED_KEY_LEN_RANGE             0x00000112</P>
<P>#define CKR_WRAPPING_KEY_HANDLE_INVALID       0x00000113</P>
<P>#define CKR_WRAPPING_KEY_SIZE_RANGE           0x00000114</P>
<P>#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT    0x00000115</P>
<P>#define CKR_RANDOM_SEED_NOT_SUPPORTED         0x00000120</P>
<P>#define CKR_RANDOM_NO_RNG                     0x00000121</P>
<P>#define CKR_BUFFER_TOO_SMALL                  0x00000150</P>
<P>#define CKR_SAVED_STATE_INVALID               0x00000160</P>
<P>#define CKR_INFORMATION_SENSITIVE             0x00000170</P>
<P>#define CKR_STATE_UNSAVEABLE                  0x00000180</P>
<P>#define CKR_CRYPTOKI_NOT_INITIALIZED          0x00000190</P>
<P>#define CKR_CRYPTOKI_ALREADY_INITIALIZED      0x00000191</P>
<P>#define CKR_MUTEX_BAD                         0x000001A0</P>
<P>#define CKR_MUTEX_NOT_LOCKED                  0x000001A1</P>
<P>#define CKR_VENDOR_DEFINED                    0x80000000</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Section 10.1 defines the meaning of each <B>CK_RV</B> value. Return values <B>CKR_VENDOR_DEFINED</B> and above are permanently reserved for token vendors.  For interoperability, vendors should register their return values through the PKCS process.</P>

<UL>
<LI><A NAME="_Toc385057845"><A NAME="_Toc405794655"><A NAME="_Toc410108993"></FONT><B><FONT FACE="Palatino">CK_NOTIFY</A></A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_NOTIFY</B> is the type of a pointer to a function used by Cryptoki to perform notification callbacks.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, CK_NOTIFY)(</P>
<P>  CK_SESSION_HANDLE hSession,</P>
<P>  CK_NOTIFICATION event,</P>
<P>  CK_VOID_PTR pApplication</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The arguments to a notification callback function have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>hSession</I>&#9;The handle of the session performing the callback</P>
<P>&#9;<I>event</I>&#9;The type of notification callback</P>
<P>&#9;<I>pApplication</I>&#9;An application-defined value.  This is the same value as was passed to <B>C_OpenSession</B> to open the session performing the callback</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc405794656"><A NAME="_Toc410108994"></FONT><B><FONT FACE="Palatino">CK_C_XXX</A></A></LI></UL>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki also defines an entire family of other function pointer types.  For each function <B>C_XXX</B> in the Cryptoki API (there are 68 such functions in Cryptoki Version 2.01; see Section 10 for detailed information about each of them), Cryptoki defines a type <B>CK_C_XXX</B>, which is a pointer to a function with the same arguments and return value as <B>C_XXX</B> has.  An appropriately-set variable of type <B>CK_C_XXX</B> may be used by an application to call the Cryptoki function <B>C_XXX</B>.</P>

<UL>
<LI><A NAME="_Toc385057846"><A NAME="_Toc405794657"><A NAME="_Toc410108995"></FONT><B><FONT FACE="Palatino">CK_FUNCTION_LIST</A>; CK_FUNCTION_LIST_PTR; CK_FUNCTION_LIST_PTR_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_FUNCTION_LIST</B> is a structure which contains a Cryptoki version and a function pointer to each function in the Cryptoki API.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_FUNCTION_LIST {</P>
<P>  CK_VERSION version;</P>
<P>  CK_C_Initialize C_Initialize;</P>
<P>  CK_C_Finalize C_Finalize;</P>
<P>  CK_C_GetInfo C_GetInfo;</P>
<P>  CK_C_GetFunctionList C_GetFunctionList;</P>
<P>  CK_C_GetSlotList C_GetSlotList;</P>
<P>  CK_C_GetSlotInfo C_GetSlotInfo;</P>
<P>  CK_C_GetTokenInfo C_GetTokenInfo;</P>
<P>  CK_C_GetMechanismList C_GetMechanismList;</P>
<P>  CK_C_GetMechanismInfo C_GetMechanismInfo;</P>
<P>  CK_C_InitToken C_InitToken;</P>
<P>  CK_C_InitPIN C_InitPIN;</P>
<P>  CK_C_SetPIN C_SetPIN;</P>
<P>  CK_C_OpenSession C_OpenSession;</P>
<P>  CK_C_CloseSession C_CloseSession;</P>
<P>  CK_C_CloseAllSessions C_CloseAllSessions;</P>
<P>  CK_C_GetSessionInfo C_GetSessionInfo;</P>
<P>  CK_C_GetOperationState C_GetOperationState;</P>
<P>  CK_C_SetOperationState C_SetOperationState;</P>
<P>  CK_C_Login C_Login;</P>
<P>  CK_C_Logout C_Logout;</P>
<P>  CK_C_CreateObject C_CreateObject;</P>
<P>  CK_C_CopyObject C_CopyObject;</P>
<P>  CK_C_DestroyObject C_DestroyObject;</P>
<P>  CK_C_GetObjectSize C_GetObjectSize;</P>
<P>  CK_C_GetAttributeValue C_GetAttributeValue;</P>
<P>  CK_C_SetAttributeValue C_SetAttributeValue;</P>
<P>  CK_C_FindObjectsInit C_FindObjectsInit;</P>
<P>  CK_C_FindObjects C_FindObjects;</P>
<P>  CK_C_FindObjectsFinal C_FindObjectsFinal;</P>
<P>  CK_C_EncryptInit C_EncryptInit;</P>
<P>  CK_C_Encrypt C_Encrypt;</P>
<P>  CK_C_EncryptUpdate C_EncryptUpdate;</P>
<P>  CK_C_EncryptFinal C_EncryptFinal;</P>
<P>  CK_C_DecryptInit C_DecryptInit;</P>
<P>  CK_C_Decrypt C_Decrypt;</P>
<P>  CK_C_DecryptUpdate C_DecryptUpdate;</P>
<P>  CK_C_DecryptFinal C_DecryptFinal;</P>
<P>  CK_C_DigestInit C_DigestInit;</P>
<P>  CK_C_Digest C_Digest;</P>
<P>  CK_C_DigestUpdate C_DigestUpdate;</P>
<P>  CK_C_DigestKey C_DigestKey;</P>
<P>  CK_C_DigestFinal C_DigestFinal;</P>
<P>  CK_C_SignInit C_SignInit;</P>
<P>  CK_C_Sign C_Sign;</P>
<P>  CK_C_SignUpdate C_SignUpdate;</P>
<P>  CK_C_SignFinal C_SignFinal;</P>
<P>  CK_C_SignRecoverInit C_SignRecoverInit;</P>
<P>  CK_C_SignRecover C_SignRecover;</P>
<P>  CK_C_VerifyInit C_VerifyInit;</P>
<P>  CK_C_Verify C_Verify;</P>
<P>  CK_C_VerifyUpdate C_VerifyUpdate;</P>
<P>  CK_C_VerifyFinal C_VerifyFinal;</P>
<P>  CK_C_VerifyRecoverInit C_VerifyRecoverInit;</P>
<P>  CK_C_VerifyRecover C_VerifyRecover;</P>
<P>  CK_C_DigestEncryptUpdate C_DigestEncryptUpdate;</P>
<P>  CK_C_DecryptDigestUpdate C_DecryptDigestUpdate;</P>
<P>  CK_C_SignEncryptUpdate C_SignEncryptUpdate;</P>
<P>  CK_C_DecryptVerifyUpdate C_DecryptVerifyUpdate;</P>
<P>  CK_C_GenerateKey C_GenerateKey;</P>
<P>  CK_C_GenerateKeyPair C_GenerateKeyPair;</P>
<P>  CK_C_WrapKey C_WrapKey;</P>
<P>  CK_C_UnwrapKey C_UnwrapKey;</P>
<P>  CK_C_DeriveKey C_DeriveKey;</P>
<P>  CK_C_SeedRandom C_SeedRandom;</P>
<P>  CK_C_GenerateRandom C_GenerateRandom;</P>
<P>  CK_C_GetFunctionStatus C_GetFunctionStatus;</P>
<P>  CK_C_CancelFunction C_CancelFunction;</P>
<P>  CK_C_WaitForSlotEvent C_WaitForSlotEvent;</P>
<P>} CK_FUNCTION_LIST;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Each Cryptoki library has a static <B>CK_FUNCTION_LIST</B> structure, and a pointer to it (or to a copy of it which is also owned by the library) may be obtained by the <B>C_GetFunctionList</B> function (see Section 10.2).  The value that this pointer points to can be used by an application to quickly find out where the executable code for each function in the Cryptoki API is located.  <I>Every function in the Cryptoki API must have an entry point defined in the Cryptoki library’s <B>CK_FUNCTION_LIST</B> structure</I>.  If a particular function in the Cryptoki API is not supported by a library, then the function pointer for that function in the library’s <B>CK_FUNCTION_LIST</B> structure should point to a function stub which simply returns CKR_FUNCTION_NOT_SUPPORTED.</P>
<P ALIGN="JUSTIFY">An application may or may not be able to modify a Cryptoki library’s static <B>CK_FUNCTION_LIST</B> structure.  Whether or not it can, it should never attempt to do so.</P>
<B><P ALIGN="JUSTIFY">CK_FUNCTION_LIST_PTR</B> is a pointer to a <B>CK_FUNCTION_LIST</B>.</P>
<B><P ALIGN="JUSTIFY">CK_FUNCTION_LIST_PTR_PTR</B> is a pointer to a <B>CK_FUNCTION_LIST_PTR</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794658"><A NAME="_Ref407445939"><A NAME="_Toc410108996"><A NAME="_Ref320512055"><A NAME="_Toc322855278"><A NAME="_Toc322945120"><A NAME="_Toc323000687"><A NAME="_Toc323024081"><A NAME="_Toc323205412"><A NAME="_Toc323610842"><A NAME="_Toc383864848"><A NAME="_Toc385057849"><A NAME="_Toc319287669"><A NAME="_Toc319313510"><A NAME="_Toc319313703"><A NAME="_Toc319315696"><A NAME="_Ref320349815"></A></A></A></A></A>8.7.&#9;Locking-related types</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The types in this section are provided solely for applications which need to access Cryptoki from multiple threads simultaneously.  <I>Applications which will not do this need not use any of these types.</P>

<UL>
</I><LI><A NAME="_Toc405794659"><A NAME="_Toc410108997"></FONT><B><FONT FACE="Palatino">CK_CREATEMUTEX</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_CREATEMUTEX</B> is the type of a pointer to an application-supplied function which creates a new mutex object and returns a pointer to it.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, CK_CREATEMUTEX)(</P>
<P>  CK_VOID_PTR_PTR ppMutex</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Calling a <B>CK_CREATEMUTEX</B> function returns the pointer to the new mutex object in the location pointed to by <I>ppMutex</I>.  Such a function should return one of the following values: CKR_OK, CKR_GENERAL_ERROR, CKR_HOST_MEMORY.</P>

<UL>
<LI><A NAME="_Toc405794660"><A NAME="_Toc410108998"></FONT><B><FONT FACE="Palatino">CK_DESTROYMUTEX</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_DESTROYMUTEX</B> is the type of a pointer to an application-supplied function which destroys an existing mutex object.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, CK_DESTROYMUTEX)(</P>
<P>  CK_VOID_PTR pMutex</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The argument to a <B>CK_DESTROYMUTEX</B> function is a pointer to the mutex object to be destroyed.  Such a function should return one of the following values: CKR_OK, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MUTEX_BAD.</P>

<UL>
<LI><A NAME="_Toc405794661"><A NAME="_Toc410108999"></FONT><B><FONT FACE="Palatino">CK_LOCKMUTEX</A> and CK_UNLOCKMUTEX</A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_LOCKMUTEX</B> is the type of a pointer to an application-supplied function which locks an existing mutex object.  <B>CK_UNLOCKMUTEX</B> is the type of a pointer to an application-supplied function which unlocks an existing mutex object.  The proper behavior for these types of functions is as follows:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_LOCKMUTEX</B> function is called on a mutex which is not locked, the calling thread obtains a lock on that mutex and returns.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_LOCKMUTEX</B> function is called on a mutex which is locked by some thread other than the calling thread, the calling thread blocks and waits for that mutex to be unlocked.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_LOCKMUTEX</B> function is called on a mutex which is locked by the calling thread, the behavior of the function call is undefined.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_UNLOCKMUTEX</B> function is called on a mutex which is locked by the calling thread, that mutex is unlocked and the function call returns.  Furthermore:</LI></P>
<P ALIGN="JUSTIFY"><LI>If exactly one thread was blocking on that particular mutex, then that thread stops blocking, obtains a lock on that mutex, and its <B>CK_LOCKMUTEX</B> call returns.</LI></P>
<P ALIGN="JUSTIFY"><LI>If more than one thread was blocking on that particular mutex, then exactly one of the blocking threads is selected somehow.  That lucky thread stops blocking, obtains a lock on the mutex, and its <B>CK_LOCKMUTEX</B> call returns.  All other threads blocking on that particular mutex continue to block.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_UNLOCKMUTEX</B> function is called on a mutex which is not locked, then the function call returns the error code CKR_MUTEX_NOT_LOCKED.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a <B>CK_UNLOCKMUTEX</B> function is called on a mutex which is locked by some thread other than the calling thread, the behavior of the function call is undefined.</LI></P></UL>

<B><P ALIGN="JUSTIFY">CK_LOCKMUTEX</B> is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, CK_LOCKMUTEX)(</P>
<P>  CK_VOID_PTR pMutex</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The argument to a <B>CK_LOCKMUTEX</B> function is a pointer to the mutex object to be locked.  Such a function should return one of the following values: CKR_OK, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MUTEX_BAD.</P>
<B><P ALIGN="JUSTIFY">CK_UNLOCKMUTEX</B> is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_CALLBACK_FUNCTION(CK_RV, CK_UNLOCKMUTEX)(</P>
<P>  CK_VOID_PTR pMutex</P>
<P>);</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The argument to a <B>CK_UNLOCKMUTEX</B> function is a pointer to the mutex object to be unlocked.  Such a function should return one of the following values: CKR_OK, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MUTEX_BAD, CKR_MUTEX_NOT_LOCKED.</P>

<UL>
<LI><A NAME="_Toc405794663"><A NAME="_Toc410109000"></FONT><B><FONT FACE="Palatino">CK_C_INITIALIZE_ARGS</A>; CK_C_INITIALIZE_ARGS_PTR</A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_C_INITIALIZE_ARGS</B> is a structure containing the optional arguments for the <B>C_Initialize</B> function.  For this version of Cryptoki, these optional arguments are all concerned with the way the library deals with threads.  <B>CK_C_INITIALIZE_ARGS</B> is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_C_INITIALIZE_ARGS {</P>
<P>  CK_CREATEMUTEX CreateMutex;</P>
<P>  CK_DESTROYMUTEX DestroyMutex;</P>
<P>  CK_LOCKMUTEX LockMutex;</P>
<P>  CK_UNLOCKMUTEX UnlockMutex;</P>
<P>  CK_FLAGS flags;</P>
<P>  CK_VOID_PTR pReserved;</P>
<P>} CK_C_INITIALIZE_ARGS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>CreateMutex</I>&#9;pointer to a function to use for creating mutex objects</P>
<P>&#9;<I>DestroyMutex</I>&#9;pointer to a function to use for destroying mutex objects</P>
<P>&#9;<I>LockMutex</I>&#9;pointer to a function to use for locking mutex objects</P>
<P>&#9;<I>UnlockMutex</I>&#9;pointer to a function to use for unlocking mutex objects</P>
<P>&#9;<I>flags</I>&#9;bit flags specifying options for <B>C_Initialize</B>; the flags are defined below</P>
<P>&#9;<I>pReserved</I>&#9;reserved for future use.  Should be NULL_PTR for this version of Cryptoki</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">The following table defines the <I>flags</I> field:</P>
<B><P><A NAME="_Toc405794975"><A NAME="_Toc410108844">Table 13, C_Initialize Parameter Flags</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=582>
<TR><TD WIDTH="53%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Bit Flag</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Mask</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_LIBRARY_CANT_CREATE_OS_THREADS</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000001</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if application threads which are executing calls to the library may <I>not</I> use native operating system calls to spawn new threads; FALSE if they may</FONT></TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKF_OS_LOCKING_OK</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>0x00000002</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if the library can use the native operation system threading model for locking; FALSE otherwise</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Ref398028757"><A NAME="_Toc405794664"></P>
<B><P ALIGN="JUSTIFY">CK_C_INITIALIZE_ARGS_PTR</B> is a pointer to a <B>CK_C_INITIALIZE_ARGS</B>.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc410109001">9.&#9;Objects</A></A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki recognizes a number of classes of objects, as defined in the <B>CK_OBJECT_CLASS</B> data type.  An object consists of a set of attributes, each of which has a given value. Each attribute that an object possesses has precisely one value.  The following figure illustrates the high-level hierarchy of the Cryptoki objects and some of the attributes they support:</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image5.gif" WIDTH=576 HEIGHT=486></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108830">Figure 5, Object Attribute Hierarchy</A></P>
</B><P ALIGN="JUSTIFY">Cryptoki provides functions for creating, destroying, and copying objects in general, and for obtaining and modifying the values of their attributes.  Some of the cryptographic functions (<I>e.g.</I>, <B>C_GenerateKey</B>) also create key objects to hold their results.</P>
<P ALIGN="JUSTIFY">Objects are always &quot;well-formed&quot; in Cryptoki—that is, an object always contains all required attributes, and the attributes are always consistent with one another from the time the object is created.  This contrasts with some object-based paradigms where an object has no attributes other than perhaps a class when it is created, and is uninitialized for some time.  In Cryptoki, objects are always initialized.</P>
<P ALIGN="JUSTIFY">Tables throughout most of Section 0 define each Cryptoki attribute in terms of the data type of the attribute value and the meaning of the attribute, which may include a default initial value.  Some of the data types are defined explicitly by Cryptoki (<I>e.g.</I>, <B>CK_OBJECT_CLASS</B>).  Attribute values may also take the following types:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;Byte array&#9;an arbitrary string (array) of <B>CK_BYTE</B>s</P>
<P>&#9;Big integer&#9;a string of <B>CK_BYTE</B>s representing an unsigned integer of arbitrary size, most-significant byte first (<I>e.g.</I>, the integer 32768 is represented as the 2-byte string 0x80 0x00)</P>
<P>&#9;Local string&#9;an unpadded string of <B>CK_CHAR</B>s (see Table 3) with no null-termination</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P ALIGN="JUSTIFY">A token can hold several identical objects, <I>i.e.</I>, it is permissible for two or more objects to have exactly the same values for all their attributes.</P>
<P ALIGN="JUSTIFY">With the exception of RSA private key objects (see Section 9.7.1), each type of object in the Cryptoki specification possesses a completely well-defined set of Cryptoki attributes.  For example, an X.509 certificate object (see Section 9.4.1) has precisely the following Cryptoki attributes: <B>CKA_CLASS</B>, <B>CKA_TOKEN</B>, <B>CKA_PRIVATE</B>, <B>CKA_MODIFIABLE</B>, <B>CKA_LABEL</B>, <B>CKA_CERTIFICATE_TYPE</B>, <B>CKA_SUBJECT</B>, <B>CKA_ID</B>, <B>CKA_ISSUER</B>, <B>CKA_SERIAL_NUMBER</B>, <B>CKA_VALUE</B>.  Some of these attributes possess default values, and need not be specified when creating an object; some of these default values may even be the empty string (&quot;&quot;).  Nonetheless, the object possesses these attributes.  A given object has a single value for each attribute it possesses, even if the attribute is a vendor-specific attribute whose meaning is outside the scope of Cryptoki.</P>
<P ALIGN="JUSTIFY">In addition to possessing Cryptoki attributes, objects may possess additional vendor-specific attributes whose meanings and values are not specified by Cryptoki.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref399824691"><A NAME="_Ref399824759"><A NAME="_Ref399824797"><A NAME="_Toc405794665"><A NAME="_Toc410109002">9.1.&#9;Creating, modifying, and copying objects</A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">All Cryptoki functions that create, modify, or copy objects take a template as one of their arguments, where the template specifies attribute values.  Cryptographic functions that create objects (see Section 10.14) may also contribute some additional attribute values themselves; which attributes have values contributed by a cryptographic function call depends on which cryptographic mechanism is being performed (see Section 11).  In any case, all the required attributes supported by an object class that do not have default values must be specified when an object is created, either in the template or by the function itself.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref399215106"><A NAME="_Toc405794666"><A NAME="_Toc410109003">9.1.1.&#9;Creating objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Objects may be created with the Cryptoki functions <B>C_CreateObject</B> (see Section 10.7), <B>C_GenerateKey</B>, <B>C_GenerateKeyPair</B>, <B>C_UnwrapKey</B>, and <B>C_DeriveKey</B> (see Section 10.14).  In addition, copying an existing object (with the function <B>C_CopyObject</B>) also creates a new object, but we consider this type of object creation separately in Section 9.1.3.</P>
<P ALIGN="JUSTIFY">Attempting to create an object with any of these functions requires an appropriate template to be supplied.</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If the supplied template specifies a value for an invalid attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_TYPE_INVALID.  An attribute is valid if it is either one of the attributes described in the Cryptoki specification or an additional vendor-specific attribute supported by the library and token.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the supplied template specifies an invalid value for a valid attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_VALUE_INVALID.  The valid values for Cryptoki attributes are described in the Cryptoki specification.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the supplied template specifies a value for a read-only attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_READ_ONLY.  Whether or not a given Cryptoki attribute is read-only is explicitly stated in the Cryptoki specification; however, a particular library and token may be even more restrictive than Cryptoki specifies.  In other words, an attribute which Cryptoki says is not read-only may nonetheless be read-only under certain circumstances (<I>i.e.</I>, in conjunction with some combinations of other attributes) for a particular library and token.  Whether or not a given non-Cryptoki attribute is read-only is obviously outside the scope of Cryptoki.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the attribute values in the supplied template, together with any default attribute values and any attribute values contributed to the object by the object-creation function itself, are insufficient to fully specify the object to create, then the attempt should fail with the error code CKR_TEMPLATE_INCOMPLETE.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the attribute values in the supplied template, together with any default attribute values and any attribute values contributed to the object by the object-creation function itself, are inconsistent, then the attempt should fail with the error code CKR_TEMPLATE_INCONSISTENT.  A set of attribute values is inconsistent if not all of its members can be satisfied simultaneously <I>by the token</I>, although each value individually is valid in Cryptoki.  One example of an incomplete template would be using a template which specifies two different values for the same attribute.  Another example would be trying to create an RC4 secret key object (see Section 9.8.3) with a <B>CKA_MODULUS</B> attribute (which is appropriate for various types of public keys (see Section 9.6) or private keys (see Section 9.7), but not for RC4 keys).  A final example would be a template for creating an RSA public key with an exponent of 17 on a token which requires all RSA public keys to have exponent 65537.  Note that this final example of an inconsistent template is token-dependent—on a different token (one which permits the value of 17 for an RSA public key exponent), such a template would <I>not</I> be inconsistent.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the supplied template specifies the same value for a particular attribute more than once (or the template specifies the same value for a particular attribute that the object-creation function itself contributes to the object), then the behavior of Cryptoki is not completely specified.  The attempt to create an object can either succeed—thereby creating the same object that would have been created if the multiply-specified attribute had only appeared once—or it can fail with error code CKR_TEMPLATE_INCONSISTENT.  Library developers are encouraged to make their libraries behave as though the attribute had only appeared once in the template; application developers are strongly encouraged never to put a particular attribute into a particular template more than once.</LI></P></OL>

<P ALIGN="JUSTIFY">If more than one of the situations listed above applies to an attempt to create an object, then the error code returned from the attempt can be any of the error codes from above that applies.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794667"><A NAME="_Toc410109004">9.1.2.&#9;Modifying objects</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Objects may be modified with the Cryptoki function <B>C_SetAttributeValue</B> (see Section 10.7).  The template supplied to <B>C_SetAttributeValue</B> can contain new values for attributes which the object already possesses; values for attributes which the object does not yet possess; or both.</P>
<P ALIGN="JUSTIFY">Some attributes of an object may be modified after the object has been created, and some may not.  In addition, attributes which Cryptoki specifies are modifiable may actually <I>not</I> be modifiable on some tokens.  That is, if a Cryptoki attribute is described as being modifiable, that really means only that it is modifiable <I>insofar as the Cryptoki specification is concerned</I>.  A particular token might not actually support modification of some such attributes.  Furthermore, whether or not a particular attribute of an object on a particular token is modifiable might depend on the values of certain attributes of the object.  For example, a secret key object’s <B>CKA_SENSITIVE</B> attribute can be changed from FALSE to TRUE, but not the other way around.</P>
<P ALIGN="JUSTIFY">All the scenarios in Section 9.1.1—and the error codes they return—apply to modifying objects with <B>C_SetAttributeValue</B>, except for the possibility of a template being incomplete.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref399147407"><A NAME="_Toc405794668"><A NAME="_Toc410109005">9.1.3.&#9;Copying objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Objects may be copied with the Cryptoki function <B>C_CopyObject</B> (see Section 10.7).  In the process of copying an object, <B>C_CopyObject</B> also modifies the attributes of the newly-created copy according to an application-supplied template.</P>
<P ALIGN="JUSTIFY">The Cryptoki attributes which can be modified during the course of a <B>C_CopyObject</B> operation are the same as the Cryptoki attributes which are described as being modifiable, plus the three special attributes <B>CKA_TOKEN</B>, <B>CKA_PRIVATE</B>, and <B>CKA_MODIFIABLE</B>.  To be more precise, these attributes are modifiable during the course of a <B>C_CopyObject</B> operation <I>insofar as the Cryptoki specification is concerned</I>.  A particular token might not actually support modification of some such attributes during the course of a <B>C_CopyObject</B> operation.  Furthermore, whether or not a particular attribute of an object on a particular token is modifiable during the course of a <B>C_CopyObject</B> operation might depend on the values of certain attributes of the object.  For example, a secret key object’s <B>CKA_SENSITIVE</B> attribute can be changed from FALSE to TRUE during the course of a <B>C_CopyObject</B> operation, but not the other way around.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc322855279"><A NAME="_Toc322945121"><A NAME="_Toc323000688"><A NAME="_Toc323024082"><A NAME="_Toc323205413"><A NAME="_Toc323610843"><A NAME="_Toc383864849"><A NAME="_Toc385057850">All the scenarios in Section 9.1.1—and the error codes they return—apply to copying objects with <B>C_CopyObject</B>, except for the possibility of a template being incomplete.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794669"><A NAME="_Toc410109006">9.2.&#9;Common attributes</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following table defines the attributes common to all objects:</P>
<B><P><A NAME="_Ref383948268"><A NAME="_Toc319314009"><A NAME="_Toc319314551"><A NAME="_Toc319314966"><A NAME="_Toc319315838"><A NAME="_Toc323204879"><A NAME="_Ref323704643"><A NAME="_Toc383864513"><A NAME="_Ref384017029"><A NAME="_Toc405794976"><A NAME="_Toc410108845">Table 14</A>, Common Object Attributes</A></A></A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="24%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data Type</B></FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_CLASS<SUP>1</SUP></FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_OBJECT_CLASS</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Object class (type)</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_TOKEN</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if object is a token object; FALSE if object is a session object (default FALSE)</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIVATE</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if object is a private object; FALSE if object is a public object.  Default value is token-specific, and may depend on the values of other attributes of the object.</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_MODIFIABLE</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if object can be modified (default TRUE)</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_LABEL</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Local string</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Description of the object (default empty)</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP>Must be specified when object is created</P>
<P ALIGN="JUSTIFY">Only the <B>CKA_LABEL</B> attribute can be modified after the object is created. (The <B>CKA_TOKEN</B>, <B>CKA_PRIVATE</B>, and <B>CKA_MODIFIABLE</B> attributes can be changed in the process of copying an object, however.)</P>
<P ALIGN="JUSTIFY">Cryptoki Version 2.01 supports the following values for <B>CKA_CLASS</B> (i.e., the following classes (types) of objects): <B>CKO_DATA</B>, <B>CKO_CERTIFICATE</B>, <B>CKO_PUBLIC_KEY</B>, <B>CKO_PRIVATE_KEY</B>, and <B>CKO_SECRET_KEY</B>.</P>
<P ALIGN="JUSTIFY">The <B>CKA_TOKEN</B> attribute identifies whether the object is a token object or a session object.</P>
<P ALIGN="JUSTIFY">When the <B>CKA_PRIVATE</B> attribute is TRUE, a user may not access the object until the user has been authenticated to the token.</P>
<P ALIGN="JUSTIFY">The value of the <B>CKA_MODIFIABLE</B> attribute determines whether or not an object is read-only.  It may or may not be the case that an unmodifiable object can be deleted.</P>
<P ALIGN="JUSTIFY">The <B>CKA_LABEL</B> attribute is intended to assist users in browsing.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287656"><A NAME="_Toc319313497"><A NAME="_Toc319313690"><A NAME="_Toc319315683"><A NAME="_Toc322855280"><A NAME="_Toc322945122"><A NAME="_Toc323000689"><A NAME="_Toc323024083"><A NAME="_Toc323205414"><A NAME="_Toc323610844"><A NAME="_Toc383864850"><A NAME="_Toc385057851"><A NAME="_Toc405794670"><A NAME="_Toc410109007"><A NAME="_Ref317568626">9.3.&#9;Data object</A></A></A></A>s</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Data objects (object class <B>CKO_DATA</B>) hold information defined by an application. Other than providing access to it, Cryptoki does not attach any special meaning to a data object. The following table lists the attributes supported by data objects, in addition to the common attributes listed in Table 14:</P>
<B><P><A NAME="_Toc319314010"><A NAME="_Toc319314552"><A NAME="_Toc319314967"><A NAME="_Toc319315839"><A NAME="_Toc323204880"><A NAME="_Toc383864514"><A NAME="_Toc405794977"><A NAME="_Toc410108846">Table 15, Data Object Attributes</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="26%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="26%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_APPLICATION</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Local string</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Description of the application that manages the object (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="26%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Value of the object (default empty)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">Both of these attributes may be modified after the object is created.</P>
<P ALIGN="JUSTIFY">The <B>CKA_APPLICATION</B> attribute provides a means for applications to indicate ownership of the data objects they manage. Cryptoki does not provide a means of ensuring that only a particular application has access to a data object, however.</P>
<P ALIGN="JUSTIFY">The following is a sample template containing attributes for creating a data object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_DATA;</P>
<P>CK_CHAR label[] = &quot;A data object&quot;;</P>
<P>CK_CHAR application[] = &quot;An application&quot;;</P>
<P>CK_BYTE data[] = &quot;Sample data&quot;;</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_APPLICATION, application, sizeof(application)},</P>
<P>  {CKA_VALUE, data, sizeof(data)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287657"><A NAME="_Toc319313498"><A NAME="_Toc319313691"><A NAME="_Toc319315684"><A NAME="_Toc322855281"><A NAME="_Toc322945123"><A NAME="_Toc323000690"><A NAME="_Toc323024084"><A NAME="_Toc323205415"><A NAME="_Toc323610845"><A NAME="_Ref383856511"><A NAME="_Toc383864851"><A NAME="_Toc385057852"><A NAME="_Ref388965223"><A NAME="_Toc405794671"><A NAME="_Toc410109008">9.4.&#9;Certificate objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Certificate objects (object class <B>CKO_CERTIFICATE</B>) hold public-key certificates. Other than providing access to certificate objects, Cryptoki does not attach any special meaning to certificates. The following table defines the common certificate object attributes, in addition to the common attributes listed in Table 14:</P>
<B><P><A NAME="_Ref383948332"><A NAME="_Toc383864515"><A NAME="_Toc405794978"><A NAME="_Toc410108847">Table 16</A>, Common Certificate Object Attributes</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_CERTIFICATE_TYPE<SUP>1</SUP></FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_CERTIFICATE_TYPE</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Type of certificate</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP>Must be specified when the object is created.</P>
<P ALIGN="JUSTIFY">The <B>CKA_CERTIFICATE_TYPE</B> attribute may not be modified after an object is created.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc383864852"><A NAME="_Ref384871893"><A NAME="_Toc385057853"><A NAME="_Toc405794672"><A NAME="_Toc410109009">9.4.1.&#9;X.509 certificate objects</A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">X.509 certificate objects (certificate type <B>CKC_X_509</B>) hold X.509 certificates.  The following table defines the X.509 certificate object attributes, in addition to the common attributes listed in Table 14 and Table 16:</P>
<B><P><A NAME="_Toc319314011"><A NAME="_Toc319314553"><A NAME="_Toc319314968"><A NAME="_Toc319315840"><A NAME="_Toc323204881"><A NAME="_Toc383864516"><A NAME="_Toc405794979"><A NAME="_Toc410108848">Table 17, X.509 Certificate Object Attributes</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="31%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBJECT<SUP>1</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of the certificate subject name</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ID</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key identifier for public/private key pair (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ISSUER</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of the certificate issuer name (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SERIAL_NUMBER</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of the certificate serial number (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="55%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BER-encoding of the certificate</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP>Must be specified when the object is created.</P>
<P ALIGN="JUSTIFY">Only the <B>CKA_ID</B>, <B>CKA_ISSUER</B>, and <B>CKA_SERIAL_NUMBER</B> attributes may be modified after the object is created.</P>
<P ALIGN="JUSTIFY">The <B>CKA_ID</B> attribute is intended as a means of distinguishing multiple public-key/private-key pairs held by the same subject (whether stored in the same token or not). (Since the keys are distinguished by subject name as well as identifier, it is possible that keys for different subjects may have the same <B>CKA_ID</B> value without introducing any ambiguity.)</P>
<P ALIGN="JUSTIFY">It is intended in the interests of interoperability that the subject name and key identifier for a certificate will be the same as those for the corresponding public and private keys (though it is not required that all be stored in the same token). However, Cryptoki does not enforce this association, or even the uniqueness of the key identifier for a given subject; in particular, an application may leave the key identifier empty.</P>
<P ALIGN="JUSTIFY">The <B>CKA_ISSUER</B> and <B>CKA_SERIAL_NUMBER</B> attributes are for compatibility with PKCS #7 and Privacy Enhanced Mail (RFC1421). Note that with the version 3 extensions to X.509 certificates, the key identifier may be carried in the certificate. It is intended that the <B>CKA_ID</B> value be identical to the key identifier in such a certificate extension, although this will not be enforced by Cryptoki.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a certificate object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>C<A NAME="_Toc319287658"><A NAME="_Toc319313499"><A NAME="_Toc319313692"><A NAME="_Toc319315685"></A>K_OBJECT_CLASS class = CKO_CERTIFICATE;</P>
<P>CK_CERTIFICATE_TYPE certType = CKC_X_509;</P>
<P>CK_CHAR label[] = &quot;A certificate object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE certificate[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_CERTIFICATE_TYPE, &amp;certType, sizeof(certType)};</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_VALUE, certificate, sizeof(certificate)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323205416"><A NAME="_Toc323610846"><A NAME="_Toc383864853"><A NAME="_Toc385057854"><A NAME="_Toc405794673"><A NAME="_Toc410109010"><A NAME="_Toc322855282"><A NAME="_Toc322945124"><A NAME="_Toc323000691"><A NAME="_Toc323024085">9.5.&#9;Key </A></A>objects</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following figure illustrates details of key objects:</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image6.gif" WIDTH=576 HEIGHT=474></P>
<B><P ALIGN="CENTER"><A NAME="_Toc410108831">Figure 6, Key Attribute Detail</A></P>
</B><P ALIGN="JUSTIFY">Key objects hold encryption or authentication keys, which can be public keys, private keys, or secret keys.  The following common footnotes apply to all the tables describing attributes of keys:</P>
<B><P ALIGN="JUSTIFY"><A NAME="_Toc405794980"><A NAME="_Toc410108849">Table 18, Common footnotes for key attribute tables</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=576>
<TR><TD VALIGN="TOP">
<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Must be specified when object is created with <B>C_CreateObject</B>.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Must <I>not</I> be specified when object is created with <B>C_CreateObject</B>.</P>
<SUP><P ALIGN="JUSTIFY">3</SUP> Must be specified when object is generated with <B>C_GenerateKey</B> or <B>C_GenerateKeyPair</B>.</P>
<SUP><P ALIGN="JUSTIFY">4</SUP> Must <I>not</I> be specified when object is generated with <B>C_GenerateKey</B> or <B>C_GenerateKeyPair</B>.</P>
<SUP><P ALIGN="JUSTIFY">5</SUP> Must be specified when object is unwrapped with <B>C_UnwrapKey</B>.</P>
<SUP><P ALIGN="JUSTIFY">6</SUP> Must <I>not</I> be specified when object is unwrapped with <B>C_Unwrap</B>.</P>
<SUP><P ALIGN="JUSTIFY">7</SUP> Cannot be revealed if object has its <B>CKA_SENSITIVE</B> attribute set to TRUE or its <B>CKA_EXTRACTABLE</B> attribute set to FALSE.</P>
<SUP><P ALIGN="JUSTIFY">8</SUP> May be modified after object is created with a <B>C_SetAttributeValue</B> call, or in the process of copying object with a <B>C_CopyObject</B> call.  As mentioned previously, however, it is possible that a particular token may not permit modification of the attribute, or may not permit modification of the attribute during the course of a <B>C_CopyObject</B> call.</P>
<SUP><P ALIGN="JUSTIFY">9</SUP> Default value is token-specific, and may depend on the values of other attributes.</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The following table defines the attributes common to public key, private key and secret key classes, in addition to the common attributes listed in Table 14:</P>
<B><P><A NAME="_Ref384003113"><A NAME="_Ref323111513"><A NAME="_Toc323204882"><A NAME="_Toc383864517"><A NAME="_Toc405794981"><A NAME="_Toc410108850">Table 19</A>, <A NAME="_Ref323111519">Common Key Attributes</A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data Type</B></FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_KEY_TYPE<SUP>1,3,5</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_KEY_TYPE</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Type of key</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ID<SUP>8</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key identifier for key (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_START_DATE<SUP>8</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_DATE</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Start date for the key (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_END_DATE<SUP>8</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_DATE</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>End date for the key (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_DERIVE<SUP>8</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports key derivation (<I>i.e.</I>, if other keys can be derived from this one (default FALSE)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_LOCAL<SUP>2,4,6</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE only if key was either</P>

<UL>
<LI>generated locally (<I>i.e.</I>, on the token) with a <B>C_GenerateKey</B> or <B>C_GenerateKeyPair</B> call</LI>
<LI>created with a <B>C_CopyObject</B> call as a copy of a key which had its <B>CKA_LOCAL</B> attribute set to TRUE</UL>
</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The <B>CKA_ID</B> field is intended to distinguish among multiple keys. In the case of public and private keys, this field assists in handling multiple keys held by the same subject; the key identifier for a public key and its corresponding private key should be the same. The key identifier should also be the same as for the corresponding certificate, if one exists. Cryptoki does not enforce these associations, however. (See Section 9.4 for further commentary.)</P>
<P ALIGN="JUSTIFY">In the case of secret keys, the meaning of the <B>CKA_ID</B> attribute is up to the application.</P>
<P ALIGN="JUSTIFY">Note that the <B>CKA_START_DATE</B> and <B>CKA_END_DATE</B> attributes are for reference only; Cryptoki does not attach any special meaning to them. In particular, it does not restrict usage of a key according to the dates; doing this is up to the application.</P>
<P ALIGN="JUSTIFY">The <B>CKA_DERIVE</B> attribute has the value TRUE if and only if it is possible to derive other keys from the key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_LOCAL</B> attribute has the value TRUE if and only if the value of the key was originally generated on the token by a <B>C_GenerateKey</B> or <B>C_GenerateKeyPair</B> call.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323205417"><A NAME="_Toc323610847"><A NAME="_Toc383864854"><A NAME="_Toc385057855"><A NAME="_Ref399153796"><A NAME="_Toc405794674"><A NAME="_Toc410109011">9.6.&#9;Public key </A></A></A>objects</A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Public key objects (object class <B>CKO_PUBLIC_KEY</B>) hold public keys.  This version of Cryptoki recognizes five types of public keys: RSA, DSA, ECDSA, Diffie-Hellman, and KEA.  The following table defines the attributes common to all public keys, in addition to the common attributes listed in Table 14 and Table 19:</P>
<B><P><A NAME="_Ref384003159"><A NAME="_Toc323204883"><A NAME="_Toc383864518"><A NAME="_Toc405794982"><A NAME="_Toc410108851">Table 20</A>, Common Public Key Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="31%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBJECT<SUP>8</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of the key subject name (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ENCRYPT<SUP>8</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports encryption<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VERIFY<SUP>8</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports verification where the signature is an appendix to the data<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VERIFY_RECOVER<SUP>8</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports verification where the data is recovered from the signature<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_WRAP<SUP>8</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports wrapping (<I>i.e.</I>, can be used to wrap other keys)<SUP>9</SUP></FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc322855283"><A NAME="_Toc322945125"><A NAME="_Toc323000692"><A NAME="_Toc323024086"></P>
<P ALIGN="JUSTIFY">It is intended in the interests of interoperability that the subject name and key identifier for a public key will be the same as those for the corresponding certificate and private key.  However, Cryptoki does not enforce this, and it is not required that the certificate and private key also be stored on the token.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323205418"><A NAME="_Toc323610848"><A NAME="_Toc383864855"><A NAME="_Toc385057856"><A NAME="_Toc405794675"><A NAME="_Toc410109012">9.6.1.&#9;RSA public key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RSA public key objects (object class <B>CKO_PUBLIC_KEY, </B>key type <B>CKK_RSA</B>) hold RSA public keys.  The following table defines the RSA public key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 20:</P>
<B><P><A NAME="_Toc319314012"><A NAME="_Toc319314554"><A NAME="_Toc319314969"><A NAME="_Toc319315841"><A NAME="_Toc323204884"><A NAME="_Toc383864519"><A NAME="_Toc405794983"><A NAME="_Toc410108852">Table 21, RSA Public Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_MODULUS<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Modulus <I>n</I></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_MODULUS_BITS<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bits of modulus <I>n</I></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PUBLIC_EXPONENT<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public exponent <I>e</I></FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">Depending on the token, there may be limits on the length of key components. See PKCS #1 for more information on RSA keys.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an RSA public key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>C<A NAME="_Toc319287659"><A NAME="_Toc319313500"><A NAME="_Toc319313693"><A NAME="_Toc319315686">K_OBJECT_CLASS class = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RSA;</P>
<P>CK_CHAR label[] = &quot;An RSA public key object&quot;;</P>
<P>CK_BYTE modulus[] = {...};</P>
<P>CK_BYTE exponent[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>   {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>   {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>   {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>   {CKA_LABEL, label, sizeof(label)},</P>
<P>   {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>   {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>   {CKA_MODULUS, modulus, sizeof(modulus)},</P>
<P>   {CKA_PUBLIC_EXPONENT, exponent, sizeof(exponent)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855284"><A NAME="_Toc322945126"><A NAME="_Toc323000693"><A NAME="_Toc323024087"><A NAME="_Toc323205419"><A NAME="_Toc323610849"><A NAME="_Toc383864856"><A NAME="_Toc385057857"><A NAME="_Toc405794676"><A NAME="_Toc410109013">9.6.2.&#9;DSA public key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">DSA public key objects (object class <B>CKO_PUBLIC_KEY, </B>key type <B>CKK_DSA</B>) hold DSA public keys.  The following table defines the DSA public key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 20:</P>
<B><P><A NAME="_Toc319314013"><A NAME="_Toc319314555"><A NAME="_Toc319314970"><A NAME="_Toc319315842"><A NAME="_Toc323204885"><A NAME="_Toc383864520"><A NAME="_Toc405794984"><A NAME="_Toc410108853">Table 22, DSA Public Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I> (512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBPRIME<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Subprime <I>q</I> (160 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g</I></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public value <I>y</I></FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287660"><A NAME="_Toc319313501"><A NAME="_Toc319313694"><A NAME="_Toc319315687"></P>
<P ALIGN="JUSTIFY">The <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;DSA parameters&quot;.  See FIPS PUB 186 for more information on DSA keys.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a DSA public key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DSA;</P>
<P>CK_CHAR label[] = &quot;A DSA public key object&quot;;</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE subprime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_SUBPRIME, subprime, sizeof(subprime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057860"><A NAME="_Toc405794677"><A NAME="_Toc410109014"><A NAME="_Toc322855285"><A NAME="_Toc322945127"><A NAME="_Toc323000694"><A NAME="_Toc323024088"><A NAME="_Toc323205420"><A NAME="_Toc323610850"><A NAME="_Toc383864857"><A NAME="_Toc385057858">9.6.3.&#9;ECDSA public key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">ECDSA public key objects (object class <B>CKO_PUBLIC_KEY, </B>key type <B>CKK_ECDSA</B>) hold ECDSA public keys.  See Section 11.3 for more information about ECDSA.  The following table defines the ECDSA public key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 20:</P>
<B><P><A NAME="_Toc405794985"><A NAME="_Toc410108854">Table 23, ECDSA Public Key Object Attributes</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="31%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ECDSA_PARAMS<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of an X9.62 </FONT><FONT FACE="Courier New" SIZE=2>ECParameters</FONT><FONT FACE="Palatino" SIZE=2> value</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_EC_POINT<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of X9.62 </FONT><FONT FACE="Courier New" SIZE=2>ECPoint</FONT><FONT FACE="Palatino" SIZE=2> value <I>P</I></FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The <B>CKA_ECDSA_PARAMS</B> attribute value is known as the &quot;ECDSA parameters&quot;.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an ECDSA public key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_ECDSA;</P>
<P>CK_CHAR label[] = &quot;An ECDSA public key object&quot;;</P>
<P>CK_BYTE ecdsaParams[] = {...};</P>
<P>CK_BYTE ecPoint[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ECDSA_PARAMS, ecdsaParams, sizeof(ecdsaParams)},</P>
<P>  {CKA_EC_POINT, ecPoint, sizeof(ecPoint)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794678"><A NAME="_Toc410109015">9.6.4.&#9;Diffie-Hellman public key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Diffie-Hellman public key objects (object class <B>CKO_PUBLIC_KEY, </B>key type <B>CKK_DH</B>) hold Diffie-Hellman public keys.  The following table defines the RSA public key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 20:</P>
<B><P><A NAME="_Toc319314014"><A NAME="_Toc319314556"><A NAME="_Toc319314971"><A NAME="_Toc319315843"><A NAME="_Toc323204886"><A NAME="_Toc383864521"><A NAME="_Toc405794986"><A NAME="_Toc410108855">Table 24, Diffie-Hellman Public Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g</I></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public value <I>y</I> </FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287661"><A NAME="_Toc319313502"><A NAME="_Toc319313695"><A NAME="_Toc319315688"></P>
<P ALIGN="JUSTIFY">The <B>CKA_PRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;Diffie-Hellman parameters&quot;.  Depending on the token, there may be limits on the length of the key components. See PKCS #3 for more information on Diffie-Hellman keys.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a Diffie-Hellman public key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DH;</P>
<P>CK_CHAR label[] = &quot;A Diffie-Hellman public key object&quot;;</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {C<A NAME="_Toc322855286"><A NAME="_Toc322945128"><A NAME="_Toc323000695"><A NAME="_Toc323024089"><A NAME="_Toc323205421"><A NAME="_Toc323610851"><A NAME="_Toc383864858">KA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323624063"><A NAME="_Toc385057859"><A NAME="_Toc405794679"><A NAME="_Toc410109016">9.6.5.&#9;KEA public key objects</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">KEA public key objects (object class <B>CKO_PUBLIC_KEY, </B>key type <B>CKK_KEA</B>) hold KEA public keys.  The following table defines the KEA public key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 20:</P>
<B><P><A NAME="_Toc323691212"><A NAME="_Toc405794987"><A NAME="_Toc410108856">Table 25, KEA Public Key Object Attributes</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I> (512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBPRIME<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Subprime <I>q</I> (160 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,3,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g </I>(512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="49%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public value <I>y</I></FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;KEA parameters&quot;.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a KEA public key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_KEA;</P>
<P>CK_CHAR label[] = &quot;A KEA public key object&quot;;</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE subprime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_SUBPRIME, subprime, sizeof(subprime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057862"><A NAME="_Ref399153802"><A NAME="_Toc405794680"><A NAME="_Toc410109017">9.7.&#9;Private key </A></A></A>objects</A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Private key objects (object class <B>CKO_PRIVATE_KEY</B>) hold private keys. This version of Cryptoki recognizes five types of private key: RSA, DSA, ECDSA, Diffie-Hellman, and KEA. The following table defines the attributes common to all private keys, in addition to the common attributes listed in Table 14 and Table 19:</P>
<B><P><A NAME="_Ref384003347"><A NAME="_Ref320440894"><A NAME="_Toc323204887"><A NAME="_Toc383864522"><A NAME="_Toc405794988"><A NAME="_Toc410108857">Table 26</A>, Common Private Key Attributes</A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBJECT<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of certificate subject name (default empty)</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SENSITIVE<SUP>8</SUP> (see below)</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key is sensitive<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_DECRYPT<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports decryption<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SIGN<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports signatures where the signature is an appendix to the data<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SIGN_RECOVER<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports signatures where the data can be recovered from the signature<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_UNWRAP<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports unwrapping (<I>i.e.</I>, can be used to unwrap other keys)<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_EXTRACTABLE<SUP>8</SUP> (see below)</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key is extractable<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ALWAYS_SENSITIVE<SUP>2,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key has <I>always</I> had the CKA_SENSITIVE attribute set to TRUE</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_NEVER_EXTRACTABLE<SUP>2,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key has <I>never</I> had the CKA_EXTRACTABLE attribute set to TRUE</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">After an object is created, the <B>CKA_SENSITIVE</B> attribute may be changed, but only to the value TRUE.  Similarly, after an object is created, the <B>CKA_EXTRACTABLE</B> attribute may be changed, but only to the value FALSE.  Attempts to make other changes to the values of these attributes should return the error code CKR_ATTRIBUTE_READ_ONLY.</P>
<P ALIGN="JUSTIFY">If the <B>CKA_SENSITIVE</B> attribute is TRUE, or if the <B>CKA_EXTRACTABLE</B> attribute is FALSE, then certain attributes of the private key cannot be revealed in plaintext outside the token.  Which attributes these are is specified for each type of private key in the attribute table in the section describing that type of key.</P>
<P ALIGN="JUSTIFY">If the <B>CKA_EXTRACTABLE</B> attribute is FALSE, then the key cannot be wrapped.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc322855287"><A NAME="_Toc322945129"><A NAME="_Toc323000696"><A NAME="_Toc323024090"><A NAME="_Toc323205422"><A NAME="_Toc323610852"><A NAME="_Toc383864859"><A NAME="_Ref384665978"><A NAME="_Ref384871793"><A NAME="_Toc385057863">It is intended in the interests of interoperability that the subject name and key identifier for a private key will be the same as those for the corresponding certificate and public key.  However, this is not enforced by Cryptoki, and it is not required that the certificate and public key also be stored on the token.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref385400506"><A NAME="_Toc405794681"><A NAME="_Toc410109018">9.7.1.&#9;RSA private key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RSA private key objects (object class <B>CKO_PRIVATE_KEY, </B>key type <B>CKK_RSA</B>) hold RSA private keys.  The following table defines the RSA private key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 26:</P>
<B><P><A NAME="_Ref384613038"><A NAME="_Toc319314015"><A NAME="_Toc319314557"><A NAME="_Toc319314972"><A NAME="_Toc319315844"><A NAME="_Toc323204888"><A NAME="_Toc383864523"><A NAME="_Toc405794989"><A NAME="_Toc410108858">Table 27</A>, RSA Private Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="38%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_MODULUS<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Modulus <I>n</I></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PUBLIC_EXPONENT<SUP>4,6</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Public exponent <I>e</I></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIVATE_EXPONENT<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private exponent <I>d</I></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME_1<SUP>4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME_2<SUP>4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>q</I></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_EXPONENT_1<SUP>4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private exponent <I>d</I> modulo <I>p</I>-1 </FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_EXPONENT_2<SUP>4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private exponent <I>d</I> modulo <I>q</I>-1 </FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_COEFFICIENT<SUP>4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="48%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CRT coefficient <I>q</I><SUP>-1</SUP> mod <I>p</I>  </FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">Depending on the token, there may be limits on the length of the key components.  See PKCS #1 for more information on RSA keys.</P>
<P ALIGN="JUSTIFY">Tokens vary in what they actually store for RSA private keys.  Some tokens store all of the above attributes, which can assist in performing rapid RSA computations.  Other tokens might store only the <B>CKA_MODULUS</B> and <B>CKA_PRIVATE_EXPONENT</B> values.</P>
<P ALIGN="JUSTIFY">Because of this, Cryptoki is flexible in dealing with RSA private key objects.  When a token generates an RSA private key, it stores whichever of the fields in Table 27 it keeps track of.  Later, if an application asks for the values of the key’s various attributes, Cryptoki supplies values only for attributes whose values it can obtain (<I>i.e.</I>, if Cryptoki is asked for the value of an attribute it cannot obtain, the request fails).  Note that a Cryptoki implementation may or may not be able and/or willing to supply various attributes of RSA private keys which are not actually stored on the token.  <I>E.g.</I>, if a particular token stores values only for the <B>CKA_PRIVATE_EXPONENT</B>, <B>CKA_PRIME_1</B>, and <B>CKA_PRIME_2</B> attributes, then Cryptoki is certainly <I>able</I> to report values for all the attributes above (since they can all be computed efficiently from these three values).  However, a Cryptoki implementation may or may not actually do this extra computation.  The only attributes from Table 27 for which a Cryptoki implementation is <I>required</I> to be able to return values are <B>CKA_MODULUS</B> and <B>CKA_PRIVATE_EXPONENT</B>.</P>
<P ALIGN="JUSTIFY">If an RSA private key object is created on a token, and more attributes from Table 27 are supplied to the object creation call than are supported by the token, the extra attributes are likely to be thrown away.  If an attempt is made to create an RSA private key object on a token with insufficient attributes for that particular token, then the object creation call fails and returns CKR_TEMPLATE_INCOMPLETE.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287662"><A NAME="_Toc319313503"><A NAME="_Toc319313696"><A NAME="_Toc319315689">Note that when generating an RSA private key, there is no <B>CKA_MODULUS_BITS</B> attribute specified.  This is because RSA private keys are only generated as part of an RSA key <I>pair</I>, and the <B>CKA_MODULUS_BITS</B> attribute for the pair is specified in the template for the RSA public key.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an RSA private key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RSA;</P>
<P>CK_CHAR label[] = &quot;An RSA private key object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE modulus[] = {...};</P>
<P>CK_BYTE publicExponent[] = {...};</P>
<P>CK_BYTE privateExponent[] = {...};</P>
<P>CK_BYTE prime1[] = {...};</P>
<P>CK_BYTE prime2[] = {...};</P>
<P>CK_BYTE exponent1[] = {...};</P>
<P>CK_BYTE exponent2[] = {...};</P>
<P>CK_BYTE coefficient[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_DECRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_SIGN, &amp;true, sizeof(true)},</P>
<P>  {CKA_MODULUS, modulus, sizeof(modulus)},</P>
<P>  {CKA_PUBLIC_EXPONENT, publicExponent, sizeof(publicExponent)},</P>
<P>  {CKA_PRIVATE_EXPONENT, privateExponent, sizeof(privateExponent)},</P>
<P>  {CKA_PRIME_1, prime1, sizeof(prime1)},</P>
<P>  {CKA_PRIME_2, prime2, sizeof(prime2)},</P>
<P>  {CKA_EXPONENT_1, exponent1, sizeof(exponent1)},</P>
<P>  {CKA_EXPONENT_2, exponent2, sizeof(exponent2)},</P>
<P>  {CKA_COEFFICIENT, coefficient, sizeof(coefficient)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855288"><A NAME="_Toc322945130"><A NAME="_Toc323000697"><A NAME="_Toc323024091"><A NAME="_Toc323205423"><A NAME="_Toc323610853"><A NAME="_Toc383864860"><A NAME="_Toc385057864"><A NAME="_Toc405794682"><A NAME="_Toc410109019">9.7.2.&#9;DSA private key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">DSA private key objects (object class <B>CKO_PRIVATE_KEY, </B>key type <B>CKK_DSA</B>) hold DSA private keys.  The following table defines the DSA private key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 26:</P>
<B><P><A NAME="_Toc319314016"><A NAME="_Toc319314558"><A NAME="_Toc319314973"><A NAME="_Toc319315845"><A NAME="_Toc323204889"><A NAME="_Toc383864524"><A NAME="_Toc405794990"><A NAME="_Toc410108859">Table 28, DSA Private Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="36%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I> (512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBPRIME<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Subprime <I>q</I> (160 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g</I></FONT></TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private value <I>x</I></FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;DSA parameters&quot;.  See FIPS PUB 186 for more information on DSA keys.</P>
<P ALIGN="JUSTIFY">Note that when generating a DSA private key, the DSA parameters are <I>not</I> specified in the key’s template.  This is because DSA private keys are only generated as part of a DSA key <I>pair</I>, and the DSA parameters for the pair are specified in the template for the DSA public key.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287663"><A NAME="_Toc319313504"><A NAME="_Toc319313697"><A NAME="_Toc319315690">The following is a sample template for creating a DSA private key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DSA;</P>
<P>CK_CHAR label[] = &quot;A DSA private key object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE subprime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_SIGN, &amp;true, sizeof(true)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_SUBPRIME, subprime, sizeof(subprime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057867"><A NAME="_Toc405794683"><A NAME="_Toc410109020"><A NAME="_Toc322855289"><A NAME="_Toc322945131"><A NAME="_Toc323000698"><A NAME="_Toc323024092"><A NAME="_Toc323205424"><A NAME="_Toc323610854"><A NAME="_Toc383864861"><A NAME="_Toc385057865">9.7.3.&#9;ECDSA private key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">ECDSA private key objects (object class <B>CKO_PRIVATE_KEY, </B>key type <B>CKK_ECDSA</B>) hold ECDSA private keys.  See Section 11.3 for more information about ECDSA.  The following table defines the ECDSA private key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 26:</P>
<B><P><A NAME="_Toc405794991"><A NAME="_Toc410108860">Table 29, ECDSA Private Key Object Attributes</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="31%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ECDSA_PARAMS<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DER-encoding of an X9.62 </FONT><FONT FACE="Courier New" SIZE=2>ECParameters</FONT><FONT FACE="Palatino" SIZE=2> value</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="53%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>X9.62 private value <I>d</I></FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The <B>CKA_ECDSA_PARAMS</B> attribute value is known as the &quot;ECDSA parameters&quot;.</P>
<P ALIGN="JUSTIFY">Note that when generating an ECDSA private key, the ECDSA parameters are <I>not</I> specified in the key’s template.  This is because ECDSA private keys are only generated as part of an ECDSA key <I>pair</I>, and the ECDSA parameters for the pair are specified in the template for the ECDSA public key.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an ECDSA private key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_ECDSA;</P>
<P>CK_CHAR label[] = &quot;An ECDSA private key object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE ecdsaParams[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_DERIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_ECDSA_PARAMS, ecdsaParams, sizeof(ecdsaParams)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794684"><A NAME="_Toc410109021">9.7.4.&#9;Diffie-Hellman private key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Diffie-Hellman private key objects (object class <B>CKO_PRIVATE_KEY, </B>key type <B>CKK_DH</B>) hold Diffie-Hellman private keys.  The following table defines the Diffie-Hellman private key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 26:</P>
<B><P><A NAME="_Toc319314017"><A NAME="_Toc319314559"><A NAME="_Toc319314974"><A NAME="_Toc319315846"><A NAME="_Toc323204890"><A NAME="_Toc383864525"><A NAME="_Toc405794992"><A NAME="_Toc410108861">Table 30, Diffie-Hellman Private Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=514>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g</I></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private value <I>x</I></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_BITS<SUP>2,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bits of private value <I>x</I></FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The <B>CKA_PRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;Diffie-Hellman parameters&quot;.  Depending on the token, there may be limits on the length of the key components.  See PKCS #3 for more information on Diffie-Hellman keys.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287664"><A NAME="_Toc319313505"><A NAME="_Toc319313698"><A NAME="_Toc319315691">Note that when generating an Diffie-Hellman private key, the Diffie-Hellman parameters are <I>not</I> specified in the key’s template.  This is because Diffie-Hellman private keys are only generated as part of a Diffie-Hellman key <I>pair</I>, and the Diffie-Hellman parameters for the pair are specified in the template for the Diffie-Hellman public key.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a Diffie-Hellman private key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DH;</P>
<P>CK_CHAR label[] = &quot;A Diffie-Hellman private key object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_DERIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057866"><A NAME="_Toc405794685"><A NAME="_Toc410109022"><A NAME="_Toc322855290"><A NAME="_Toc322945132"><A NAME="_Toc323000699"><A NAME="_Toc323024093"><A NAME="_Toc323205425"><A NAME="_Toc323610855"><A NAME="_Toc383864862">9.7.5.&#9;KEA<A NAME="_Toc323624067"> private key objects</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">KEA private key objects (object class <B>CKO_PRIVATE_KEY, </B>key type <B>CKK_KEA</B>) hold KEA private keys.  The following table defines the KEA private key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 26:</P>
<B><P><A NAME="_Toc323691216"><A NAME="_Toc405794993"><A NAME="_Toc410108862">Table 31, KEA Private Key Object Attributes</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=510>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_PRIME<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Prime <I>p</I> (512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SUBPRIME<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Subprime <I>q</I> (160 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_BASE<SUP>1,4,6</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Base <I>g </I>(512 to 1024 bits, in steps of 64 bits)</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Big integer</FONT></TD>
<TD WIDTH="52%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Private value <I>x</I></FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B> and <B>CKA_BASE</B> attribute values are collectively the &quot;KEA parameters&quot;.</P>
<P ALIGN="JUSTIFY">Note that when generating a KEA private key, the KEA parameters are <I>not</I> specified in the key’s template.  This is because KEA private keys are only generated as part of a KEA key <I>pair</I>, and the KEA parameters for the pair are specified in the template for the KEA public key.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a KEA private key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_KEA;</P>
<P>CK_CHAR label[] = &quot;A KEA private key object&quot;;</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE subprime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_DERIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_SUBPRIME, subprime, sizeof(subprime)},</P>
<P>  {CKA_BASE, base, sizeof(base)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057869"><A NAME="_Toc405794686"><A NAME="_Toc410109023">9.8.&#9;Secret key objects</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Secret key objects (object class <B>CKO_SECRET_KEY</B>) hold secret keys. This version of Cryptoki recognizes the following types of secret key: generic, RC2, RC4, RC5, DES, DES2, DES3, CAST, CAST3, CAST128 (also known as CAST5), IDEA, CDMF, SKIPJACK, BATON, and JUNIPER.  The following table defines the attributes common to all secret keys, in addition to the common attributes listed in Table 14 and Table 19:</P>
<B><P><A NAME="_Ref384003560"><A NAME="_Toc323204891"><A NAME="_Toc383864526"><A NAME="_Toc405794994"><A NAME="_Toc410108863">Table 32</A>, Common Secret Key Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="38%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SENSITIVE<SUP>8</SUP> (see below)</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if object is sensitive (default FALSE)</FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ENCRYPT<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports encryption<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_DECRYPT<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports decryption<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_SIGN<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports signatures (<I>i.e.</I>, authentication codes) where the signature is an appendix to the data<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VERIFY<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports verification (<I>i.e.</I>, of authentication codes) where the signature is an appendix to the data<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_WRAP<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports wrapping (<I>i.e.</I>, can be used to wrap other keys)<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_UNWRAP<SUP>8</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key supports unwrapping (<I>i.e.</I>, can be used to unwrap other keys)<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_EXTRACTABLE<SUP>8</SUP> (see below)</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key is extractable<SUP>9</SUP></FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_ALWAYS_SENSITIVE<SUP>2,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key has <I>always</I> had the CKA_SENSITIVE attribute set to TRUE</FONT></TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_NEVER_EXTRACTABLE<SUP>2,4,6</SUP></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_BBOOL</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>TRUE if key has <I>never</I> had the CKA_EXTRACTABLE attribute set to TRUE</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">After an object is created, the <B>CKA_SENSITIVE</B> attribute may be changed, but only to the value TRUE.  Similarly, after an object is created, the <B>CKA_EXTRACTABLE</B> attribute may be changed, but only to the value FALSE.  Attempts to make other changes to the values of these attributes should return the error code CKR_ATTRIBUTE_READ_ONLY.</P>
<P ALIGN="JUSTIFY">If the <B>CKA_SENSITIVE</B> attribute is TRUE, or if the <B>CKA_EXTRACTABLE</B> attribute is FALSE, then certain attributes of the secret key cannot be revealed in plaintext outside the token.  Which attributes these are is specified for each type of secret key in the attribute table in the section describing that type of key.</P>
<P ALIGN="JUSTIFY">If the <B>CKA_EXTRACTABLE</B> attribute is FALSE, then the key cannot be wrapped.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855296"><A NAME="_Toc322945138"><A NAME="_Toc323000705"><A NAME="_Toc323024094"><A NAME="_Toc323205426"><A NAME="_Toc323610856"><A NAME="_Toc383864863"><A NAME="_Toc385057870"><A NAME="_Toc405794687"><A NAME="_Toc410109024"><A NAME="_Toc322855291"><A NAME="_Toc322945133"><A NAME="_Toc323000700">9.8.1.&#9;Generic secret key objects</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Generic secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_GENERIC_SECRET</B>) hold generic secret keys. These keys do not support encryption, decryption, signatures or verification; however, other keys can be derived from them. The following table defines the generic secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc323204892"><A NAME="_Toc383864527"><A NAME="_Toc405794995"><A NAME="_Toc410108864">Table 33, Generic Secret Key Object Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=447>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (arbitrary length)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a generic secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_GENERIC_SECRET;</P>
<P>CK_CHAR label[] = &quot;A generic secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_DERIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323024095"><A NAME="_Toc323205427"><A NAME="_Toc323610857"><A NAME="_Toc383864864"><A NAME="_Toc385057871"><A NAME="_Toc405794688"><A NAME="_Toc410109025">9.8.2.&#9;RC2 secret key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_RC2</B>) hold RC2 keys.  The following table defines the RC2 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc319314018"><A NAME="_Toc319314560"><A NAME="_Toc319314975"><A NAME="_Toc319315847"><A NAME="_Toc323204893"><A NAME="_Toc383864528"><A NAME="_Toc405794996"><A NAME="_Toc410108865">Table 34, RC2 Secret Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=447>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (1 to 128 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287665"><A NAME="_Toc319313506"><A NAME="_Toc319313699"><A NAME="_Toc319315692"></P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an RC2 secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RC2;</P>
<P>CK_CHAR label[] = &quot;An RC2 secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855292"><A NAME="_Toc322945134"><A NAME="_Toc323000701"><A NAME="_Toc323024096"><A NAME="_Toc323205428"><A NAME="_Toc323610858"><A NAME="_Toc383864865"><A NAME="_Toc385057872"><A NAME="_Ref399153689"><A NAME="_Toc405794689"><A NAME="_Toc410109026">9.8.3.&#9;RC4 secret key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC4 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_RC4</B>) hold RC4 keys.  The following table defines the RC4 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc319314019"><A NAME="_Toc319314561"><A NAME="_Toc319314976"><A NAME="_Toc319315848"><A NAME="_Toc323204894"><A NAME="_Toc383864529"><A NAME="_Toc405794997"><A NAME="_Toc410108866">Table 35, RC4 Secret Key Object</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=447>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (1 to 256 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287666"><A NAME="_Toc319313507"><A NAME="_Toc319313700"><A NAME="_Toc319315693"></P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an RC4 secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RC4;</P>
<P>CK_CHAR label[] = &quot;An RC4 secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057873"><A NAME="_Toc405794690"><A NAME="_Toc410109027"><A NAME="_Toc322855293"><A NAME="_Toc322945135"><A NAME="_Toc323000702"><A NAME="_Toc323024097"><A NAME="_Toc323205429"><A NAME="_Toc323610859"><A NAME="_Toc383864866">9.8.4.&#9;RC5 secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_RC5</B>) hold RC5 keys.  The following table defines the RC5 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405794998"><A NAME="_Toc410108867">Table 36, RC4 Secret Key Object</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=447>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (0 to 255 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an RC5 secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RC5;</P>
<P>CK_CHAR label[] = &quot;An RC5 secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057874"><A NAME="_Toc405794691"><A NAME="_Toc410109028">9.8.5.&#9;DES secret key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">DES secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_DES</B>) hold single-length DES keys.  The following table defines the DES secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc319314020"><A NAME="_Toc319314562"><A NAME="_Toc319314977"><A NAME="_Toc319315849"><A NAME="_Toc323204895"><A NAME="_Toc383864530"><A NAME="_Toc405794999"><A NAME="_Toc410108868">Table 37, DES Secret Key Object</A></A></A></A></A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 8 bytes long)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287667"><A NAME="_Toc319313508"><A NAME="_Toc319313701"><A NAME="_Toc319315694"></P>
<P ALIGN="JUSTIFY">DES keys must always have their parity bits properly set as described in FIPS PUB 46-2.  Attempting to create or unwrap a DES key with incorrect parity will return an error.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a DES secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES;</P>
<P>CK_CHAR label[] = &quot;A DES secret key object&quot;;</P>
<P>CK_BYTE value[8] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P>
<P>&nbsp;</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855294"><A NAME="_Toc322945136"><A NAME="_Toc323000703"><A NAME="_Toc323024098"><A NAME="_Toc323205430"><A NAME="_Toc323610860"><A NAME="_Toc383864867"><A NAME="_Toc385057875"><A NAME="_Toc405794692"><A NAME="_Toc410109029">9.8.6.&#9;DES2 secret key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">DES2 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_DES2</B>) hold double-length DES keys.  The following table defines the DES2 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc319314021"><A NAME="_Toc319314563"><A NAME="_Toc319314978"><A NAME="_Toc319315850"><A NAME="_Toc323204896"><A NAME="_Toc383864531"><A NAME="_Toc405795000"><A NAME="_Toc410108869">Table 38, DES2 Secret Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 16 bytes long)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc319287668"><A NAME="_Toc319313509"><A NAME="_Toc319313702"><A NAME="_Toc319315695"></P>
<P ALIGN="JUSTIFY">DES2 keys must always have their parity bits properly set as described in FIPS PUB 46-2 (<I>i.e.</I>, each of the DES keys comprising a DES2 key must have its parity bits properly set).  Attempting to create or unwrap a DES2 key with incorrect parity will return an error.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a double-length DES secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES2;</P>
<P>CK_CHAR label[] = &quot;A DES2 secret key object&quot;;</P>
<P>CK_BYTE value[16] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855295"><A NAME="_Toc322945137"><A NAME="_Toc323000704"><A NAME="_Toc323024099"><A NAME="_Toc323205431"><A NAME="_Toc323610861"><A NAME="_Toc383864868"><A NAME="_Toc385057876"><A NAME="_Toc405794693"><A NAME="_Toc410109030">9.8.7.&#9;DES3 secret key objects</A></A></A></A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">DES3 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_DES3</B>) hold triple-length DES keys.  The following table defines the DES3 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc319314022"><A NAME="_Toc319314564"><A NAME="_Toc319314979"><A NAME="_Toc319315851"><A NAME="_Toc323204897"><A NAME="_Toc383864532"><A NAME="_Toc405795001"><A NAME="_Toc410108870">Table 39, DES3 Secret Key Object</A></A></A></A> Attributes</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 24 bytes long)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">DES3 keys must always have their parity bits properly set as described in FIPS PUB 46-2 (<I>i.e.</I>, each of the DES keys comprising a DES3 key must have its parity bits properly set).  Attempting to create or unwrap a DES3 key with incorrect parity will return an error.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a triple-length DES secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES3;</P>
<P>CK_CHAR label[] = &quot;A DES3 secret key object&quot;;</P>
<P>CK_BYTE value[24] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323624071"><A NAME="_Toc385057877"><A NAME="_Toc405794694"><A NAME="_Toc410109031">9.8.8.&#9;CAST secret key objects</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CAST secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_CAST</B>) hold CAST keys.  The following table defines the CAST secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc323691220"><A NAME="_Toc405795002"><A NAME="_Toc410108871">Table 40, CAST Secret Key Object Attributes</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (1 to 8 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The following is a sample template for creating a CAST secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_CAST;</P>
<P>CK_CHAR label[] = &quot;A CAST secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057878"><A NAME="_Toc405794695"><A NAME="_Toc410109032">9.8.9.&#9;CAST3 secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CAST3 secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_CAST3</B>) hold CAST3 keys.  The following table defines the CAST3 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405795003"><A NAME="_Toc410108872">Table 41, CAST3 Secret Key Object Attributes</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (1 to 8 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The following is a sample template for creating a CAST3 secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_CAST3;</P>
<P>CK_CHAR label[] = &quot;A CAST3 secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057879"><A NAME="_Toc405794696"><A NAME="_Toc410109033">9.8.10.&#9;CAST128 (CAST5) secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CAST128 (also known as CAST5) secret key objects (object class <B>CKO_SECRET_KEY, </B>key type CKK_CAST128 or <B>CKK_CAST5</B>) hold CAST128 keys.  The following table defines the CAST128 secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405795004"><A NAME="_Toc410108873">Table 42, CAST128 (CAST5) Secret Key Object Attributes</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (1 to 16 bytes)</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE_LEN<SUP>2,3,6</SUP></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CK_ULONG</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Length in bytes of key value</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">The following is a sample template for creating a CAST128 (CAST5) secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_CAST128;</P>
<P>CK_CHAR label[] = &quot;A CAST128 secret key object&quot;;</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057880"><A NAME="_Toc405794697"><A NAME="_Toc410109034"><A NAME="_Toc323624073"><A NAME="_Ref320515101"><A NAME="_Toc322855297"><A NAME="_Toc322945139"><A NAME="_Toc323000706"><A NAME="_Toc323024100"><A NAME="_Toc323205432"><A NAME="_Toc323610862"><A NAME="_Toc383864869">9.8.11.&#9;IDEA secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">IDEA secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_IDEA</B>) hold IDEA keys.  The following table defines the IDEA secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405795005"><A NAME="_Toc410108874">Table 43, IDEA Secret Key Object</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 16 bytes long)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating an IDEA secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_IDEA;</P>
<P>CK_CHAR label[] = &quot;An IDEA secret key object&quot;;</P>
<P>CK_BYTE value[16] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057881"><A NAME="_Toc405794698"><A NAME="_Toc410109035">9.8.12.&#9;CDMF secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CDMF secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_CDMF</B>) hold single-length CDMF keys.  The following table defines the CDMF secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405795006"><A NAME="_Toc410108875">Table 44, CDMF Secret Key Object</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 8 bytes long)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">CDMF keys must always have their parity bits properly set in exactly the same fashion described for DES keys in FIPS PUB 46-2.  Attempting to create or unwrap a CDMF key with incorrect parity will return an error.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a CDMF secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_CDMF;</P>
<P>CK_CHAR label[] = &quot;A CDMF secret key object&quot;;</P>
<P>CK_BYTE value[8] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057882"><A NAME="_Toc405794699"><A NAME="_Toc410109036">9.8.13.&#9;SKIPJACK secret key objects</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_SKIPJACK</B>) holds a single-length MEK or a TEK.  The following table defines the SKIPJACK secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc323691222"><A NAME="_Toc405795007"><A NAME="_Toc410108876">Table 45, SKIPJACK Secret Key Object</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 12 bytes long)</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">SKIPJACK keys have 16 checksum bits, and these bits must be properly set.  Attempting to create or unwrap a SKIPJACK key with incorrect checksum bits will return an error.</P>
<P ALIGN="JUSTIFY">It is not clear that any tokens exist (or will ever exist) which permit an application to create a SKIPJACK key with a specified value.  Nonetheless, we provide templates for doing so.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a SKIPJACK MEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_SKIPJACK;</P>
<P>CK_CHAR label[] = &quot;A SKIPJACK MEK secret key object&quot;;</P>
<P>CK_BYTE value[12] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following is a sample template for creating a SKIPJACK TEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_SKIPJACK;</P>
<P>CK_CHAR label[] = &quot;A SKIPJACK TEK secret key object&quot;;</P>
<P>CK_BYTE value[12] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057883"><A NAME="_Toc405794700"><A NAME="_Toc410109037">9.8.14.&#9;BATON secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_BATON</B>) hold single-length BATON keys.  The following table defines the BATON secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, and Table 32:</P>
<B><P><A NAME="_Toc405795008"><A NAME="_Toc410108877">Table 46, BATON Secret Key Object</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 40 bytes long)</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">BATON keys have 160 checksum bits, and these bits must be properly set.  Attempting to create or unwrap a BATON key with incorrect checksum bits will return an error.</P>
<P ALIGN="JUSTIFY">It is not clear that any tokens exist (or will ever exist) which permit an application to create a BATON key with a specified value.  Nonetheless, we provide templates for doing so.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a BATON MEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_BATON;</P>
<P>CK_CHAR label[] = &quot;A BATON MEK secret key object&quot;;</P>
<P>CK_BYTE value[40] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following is a sample template for creating a BATON TEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_BATON;</P>
<P>CK_CHAR label[] = &quot;A BATON TEK secret key object&quot;;</P>
<P>CK_BYTE value[40] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057884"><A NAME="_Toc405794701"><A NAME="_Toc410109038">9.8.15.&#9;JUNIPER secret key objects</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">JUNIPER secret key objects (object class <B>CKO_SECRET_KEY, </B>key type <B>CKK_JUNIPER</B>) hold single-length JUNIPER keys.  The following table defines the JUNIPER secret key object attributes, in addition to the common attributes listed in Table 14, Table 19, Table 32:</P>
<B><P><A NAME="_Toc405795009"><A NAME="_Toc410108878">Table 47, JUNIPER Secret Key Object</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=450>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Attribute</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Data type</B></FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Meaning</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CKA_VALUE<SUP>1,4,6,7</SUP></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Byte array</FONT></TD>
<TD WIDTH="47%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Key value (always 40 bytes long)</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
</SUP><P ALIGN="JUSTIFY">JUNIPER keys have 160 checksum bits, and these bits must be properly set.  Attempting to create or unwrap a JUNIPER key with incorrect checksum bits will return an error.</P>
<P ALIGN="JUSTIFY">It is not clear that any tokens exist (or will ever exist) which permit an application to create a JUNIPER key with a specified value.  Nonetheless, we provide templates for doing so.</P>
<P ALIGN="JUSTIFY">The following is a sample template for creating a JUNIPER MEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_JUNIPER;</P>
<P>CK_CHAR label[] = &quot;A JUNIPER MEK secret key object&quot;;</P>
<P>CK_BYTE value[40] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The following is a sample template for creating a JUNIPER TEK secret key object:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_OBJECT_CLASS class = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_JUNIPER;</P>
<P>CK_CHAR label[] = &quot;A JUNIPER TEK secret key object&quot;;</P>
<P>CK_BYTE value[40] = {...};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;class, sizeof(class)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_LABEL, label, sizeof(label)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Ref384459053"><A NAME="_Toc385057885"><A NAME="_Toc405794702"><A NAME="_Toc410109039">10.&#9;Functions</A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki's functions are organized into the following categories:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>general-purpose functions (4 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>slot and token management functions (9 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>session management functions (8 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>object management functions (9 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>encryption functions (4 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>decryption functions (4 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>message digesting functions (5 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>signing and MACing functions (6 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>functions for verifying signatures and MACs (6 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>dual-purpose cryptographic functions (4 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>key management functions (5 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>random number generation functions (2 functions)</LI></P>
<P ALIGN="JUSTIFY"><LI>parallel function management functions (2 functions)</LI></P></UL>

<P ALIGN="JUSTIFY">In addition to these 68 functions in the Cryptoki Version 2.01 API proper, Cryptoki can use application-supplied callback functions to notify an application of certain events, and can also use application-supplied functions to handle mutex objects for safe multi-threaded library access.</P>
<P ALIGN="JUSTIFY">Execution of a Cryptoki function call is in general an all-or-nothing affair, <I>i.e.</I>, a function call accomplishes either its entire goal, or nothing at all.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If a Cryptoki function executes successfully, it returns the value CKR_OK.</LI></P>
<P ALIGN="JUSTIFY"><LI>If a Cryptoki function does not execute successfully, it returns some value other than CKR_OK, and the token is in the same state as it was in prior to the function call.  If the function call was supposed to modify the contents of certain memory addresses on the host computer, these memory addresses may have been modified, despite the failure of the function.</LI></P>
<P ALIGN="JUSTIFY"><LI>In unusual (and extremely unpleasant!) circumstances, a function can fail with the return value CKR_GENERAL_ERROR.  When this happens, the token and/or host computer may be in an inconsistent state, and the goals of the function may have been partially achieved.</LI></P></UL>

<P ALIGN="JUSTIFY">There are a small number of Cryptoki functions whose return values do not behave precisely as described above; these exceptions are documented individually with the description of the functions themselves.</P>
<P ALIGN="JUSTIFY">A Cryptoki library need not support every function in the Cryptoki API.  However, even an unsupported function must have a &quot;stub&quot; in the library which simply returns the value CKR_FUNCTION_NOT_SUPPORTED.  The function’s entry in the library’s <B>CK_FUNCTION_LIST</B> structure (as obtained by <B>C_GetFunctionList</B>) should point to this stub function (see Section 8.6).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384634295"><A NAME="_Toc385057886"><A NAME="_Toc405794703"><A NAME="_Toc410109040">10.1.&#9;Function return values</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The Cryptoki interface possesses a large number of functions and return values.  In Section 10.1, we enumerate the various possible return values for Cryptoki functions; most of the remainder of Section 10 details the behavior of Cryptoki functions, including what values each of them may return.</P>
<P ALIGN="JUSTIFY">Because of the complexity of the Cryptoki specification, it is recommended that Cryptoki applications attempt to give some leeway when interpreting Cryptoki functions’ return values.  We have attempted to specify the behavior of Cryptoki functions as completely as was feasible; nevertheless, there are presumably some gaps.  For example, it is possible that a particular error code which might apply to a particular Cryptoki function is unfortunately not actually listed in the description of that function as a possible error code.  It is conceivable that the developer of a Cryptoki library might nevertheless permit his/her implementation of that function to return that error code.  It would clearly be somewhat ungraceful if a Cryptoki application using that library were to terminate by abruptly dumping core upon receiving that error code for that function.  It would be far preferable for the application to examine the function’s return value, see that it indicates some sort of error (even if the application doesn’t know precisely <I>what</I> kind of error), and behave accordingly.</P>
<P ALIGN="JUSTIFY">See Section 10.1.8 for some specific details on how a developer might attempt to make an application that accommodates a range of behaviors from Cryptoki libraries.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384823451"><A NAME="_Toc385057887"><A NAME="_Toc405794704"><A NAME="_Toc410109041"><A NAME="_Toc319313511"><A NAME="_Toc319313704"><A NAME="_Toc319315697"><A NAME="_Toc322855298"><A NAME="_Toc322945140"><A NAME="_Toc323000707"><A NAME="_Toc323024101"><A NAME="_Toc323205433"><A NAME="_Toc323610863"><A NAME="_Toc383864870">10.1.1.&#9;Universal Cryptoki function return values</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Any Cryptoki function can return any of the following values:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_GENERAL_ERROR: Some horrible, unrecoverable error has occurred.  In the worst case, it is possible that the function only partially succeeded, and that the computer and/or token is in an inconsistent state.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_HOST_MEMORY: The computer that the Cryptoki library is running on has insufficient memory to perform the requested function.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_FUNCTION_FAILED: The requested function could not be performed, but detailed information about why not is not available in this error return.  If the failed function uses a session, it is possible that the <B>CK_SESSION_INFO</B> structure that can be obtained by calling <B>C_GetSessionInfo</B> will hold useful information about what happened in its <I>ulDeviceError</I> field.  In any event, although the function call failed, the situation is not necessarily totally hopeless, as it is likely to be when CKR_GENERAL_ERROR is returned.  Depending on what the root cause of the error actually was, it is possible that an attempt to make the exact same function call again would succeed.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_OK: The function executed successfully.  Technically, CKR_OK is not <I>quite</I> a &quot;universal&quot; return value; in particular, the legacy functions <B>C_GetFunctionStatus</B> and <B>C_CancelFunction</B> (see Section 10.16) cannot return CKR_OK.</LI></P></UL>

<P ALIGN="JUSTIFY">The relative priorities of these errors are in the order listed above, <I>e.g.</I>, if either of CKR_GENERAL_ERROR or CKR_HOST_MEMORY would be an appropriate error return, then CKR_GENERAL_ERROR should be returned.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384823481"><A NAME="_Toc385057888"><A NAME="_Toc405794705"><A NAME="_Toc410109042">10.1.2.&#9;Cryptoki function return values for functions that use a session handle</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Any Cryptoki function that takes a session handle as one of its arguments (<I>i.e.</I>, any Cryptoki function except for <B>C_Initialize</B>, <B>C_Finalize</B>, <B>C_GetInfo</B>, <B>C_GetFunctionList</B>, <B>C_GetSlotList</B>, <B>C_GetSlotInfo</B>, <B>C_GetTokenInfo</B>, <B>C_WaitForSlotEvent</B>, <B>C_GetMechanismList</B>, <B>C_GetMechanismInfo</B>, <B>C_InitToken</B>, <B>C_OpenSession</B>, and <B>C_CloseAllSessions</B>) can return the following values:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_HANDLE_INVALID: The specified session handle was invalid <I>at the time that the function was invoked</I>.  Note that this can happen if the session’s token is removed before the function invocation, since removing a token closes all sessions with it.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_DEVICE_REMOVED: The token was removed from its slot <I>during the execution of the function</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_CLOSED: The session was closed <I>during the execution of the function</I>.  Note that, as stated in Section 5.6.6, the behavior of Cryptoki is <I>undefined</I> if multiple threads of an application attempt to access a common Cryptoki session simultaneously.  Therefore, there is actually no guarantee that a function invocation could ever return the value CKR_SESSION_CLOSED—if one thread is using a session when another thread closes that session, that is an instance of multiple threads accessing a common session simultaneously.</LI></P></UL>

<P ALIGN="JUSTIFY">The relative priorities of these errors are in the order listed above, <I>e.g.</I>, if either of CKR_SESSION_HANDLE_INVALID or CKR_DEVICE_REMOVED would be an appropriate error return, then CKR_SESSION_HANDLE_INVALID should be returned.</P>
<P ALIGN="JUSTIFY">In practice, it is often not crucial (or possible) for a Cryptoki library to be able to make a distinction between a token being removed <I>before</I> a function invocation and a token being removed <I>during</I> a function execution.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384823523"><A NAME="_Toc385057889"><A NAME="_Toc405794706"><A NAME="_Toc410109043">10.1.3.&#9;Cryptoki function return values for functions that use a token</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Any Cryptoki function that uses a particular token (<I>i.e.</I>, any Cryptoki function except for <B>C_Initialize</B>, <B>C_Finalize</B>, <B>C_GetInfo</B>, <B>C_GetFunctionList</B>, <B>C_GetSlotList</B>, <B>C_GetSlotInfo</B>, or<B> C_WaitForSlotEvent</B>) can return any of the following values:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_DEVICE_MEMORY: The token does not have sufficient memory to perform the requested function.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_DEVICE_ERROR: Some problem has occurred with the token and/or slot.  This error code can be returned by more than just the functions mentioned above; in particular, it is possible for <B>C_GetSlotInfo</B> to return CKR_DEVICE_ERROR.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_TOKEN_NOT_PRESENT: The token was not present in its slot <I>at the time that the function was invoked</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_DEVICE_REMOVED: The token was removed from its slot <I>during the execution of the function</I>.</LI></P></UL>

<P ALIGN="JUSTIFY">The relative priorities of these errors are in the order listed above, <I>e.g.</I>, if either of CKR_DEVICE_MEMORY or CKR_DEVICE_ERROR would be an appropriate error return, then CKR_DEVICE_MEMORY should be returned.</P>
<P ALIGN="JUSTIFY">In practice, it is often not critical (or possible) for a Cryptoki library to be able to make a distinction between a token being removed <I>before</I> a function invocation and a token being removed <I>during</I> a function execution.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794707"><A NAME="_Toc410109044"><A NAME="_Toc385057890"><A NAME="_Ref385060159">10.1.4.&#9;Special return value for application-supplied callbacks</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">There is a special-purpose return value which is not returned by any function in the actual Cryptoki API, but which may be returned by an application-supplied callback function.  It is:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_CANCEL: When a function executing in serial with an application decides to give the application a chance to do some work, it calls an application-supplied function with a CKN_SURRENDER callback (see Section 10.17).  If the callback returns the value CKR_CANCEL, then the function aborts and returns CKR_FUNCTION_CANCELED.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794708"><A NAME="_Toc410109045">10.1.5.&#9;Special return values for mutex-handling functions</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">There are two other special-purpose return values which are not returned by any actual Cryptoki functions.  These values may be returned by application-supplied mutex-handling functions, and they may safely be ignored by application developers who are not using their own threading model.  They are:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_MUTEX_BAD: This error code can be returned by mutex-handling functions who are passed a bad mutex object as an argument.  Unfortunately, it is possible for such a function not to recognize a bad mutex object.  There is therefore no guarantee that such a function will successfully detect bad mutex objects and return this value.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_MUTEX_NOT_LOCKED: This error code can be returned by mutex-unlocking functions.  It indicates that the mutex supplied to the mutex-unlocking function was not locked.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref395516454"><A NAME="_Toc405794709"><A NAME="_Toc410109046">10.1.6.&#9;All other Cryptoki function return values</A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Descriptions of the other Cryptoki function return values follow.  Except as mentioned in the descriptions of particular error codes, there are in general no particular priorities among the errors listed below, <I>i.e.</I>, if more than one error code might apply to an execution of a function, then the function may return any applicable error code.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>CKR_ARGUMENTS_BAD: This is a rather generic error code which indicates that the arguments supplied to the Cryptoki function were in some way not appropriate.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ATTRIBUTE_READ_ONLY: An attempt was made to set a value for an attribute which may not be set by the application, or which may not be modified by the application.  See Section 9.1 for more information.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ATTRIBUTE_SENSITIVE: An attempt was made to obtain the value of an attribute of an object which cannot be satisfied because the object is either sensitive or unextractable.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ATTRIBUTE_TYPE_INVALID: An invalid attribute type was specified in a template.  See Section 9.1 for more information.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ATTRIBUTE_VALUE_INVALID: An invalid value was specified for a particular attribute in a template.  See Section 9.1 for more information.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_BUFFER_TOO_SMALL: The output of the function is too large to fit in the supplied buffer.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_CANT_LOCK: This value can only be returned by <B>C_Initialize</B>.  It means that the type of locking requested by the application for thread-safety is not available in this library, and so the application cannot make use of this library in the specified fashion.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_CRYPTOKI_ALREADY_INITIALIZED: This value can only be returned by <B>C_Initialize</B>.  It means that the Cryptoki library has already been initialized (by a previous call to <B>C_Initialize</B> which did not have a matching <B>C_Finalize</B> call).</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_CRYPTOKI_NOT_INITIALIZED: This value can be returned by any function other than <B>C_Initialize</B> and <B>C_GetFunctionList</B>.  It indicates that the function cannot be executed because the Cryptoki library has not yet been initialized by a call to <B>C_Initialize</B>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_DATA_INVALID: The plaintext input data to a cryptographic operation is invalid.  At present, this error only applies to the <B>CKM_RSA_X_509</B> mechanism; it is returned when plaintext is supplied that has the same number of bytes as the RSA modulus and is numerically at least as large as the modulus.  This return value has lower priority than CKR_DATA_LEN_RANGE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_DATA_LEN_RANGE: The plaintext input data to a cryptographic operation has a bad length.  Depending on the operation’s mechanism, this could mean that the plaintext data is too short, too long, or is not a multiple of some particular blocksize.  This return value has higher priority than CKR_DATA_INVALID.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ENCRYPTED_DATA_INVALID: The encrypted input to a decryption operation has been determined to be invalid ciphertext.  This return value has lower priority than CKR_ENCRYPTED_DATA_LEN_RANGE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_ENCRYPTED_DATA_LEN_RANGE: The ciphertext input to a decryption operation has been determined to be invalid ciphertext solely on the basis of its length.  Depending on the operation’s mechanism, this could mean that the ciphertext is too short, too long, or is not a multiple of some particular blocksize.  This return value has higher priority than CKR_ENCRYPTED_DATA_INVALID.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_FUNCTION_CANCELED: The function was canceled in mid-execution.  This happens to a cryptographic function if the function makes a <B>CKN_SURRENDER</B> application callback which returns CKR_CANCEL (see CKR_CANCEL).</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_FUNCTION_NOT_PARALLEL: There is currently no function executing in parallel in the specified session.  This is a legacy error code which is only returned by the legacy functions <B>C_GetFunctionStatus</B> and <B>C_CancelFunction</B>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_FUNCTION_NOT_SUPPORTED: The requested function is not supported by this Cryptoki library.  Even unsupported functions in the Cryptoki API should have a &quot;stub&quot; in the library; this stub should simply return the value CKR_FUNCTION_NOT_SUPPORTED.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_INFORMATION_SENSITIVE: The information requested could not be obtained because the token considers it sensitive, and is not able or willing to reveal it.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_CHANGED: This value is only returned by <B>C_SetOperationState</B>.  It indicates that one of the keys specified is not the same key that was being used in the original saved session.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_FUNCTION_NOT_PERMITTED: An attempt has been made to use a key for a cryptographic purpose that the key’s attributes are not set to allow it to do.  For example, to use a key for performing encryption, that key must have its <B>CKA_ENCRYPT</B> attribute set to TRUE (the fact that the key must have a <B>CKA_ENCRYPT</B> attribute implies that the key cannot be a private key).  This return value has lower priority than CKR_KEY_TYPE_INCONSISTENT.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_HANDLE_INVALID: The specified key handle is not valid.  It may be the case that the specified handle is a valid handle for an object which is not a key.  We reiterate here that 0 is never a valid key handle.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_INDIGESTIBLE: This error code can only be returned by <B>C_DigestKey</B>.  It indicates that the value of the specified key cannot be digested for some reason (perhaps the key isn’t a secret key, or perhaps the token simply can’t digest this kind of key).</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_NEEDED: This value is only returned by <B>C_SetOperationState</B>.  It indicates that the session state cannot be restored because <B>C_SetOperationState</B> needs to be supplied with one or more keys that were being used in the original saved session.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_NOT_NEEDED: An extraneous key was supplied to <B>C_SetOperationState</B>.  For example, an attempt was made to restore a session that had been performing a message digesting operation, and an encryption key was supplied.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_NOT_WRAPPABLE: Although the specified private or secret key does not have its CKA_UNEXTRACTABLE attribute set to TRUE, Cryptoki (or the token) is unable to wrap the key as requested (possibly the token can only wrap a given key with certain types of keys, and the wrapping key specified is not one of these types).  Compare with CKR_KEY_UNEXTRACTABLE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_SIZE_RANGE: Although the requested keyed cryptographic operation could in principle be carried out, this Cryptoki library (or the token) is unable to actually do it because the supplied key‘s size is outside the range of key sizes that it can handle.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_TYPE_INCONSISTENT: The specified key is not the correct type of key to use with the specified mechanism.  This return value has a higher priority than CKR_KEY_FUNCTION_NOT_PERMITTED.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_KEY_UNEXTRACTABLE: The specified private or secret key can’t be wrapped because its CKA_UNEXTRACTABLE attribute is set to TRUE.  Compare with CKR_KEY_NOT_WRAPPABLE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_MECHANISM_INVALID: An invalid mechanism was specified to the cryptographic operation.  This error code is an appropriate return value if an unknown mechanism was specified or if the mechanism specified cannot be used in the selected token with the selected function.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_MECHANISM_PARAM_INVALID: Invalid parameters were supplied to the mechanism specified to the cryptographic operation.  Which parameter values are supported by a given mechanism can vary from token to token.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_NEED_TO_CREATE_THREADS: This value can only be returned by <B>C_Initialize</B>.  It is returned when two conditions hold:</LI></P></UL>

<OL>

<OL>

<P ALIGN="JUSTIFY"><LI>The application called <B>C_Initialize</B> in a way which tells the Cryptoki library that application threads executing calls to the library cannot use native operating system methods to spawn new threads.</LI></P>
<P ALIGN="JUSTIFY"><LI>The library cannot function properly without being able to spawn new threads in the above fashion.</LI></P></OL>
</OL>


<UL>
<P ALIGN="JUSTIFY"><LI>CKR_NO_EVENT: This value can only be returned by <B>C_GetSlotEvent</B>.  It is returned when <B>C_GetSlotEvent</B> is called in non-blocking mode and there are no new slot events to return.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_OBJECT_HANDLE_INVALID: The specified object handle is not valid.  We reiterate here that 0 is never a valid object handle.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_OPERATION_ACTIVE: There is already an active operation (or combination of active operations) which prevents Cryptoki from activating the specified operation.  For example, an active object-searching operation would prevent Cryptoki from activating an encryption operation with <B>C_EncryptInit</B>.  Or, an active digesting operation and an active encryption operation would prevent Cryptoki from activating a signature operation.  Or, on a token which doesn’t support simultaneous dual cryptographic operations in a session (see the description of the <B>CKF_DUAL_CRYPTO_OPERATIONS</B> flag in the <B>CK_TOKEN_INFO</B> structure), an active signature operation would prevent Cryptoki from activating an encryption operation.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_OPERATION_NOT_INITIALIZED: There is no active operation of an appropriate type in the specified session.  For example, an application cannot call <B>C_Encrypt</B> in a session without having called <B>C_EncryptInit</B> first to activate an encryption operation.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_PIN_EXPIRED: The specified PIN has expired, and cannot be used to authenticate the user to the token.  Whether or not the normal user’s PIN on a token ever expires varies from token to token.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_PIN_INCORRECT: The specified PIN is incorrect, <I>i.e.</I>, does not match the PIN stored on the token.  More generally-- when authentication to the token involves something other than a PIN-- the attempt to authenticate the user has failed.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_PIN_INVALID: The specified PIN has invalid characters in it.  This return code only applies to functions which attempt to set a PIN.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_PIN_LEN_RANGE: The specified PIN is too long or too short.  This return code only applies to functions which attempt to set a PIN.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_PIN_LOCKED: The specified PIN is &quot;locked&quot;, and cannot be used.  That is, because some particular number of failed authentication attempts has been reached, the token is unwilling to permit further attempts at authentication.  Depending on the token, the specified PIN may or may not remain locked indefinitely.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_RANDOM_NO_RNG: This value can be returned by <B>C_SeedRandom</B> and <B>C_GenerateRandom</B>.  It indicates that the specified token doesn’t have a random number generator.  This return value has higher priority than CKR_RANDOM_SEED_NOT_SUPPORTED.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_RANDOM_SEED_NOT_SUPPORTED: This value can only be returned by <B>C_SeedRandom</B>.  It indicates that the token’s random number generator does not accept seeding from an application.  This return value has lower priority than CKR_RANDOM_NO_RNG.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SAVED_STATE_INVALID: This value can only be returned by <B>C_SetOperationState</B>.  It indicates that the supplied saved cryptographic operations state is invalid, and so it cannot be restored to the specified session.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_COUNT: This value can only be returned by <B>C_OpenSession</B>.  It indicates that the attempt to open a session failed, either because the token has too many sessions already open, or because the token has too many read/write sessions already open.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_EXISTS: This value can only be returned by <B>C_InitToken</B>.  It indicates that a session with the token is already open, and so the token cannot be initialized.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_PARALLEL_NOT_SUPPORTED: The specified token does not support parallel sessions.  This is a legacy error code—in Cryptoki Version 2.01, <I>no</I> token supports parallel sessions.  CKR_SESSION_PARALLEL_NOT_SUPPORTED can only be returned by <B>C_OpenSession</B>, and it is only returned when <B>C_OpenSession</B> is called in a particular [deprecated] way.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_READ_ONLY: The specified session was unable to accomplish the desired action because it is a read-only session.  This return value has lower priority than CKR_TOKEN_WRITE_PROTECTED.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_READ_ONLY_EXISTS: A read-only session already exists, and so the SO cannot be logged in.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SESSION_READ_WRITE_SO_EXISTS: A read/write SO session already exists, and so a read-only session cannot be opened.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SIGNATURE_LEN_RANGE: The provided signature/MAC can be seen to be invalid solely on the basis of its length.  This return value has higher priority than CKR_SIGNATURE_INVALID.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SIGNATURE_INVALID: The provided signature/MAC is invalid.  This return value has lower priority than CKR_SIGNATURE_LEN_RANGE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_SLOT_ID_INVALID: The specified slot ID is not valid.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_STATE_UNSAVEABLE: The cryptographic operations state of the specified session cannot be saved for some reason (possibly the token is simply unable to save the current state).  This return value has lower priority than CKR_OPERATION_NOT_INITIALIZED.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_TEMPLATE_INCOMPLETE: The template specified for creating an object is incomplete, and lacks some necessary attributes.  See Section 9.1 for more information.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_TEMPLATE_INCONSISTENT: The template specified for creating an object has conflicting attributes.  See Section 9.1 for more information.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_TOKEN_NOT_RECOGNIZED: The Cryptoki library and/or slot does not recognize the token in the slot.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_TOKEN_WRITE_PROTECTED: The requested action could not be performed because the token is write-protected.  This return value has higher priority than CKR_SESSION_READ_ONLY.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_UNWRAPPING_KEY_HANDLE_INVALID: This value can only be returned by <B>C_UnwrapKey</B>.  It indicates that the key handle specified to be used to unwrap another key is not valid.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_UNWRAPPING_KEY_SIZE_RANGE: This value can only be returned by <B>C_UnwrapKey</B>.  It indicates that although the requested unwrapping operation could in principle be carried out, this Cryptoki library (or the token) is unable to actually do it because the supplied key’s size is outside the range of key sizes that it can handle.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT: This value can only be returned by <B>C_UnwrapKey</B>.  It indicates that the type of the key specified to unwrap another key is not consistent with the mechanism specified for unwrapping.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_ALREADY_LOGGED_IN: This value can only be returned by <B>C_Login</B>.  It indicates that the specified user cannot be logged into the session, because it is already logged into the session.  For example, if an application has an open SO session, and it attempts to log the SO into it, it will receive this error code.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_ANOTHER_ALREADY_LOGGED_IN: This value can only be returned by <B>C_Login</B>.  It indicates that the specified user cannot be logged into the session, because another user is already logged into the session.  For example, if an application has an open SO session, and it attempts to log the normal user into it, it will receive this error code.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_NOT_LOGGED_IN: The desired action cannot be performed because the appropriate user (or <I>an</I> appropriate user) is not logged in.  One example is that a session cannot be logged out unless it is logged in.  Another example is that a private object cannot be created on a token unless the session attempting to create it is logged in as the normal user.  A final example is that cryptographic operations on certain tokens cannot be performed unless the normal user is logged in.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_PIN_NOT_INITIALIZED: This value can only be returned by <B>C_Login</B>.  It indicates that the normal user’s PIN has not yet been initialized with <B>C_InitPIN</B>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_TOO_MANY_TYPES: An attempt was made to have more distinct users simultaneously logged into the token than the token and/or library permits.  For example, if some application has an open SO session, and another application attempts to log the normal user into a session, the attempt may return this error.  It is not required to, however.  Only if the simultaneous distinct users cannot be supported does <B>C_Login</B> have to return this value.  Note that this error code generalizes to true multi-user tokens.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_USER_TYPE_INVALID: An invalid value was specified as a <B>CK_USER_TYPE</B>.  Valid types are <B>CKU_SO</B> and <B>CKU_USER</B>.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_WRAPPED_KEY_INVALID: This value can only be returned by <B>C_UnwrapKey</B>.  It indicates that the provided wrapped key is not valid.  If a call is made to <B>C_UnwrapKey</B> to unwrap a particular type of key (<I>i.e.</I>, some particular key type is specified in the template provided to <B>C_UnwrapKey</B>), and the wrapped key provided to <B>C_UnwrapKey</B> is recognizably not a wrapped key of the proper type, then <B>C_UnwrapKey</B> should return CKR_WRAPPED_KEY_INVALID.  This return value has lower priority than CKR_WRAPPED_KEY_LEN_RANGE.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_WRAPPED_KEY_LEN_RANGE: This value can only be returned by <B>C_UnwrapKey</B>.  It indicates that the provided wrapped key can be seen to be invalid solely on the basis of its length.  This return value has higher priority than CKR_WRAPPED_KEY_INVALID.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_WRAPPING_KEY_HANDLE_INVALID: This value can only be returned by <B>C_WrapKey</B>.  It indicates that the key handle specified to be used to wrap another key is not valid.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_WRAPPING_KEY_SIZE_RANGE: This value can only be returned by <B>C_WrapKey</B>.  It indicates that although the requested wrapping operation could in principle be carried out, this Cryptoki library (or the token) is unable to actually do it because the supplied wrapping key’s size is outside the range of key sizes that it can handle.</LI></P>
<P ALIGN="JUSTIFY"><LI>CKR_WRAPPING_KEY_TYPE_INCONSISTENT: This value can only be returned by <B>C_WrapKey</B>.  It indicates that the type of the key specified to wrap another key is not consistent with the mechanism specified for wrapping.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057891"><A NAME="_Toc405794710"><A NAME="_Toc410109047">10.1.7.&#9;More on relative priorities of Cryptoki errors</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In general, when a Cryptoki call is made, error codes from Section 10.1.1 (other than CKR_OK) take precedence over error codes from Section 10.1.2, which take precedence over error codes from Section 10.1.3, which take precedence over error codes from Section 10.1.6.  One minor implication of this is that functions that use a session handle (<I>i.e.</I>, <I>most</I> functions!) never return the error code CKR_TOKEN_NOT_PRESENT (they return CKR_SESSION_HANDLE_INVALID instead).  Other than these precedences, if more than one error code applies to the result of a Cryptoki call, any of the applicable error codes may be returned.  Exceptions to this rule will be explicitly mentioned in the descriptions of functions.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref406906262"><A NAME="_Toc410109048">10.1.8.&#9;Error code &quot;gotchas&quot;</A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Here is a short list of a few particular things about return values that Cryptoki developers might want to be aware of:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>As mentioned in Sections 10.1.2 and 10.1.3, a Cryptoki library may not be able to make a distinction between a token being removed <I>before</I> a function invocation and a token being removed <I>during</I> a function invocation.</LI></P>
<P ALIGN="JUSTIFY"><LI>As mentioned in Section 10.1.2, an application should never count on getting a CKR_SESSION_CLOSED error.</LI></P>
<P ALIGN="JUSTIFY"><LI>The difference between CKR_DATA_INVALID and CKR_DATA_LEN_RANGE can be somewhat subtle.  Unless an application <I>needs</I> to be able to distinguish between these return values, it is best to always treat them equivalently.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the difference between CKR_ENCRYPTED_DATA_INVALID and CKR_ENCRYPTED_DATA_LEN_RANGE, and between CKR_WRAPPED_KEY_INVALID and CKR_WRAPPED_KEY_LEN_RANGE, can be subtle, and it may be best to treat these return values equivalently.</LI></P>
<P ALIGN="JUSTIFY"><LI>Even with the guidance of Section 9.1, it can be difficult for a Cryptoki library developer to know which of CKR_ATTRIBUTE_VALUE_INVALID, CKR_TEMPLATE_INCOMPLETE, or CKR_TEMPLATE_INCONSISTENT to return.  When possible, it is recommended that application developers be generous in their interpretations of these error codes.</LI></P></OL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384895442"><A NAME="_Ref384959982"><A NAME="_Toc385057892"><A NAME="_Toc405794711"><A NAME="_Toc410109049"><A NAME="_Ref384632513">10.2.&#9;Conventions for functions returning </A>output in a variable-length buffer</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A number of the functions defined in Cryptoki return output produced by some cryptographic mechanism.  The amount of output returned by these functions is returned in a variable-length application-supplied buffer.  An example of a function of this sort is <B>C_Encrypt</B>, which takes some plaintext as an argument, and outputs a buffer full of ciphertext.</P>
<P ALIGN="JUSTIFY">These functions have some common calling conventions, which we describe here.  Two of the arguments to the function are a pointer to the output buffer (say <I>pBuf</I>) and a pointer to a location which will hold the length of the output produced (say <I>pulBufLen</I>).  There are two ways for an application to call such a function:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If <I>pBuf</I> is NULL_PTR, then all that the function does is return (in *<I>pulBufLen</I>) a number of bytes which would suffice to hold the cryptographic output produced from the input to the function.  This number may somewhat exceed the precise number of bytes needed, but should not exceed it by a large amount.  CKR_OK is returned by the function.</LI></P>
<P ALIGN="JUSTIFY"><LI>If <I>pBuf</I> is not NULL_PTR, then *<I>pulBufLen</I> must contain the size in bytes of the buffer pointed to by <I>pBuf</I>.  If that buffer is large enough to hold the cryptographic output produced from the input to the function, then that cryptographic output is placed there, and CKR_OK is returned by the function.  If the buffer is not large enough, then CKR_BUFFER_TOO_SMALL is returned.  In either case, *<I>pulBufLen</I> is set to hold the <I>exact</I> number of bytes needed to hold the cryptographic output produced from the input to the function.</LI></P></OL>

<P ALIGN="JUSTIFY">All functions which use the above convention will explicitly say so.</P>
<P ALIGN="JUSTIFY">Cryptographic functions which return output in a variable-length buffer should always return as much output as can be computed from what has been passed in to them thus far.  As an example, consider a session which is performing a multiple-part decryption operation with DES in cipher-block chaining mode with PKCS padding.  Suppose that, initially, 8 bytes of ciphertext are passed to the <B>C_DecryptUpdate</B> function.  The blocksize of DES is 8 bytes, but the PKCS padding makes it unclear at this stage whether the ciphertext was produced from encrypting a 0-byte string, or from encrypting some string of length at least 8 bytes.  Hence the call to <B>C_DecryptUpdate</B> should return 0 bytes of plaintext.  If a single additional byte of ciphertext is supplied by a subsequent call to <B>C_DecryptUpdate</B>, then that call should return 8 bytes of plaintext (one full DES block).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057893"><A NAME="_Toc405794712"><A NAME="_Toc410109050">10.3.&#9;Disclaimer concerning sample code</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For the remainder of Section 10, we enumerate the various functions defined in Cryptoki.  Most functions will be shown in use in at least one sample code snippet.  For the sake of brevity, sample code will frequently be somewhat incomplete.  In particular, sample code will generally ignore possible error returns from C library functions, and also will not deal with Cryptoki error returns in a realistic fashion.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057894"><A NAME="_Ref394217698"><A NAME="_Ref394217726"><A NAME="_Toc405794713"><A NAME="_Toc410109051">10.4.&#9;General-purpose</A></A></A></A></A></A></A></A></A></A> functions</A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following general-purpose functions:</P>

<UL>
<LI><A NAME="_Toc323024102"><A NAME="_Toc323205434"><A NAME="_Toc323610864"><A NAME="_Toc383864871"><A NAME="_Toc385057895"><A NAME="_Toc405794714"><A NAME="_Toc410109052"></FONT><B><FONT FACE="Palatino">C_Initialize</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Initialize)(<BR>
  CK_VOID_PTR pInitArgs<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Initialize</FONT></B> initializes the Cryptoki library.  <I>pInitArgs</I> either has the value NULL_PTR or points to a <B>CK_C_INITIALIZE_ARGS</B> structure containing information on how the library should deal with multi-threaded access.  If an application will not be accessing Cryptoki through multiple threads simultaneously, it can generally supply the value NULL_PTR to <B>C_Initialize</B> (the consequences of supplying this value will be explained below).</P>
<P ALIGN="JUSTIFY">If <I>pInitArgs</I> is non-NULL_PTR, <B>C_Initialize</B> should cast it to a <B>CK_C_INITIALIZE_ARGS_PTR</B> and then dereference the resulting pointer to obtain the <B>CK_C_INITIALIZE_ARGS</B> fields <I>CreateMutex</I>, <I>DestroyMutex</I>, <I>LockMutex</I>, <I>UnlockMutex</I>, <I>flags</I>, and <I>pReserved</I>.  For this version of Cryptoki, the value of <I>pReserved</I> thereby obtained must be NULL_PTR; if it’s not, then <B>C_Initialize</B> should return with the value CKR_ARGUMENTS_BAD.</P>
<P ALIGN="JUSTIFY">If the <B>CKF_LIBRARY_CANT_CREATE_OS_THREADS</B> flag in the <I>flags</I> field is set, that indicates that application threads which are executing calls to the Cryptoki library are not permitted to use the native operation system calls to spawn off new threads.  In other words, the library’s code may not create its own threads.  If the library is unable to function properly under this restriction, <B>C_Initialize</B> should return with the value CKR_NEED_TO_CREATE_THREADS.</P>
<P ALIGN="JUSTIFY">A call to <B>C_Initialize</B> specifies one of four different ways to support multi-threaded access via the value of the <B>CKF_OS_LOCKING_OK</B> flag in the <I>flags</I> field and the values of the <I>CreateMutex</I>, <I>DestroyMutex</I>, <I>LockMutex</I>, and <I>UnlockMutex</I> function pointer fields:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If the flag <I>isn’t</I> set, and the function pointer fields <I>aren’t</I> supplied (<I>i.e.</I>, they all have the value NULL_PTR), that means that the application <I>won’t</I> be accessing the Cryptoki library from multiple threads simultaneously.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the flag <I>is</I> set, and the function pointer fields <I>aren’t</I> supplied (<I>i.e.</I>, they all have the value NULL_PTR), that means that the application <I>will</I> be performing multi-threaded Cryptoki access, and the library needs to use the native operating system primitives to ensure safe multi-threaded access.  If the library is unable to do this, <B>C_Initialize</B> should return with the value CKR_CANT_LOCK.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the flag <I>isn’t</I> set, and the function pointer fields <I>are</I> supplied (<I>i.e.</I>, they all have non-NULL_PTR values), that means that the application <I>will</I> be performing multi-threaded Cryptoki access, and the library needs to use the supplied function pointers for mutex-handling to ensure safe multi-threaded access.  If the library is unable to do this, <B>C_Initialize</B> should return with the value CKR_CANT_LOCK.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the flag <I>is</I> set, and the function pointer fields <I>are</I> supplied (<I>i.e.</I>, they all have non-NULL_PTR values), that means that the application <I>will</I> be performing multi-threaded Cryptoki access, and the library needs to use either the native operating system primitives or the supplied function pointers for mutex-handling to ensure safe multi-threaded access.  If the library is unable to do this, <B>C_Initialize</B> should return with the value CKR_CANT_LOCK.</LI></P></OL>

<P ALIGN="JUSTIFY">If some, but not all, of the supplied function pointers to <B>C_Initialize</B> are non-NULL_PTR, then <B>C_Initialize</B> should return with the value CKR_ARGUMENTS_BAD.</P>
<P ALIGN="JUSTIFY">A call to <B>C_Initialize</B> with <I>pInitArgs</I> set to NULL_PTR is treated like a call to <B>C_Initialize</B> with <I>pInitArgs</I> pointing to a <B>CK_C_INITIALIZE_ARGS</B> which has the <I>CreateMutex</I>, <I>DestroyMutex</I>, <I>LockMutex</I>, <I>UnlockMutex</I>, and <I>pReserved</I> fields set to NULL_PTR, and has the <I>flags</I> field set to 0.</P>
<B><P ALIGN="JUSTIFY">C_Initialize</B> should be the first Cryptoki call made by an application, except for calls to <B>C_GetFunctionList</B>.  What this function actually does is implementation-dependent; typically, it might cause Cryptoki to initialize its internal memory buffers, or any other resources it requires.</P>
<P ALIGN="JUSTIFY">If several applications are using Cryptoki, each one should call <B>C_Initialize</B>.  Every call to <B>C_Initialize</B> should (eventually) be succeeded by a single call to <B>C_Finalize</B>.  See Section 5.5 for more details.</P>
<P>Return values: CKR_ARGUMENTS_BAD, CKR_CANT_LOCK, CKR_CRYPTOKI_ALREADY_INITIALIZED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_NEED_TO_CREATE_THREADS, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_GetInfo</B>.</P>

<UL>
<LI><A NAME="_Toc385057896"><A NAME="_Toc405794715"><A NAME="_Toc410109053"><A NAME="_Toc323024103"><A NAME="_Toc323205435"><A NAME="_Toc323610865"><A NAME="_Toc383864872"></FONT><B><FONT FACE="Palatino">C_Finalize</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Finalize)(<BR>
  CK_VOID_PTR pReserved<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Finalize</B> is called to indicate that an application is finished with the Cryptoki library.  It should be the last Cryptoki call made by an application.  The <I>pReserved</I> parameter is reserved for future versions; for this version, it should be set to NULL_PTR (if <B>C_Finalize</B> is called with a non-NULL_PTR value for <I>pReserved</I>, it should return the value CKR_ARGUMENTS_BAD.</P>
<P ALIGN="JUSTIFY">If several applications are using Cryptoki, each one should call <B>C_Finalize</B>.  Each application’s call to <B>C_Finalize</B> should be preceded by a single call to <B>C_Initialize</B>; in between the two calls, an application can make calls to other Cryptoki functions.  See Section 5.5 for more details.</P>
<I><P ALIGN="JUSTIFY">Despite the fact that the parameters supplied to <B>C_Initialize</B> can in general allow for safe multi-threaded access to a Cryptoki library, the behavior of <B>C_Finalize</B> is nevertheless undefined if it is called by an application while other threads of the application are making Cryptoki calls.  The exception to this exceptional behavior of <B>C_Finalize</B> occurs when a thread calls <B>C_Finalize</B> while another of the application’s threads is blocking on Cryptoki’s <B>C_WaitForSlotEvent</B> function.  When this happens, the blocked thread becomes unblocked and returns the value CKR_CRYPTOKI_NOT_INITIALIZED.  See <B>C_WaitForSlotEvent</B> for more information.</P>
</I><P>Return values: CKR_ARGUMENTS_BAD, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_GetInfo</B>.</P>

<UL>
<LI><A NAME="_Toc385057897"><A NAME="_Toc405794716"><A NAME="_Toc410109054"></FONT><B><FONT FACE="Palatino">C_GetInfo</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetInfo)(<BR>
  CK_INFO_PTR pInfo<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetInfo</B> returns general information about Cryptoki.  <I>pInfo</I> points to the location that receives the information.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_INFO info;</P>
<P>CK_RV rv;</P>
<P>CK_C_INITIALIZE_ARGS InitArgs;</P>

<P>InitArgs.CreateMutex = &amp;MyCreateMutex;</P>
<P>InitArgs.DestroyMutex = &amp;MyDestroyMutex;</P>
<P>InitArgs.LockMutex = &amp;MyLockMutex;</P>
<P>InitArgs.UnlockMutex = &amp;MyUnlockMutex;</P>
<P>InitArgs.flags = CKF_OS_LOCKING_OK;</P>
<P>InitArgs.pReserved = NULL_PTR;</P>

<P>rv = C_Initialize((CK_VOID_PTR)&amp;InitArgs);</P>
<P>assert(rv == CKR_OK);</P>

<P>rv = C_GetInfo(&amp;info);</P>
<P>assert(rv == CKR_OK);</P>
<P>if(info.version.major == 2) {</P>
<P>  /* Do lots of interesting cryptographic things with the token */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>rv = C_Finalize(NULL_PTR);</P>
<P>assert(rv == CKR_OK);</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057898"><A NAME="_Toc405794717"><A NAME="_Toc410109055"><A NAME="_Toc319287671"><A NAME="_Toc319313512"><A NAME="_Toc319313705"><A NAME="_Toc319315698"><A NAME="_Toc322855299"><A NAME="_Toc322945141"><A NAME="_Toc323000708"><A NAME="_Toc323024104"><A NAME="_Toc323205436"><A NAME="_Toc323610866"><A NAME="_Toc383864873"></FONT><B><FONT FACE="Palatino">C_GetFunctionList</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetFunctionList)(<BR>
  CK_FUNCTION_LIST_PTR_PTR ppFunctionList<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetFunctionList</B> obtains a pointer to the Cryptoki library’s list of function pointers.  <I>ppFunctionList</I> points to a value which will receive a pointer to the library’s <B>CK_FUNCTION_LIST</B> structure, which in turn contains function pointers for all the Cryptoki API routines in the library.  <I>The pointer thus obtained may point into memory which is owned by the Cryptoki library, and which may or may not be writable</I>.  Whether or not this is the case, no attempt should be made to write to this memory.</P>
<B><P ALIGN="JUSTIFY">C_GetFunctionList</B> is the only Cryptoki function which an application may call before calling <B>C_Initialize</B>.  It is provided to make it easier and faster for applications to use shared Cryptoki libraries and to use more than one Cryptoki library simultaneously.</P>
<P ALIGN="JUSTIFY">Return values: CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_FUNCTION_LIST_PTR pFunctionList;</P>
<P>CK_C_Initialize pC_Initialize;</P>
<P>CK_RV rv;</P>

<P>/* It’s OK to call C_GetFunctionList before calling C_Initialize */</P>
<P>rv = C_GetFunctionList(&amp;pFunctionList);</P>
<P>assert(rv == CKR_OK);</P>
<P>pC_Initialize = pFunctionList -&gt; C_Initialize;</P>

<P>/* Call the C_Initialize function in the library */</P>
<P>rv = (*pC_Initialize)(NULL_PTR);</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057899"><A NAME="_Toc405794718"><A NAME="_Toc410109056">10.5.&#9;Slot and token management</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for slot and token management:</P>

<UL>
<LI><A NAME="_Toc323024105"><A NAME="_Toc323205437"><A NAME="_Toc323610867"><A NAME="_Toc383864874"><A NAME="_Toc385057900"><A NAME="_Toc405794719"><A NAME="_Toc410109057"></FONT><B><FONT FACE="Palatino">C_GetSlotList</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetSlotList)(<BR>
  CK_BBOOL tokenPresent,<BR>
  CK_SLOT_ID_PTR pSlotList,<BR>
  CK_ULONG_PTR pulCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetSlotList</B> is used to obtain a list of slots in the system. <I>tokenPresent</I> indicates whether the list obtained includes only those slots with a token present (TRUE), or all slots (FALSE); <I>pulCount</I> points to the location that receives the number of slots.</P>
<P ALIGN="JUSTIFY">There are two ways for an application to call <B>C_GetSlotList</B>:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If <I>pSlotList</I> is NULL_PTR, then all that <B>C_GetSlotList</B> does is return (in *<I>pulCount</I>) the number of slots, without actually returning a list of slots.  The contents of the buffer pointed to by <I>pulCount</I> on entry to <B>C_GetSlotList</B> has no meaning in this case, and the call returns the value CKR_OK.</LI></P>
<P ALIGN="JUSTIFY"><LI>If <I>pSlotList</I> is not NULL_PTR, then *<I>pulCount</I> must contain the size (in terms of <B>CK_SLOT_ID</B> elements) of the buffer pointed to by <I>pSlotList</I>.  If that buffer is large enough to hold the list of slots, then the list is returned in it, and CKR_OK is returned.  If not, then the call to <B>C_GetSlotList</B> returns the value CKR_BUFFER_TOO_SMALL.  In either case, the value *<I>pulCount</I> is set to hold the number of slots.</LI></P></OL>

<P ALIGN="JUSTIFY">Because <B>C_GetSlotList</B> does not allocate any space of its own, an application will often call <B>C_GetSlotList</B> twice (or sometimes even more times—if an application is trying to get a list of all slots with a token present, then the number of such slots can (unfortunately) change between when the application asks for how many such slots there are and when the application asks for the slots themselves).  However, multiple calls to <B>C_GetSlotList</B> are by no means <I>required</I>.</P>
<P ALIGN="JUSTIFY">All slots which <B>C_GetSlotList</B> reports must be able to be queried as valid slots by <B>C_GetSlotInfo</B>.  Furthermore, the set of slots accessible through a Cryptoki library is fixed at the time that <B>C_Initialize</B> is called.  If an application calls <B>C_Initialize</B> and <B>C_GetSlotList</B>, and then the user hooks up a new hardware device, that device cannot suddenly appear as a new slot if <B>C_GetSlotList</B> is called again.  To recognize the new device, <B>C_Initialize</B> needs to be called again (and to be able to call <B>C_Initialize</B> successfully<B>, C_Finalize</B> needs to be called first).  Even if <B>C_Initialize</B> is successfully called, it may or may not be the case that the new device will then be successfully recognized.  On some platforms, it may be necessary to restart the entire system.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_ULONG ulSlotCount, ulSlotWithTokenCount;</P>
<P>CK_SLOT_ID_PTR pSlotList, pSlotWithTokenList;</P>
<P>CK_RV rv;</P>

<P>/* Get list of all slots */</P>
<P>rv = C_GetSlotList(FALSE, NULL_PTR, &amp;ulSlotCount);</P>
<P>if (rv == CKR_OK) {</P>
<P>  pSlotList =</P>
<P>    (CK_SLOT_ID_PTR) malloc(ulSlotCount*sizeof(CK_SLOT_ID));</P>
<P>  rv = C_GetSlotList(FALSE, pSlotList, &amp;ulSlotCount);</P>
<P>  if (rv == CKR_OK) {</P>
<P>    /* Now use that list of all slots */</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>

<P>  free(pSlotList);</P>
<P>}</P>

<P>/* Get list of all slots with a token present */</P>
<P>pSlotWithTokenList = (CK_SLOT_ID_PTR) malloc(0);</P>
<P>ulSlotWithTokenCount = 0;</P>
<P>while (1) {</P>
<P>  rv = C_GetSlotList(</P>
<P>    TRUE, pSlotWithTokenList, ulSlotWithTokenCount);</P>
<P>  if (rv != CKR_BUFFER_TOO_SMALL)</P>
<P>    break;</P>
<P>  pSlotWithTokenList = realloc(</P>
<P>    pSlotWithTokenList,</P>
<P>    ulSlotWithTokenList*sizeof(CK_SLOT_ID));</P>
<P>}</P>

<P>if (rv == CKR_OK) {</P>
<P>  /* Now use that list of all slots with a token present */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>free(pSlotWithTokenList);</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024106"><A NAME="_Toc323205438"><A NAME="_Toc323610868"><A NAME="_Toc383864875"><A NAME="_Toc385057901"><A NAME="_Toc405794720"><A NAME="_Toc410109058"></FONT><B><FONT FACE="Palatino">C_GetSlotInfo</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetSlotInfo)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_SLOT_INFO_PTR pInfo<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetSlotInfo</B> obtains information about a particular slot in the system. <I>slotID</I> is the ID of the slot; <I>pInfo</I> points to the location that receives the slot information.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SLOT_ID_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_GetTokenInfo.</P>

<UL>
</B><LI><A NAME="_Toc323024107"><A NAME="_Toc323205439"><A NAME="_Toc323610869"><A NAME="_Toc383864876"><A NAME="_Toc385057902"><A NAME="_Toc405794721"><A NAME="_Toc410109059"></FONT><B><FONT FACE="Palatino">C_GetTokenInfo</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetTokenInfo)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_TOKEN_INFO_PTR pInfo<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetTokenInfo</B> obtains information about a particular token in the system.  <I>slotID</I> is the ID of the token’s slot; <I>pInfo</I> points to the location that receives the token information.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT, CKR_TOKEN_NOT_RECOGNIZED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_ULONG ulCount;</P>
<P>CK_SLOT_ID_PTR pSlotList;</P>
<P>CK_SLOT_INFO slotInfo;</P>
<P>CK_TOKEN_INFO tokenInfo;</P>
<P>CK_RV rv;</P>

<P>rv = C_GetSlotList(FALSE, NULL_PTR, &amp;ulCount);</P>
<P>if ((rv == CKR_OK) &amp;&amp; (ulCount &gt; 0)) {</P>
<P>  pSlotList = (CK_SLOT_ID_PTR) malloc(ulCount*sizeof(CK_SLOT_ID));</P>
<P>  rv = C_GetSlotList(FALSE, pSlotList, &amp;ulCount);</P>
<P>  assert(rv == CKR_OK);</P>

<P>  /* Get slot information for first slot */</P>
<P>  rv = C_GetSlotInfo(pSlotList[0], &amp;slotInfo);</P>
<P>  assert(rv == CKR_OK);</P>

<P>  /* Get token information for first slot */</P>
<P>  rv = C_GetTokenInfo(pSlotList[0], &amp;tokenInfo);</P>
<P>  if (rv == CKR_TOKEN_NOT_PRESENT) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>  free(pSlotList);</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc405794722"><A NAME="_Toc410109060"><A NAME="_Toc323024108"><A NAME="_Toc323205440"><A NAME="_Toc323610870"><A NAME="_Toc383864877"><A NAME="_Toc385057903"></FONT><B><FONT FACE="Palatino">C_WaitForSlotEvent</A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_WaitForSlotEvent)(<BR>
  CK_FLAGS flags,<BR>
  CK_SLOT_ID_PTR pSlot,<BR>
  CK_VOID_PTR pReserved<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_WaitForSlotEvent</B> waits for a slot event, such as token insertion or token removal, to occur.  <I>flags</I> determines whether or not the <B>C_WaitForSlotEvent</B> call blocks (<I>i.e.</I>, waits for a slot event to occur); <I>pSlot</I> points to a location which will receive the ID of the slot that the event occurred in.  <I>pReserved</I> is reserved for future versions; for this version of Cryptoki, it should be NULL_PTR.</P>
<P ALIGN="JUSTIFY">At present, the only flag defined for use in the <I>flags</I> argument is <B>CKF_DONT_BLOCK</B>:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CKF_DONT_BLOCK 1</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Internally, each Cryptoki application has a flag for each slot which is used to track whether or not any unrecognized events involving that slot have occurred.  When an application initially calls <B>C_Initialize</B>, every slot’s event flag is cleared.  Whenever a slot event occurs, the flag corresponding to the slot in which the event occurred is set.</P>
<P ALIGN="JUSTIFY">If <B>C_WaitForSlotEvent</B> is called with the <B>CKF_DONT_BLOCK</B> flag set in the <I>flags</I> argument, and some slot’s event flag is set, then that event flag is cleared, and the call returns with the ID of that slot in the location pointed to by <I>pSlot</I>.  If more than one slot’s event flag is set at the time of the call, one such slot is chosen by the library to have its event flag cleared and to have its slot ID returned.</P>
<P ALIGN="JUSTIFY">If <B>C_WaitForSlotEvent</B> is called with the <B>CKF_DONT_BLOCK</B> flag set in the <I>flags</I> argument, and no slot’s event flag is set, then the call returns with the value CKR_NO_EVENT.  In this case, the contents of the location pointed to by <I>pSlot</I> when <B>C_WaitForSlotEvent</B> are undefined.</P>
<P ALIGN="JUSTIFY">If <B>C_WaitForSlotEvent</B> is called with the <B>CKF_DONT_BLOCK</B> flag clear in the <I>flags</I> argument, then the call behaves as above, except that it will block.  That is, if no slot’s event flag is set at the time of the call, <B>C_WaitForSlotEvent</B> will wait until some slot’s event flag becomes set.  If a thread of an application has a <B>C_WaitForSlotEvent</B> call blocking when another thread of that application calls <B>C_Finalize</B>, the <B>C_WaitForSlotEvent</B> call returns with the value CKR_CRYPTOKI_NOT_INITIALIZED.</P>
<I><P ALIGN="JUSTIFY">Although the parameters supplied to <B>C_Initialize</B> can in general allow for safe multi-threaded access to a Cryptoki library, <B>C_WaitForSlotEvent</B> is exceptional in that the behavior of Cryptoki is undefined if multiple threads of a single application make simultaneous calls to <B>C_WaitForSlotEvent</B>.</P>
</I><P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_NO_EVENT, CKR_OK.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_FLAGS flags = 0;</P>
<P>CK_SLOT_ID slotID;</P>
<P>CK_SLOT_INFO slotInfo;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Block and wait for a slot event */</P>
<P>rv = C_WaitForSlotEvent(flags, &amp;slotID, NULL_PTR);</P>
<P>assert(rv == CKR_OK);</P>

<P>/* See what’s up with that slot */</P>
<P>rv = C_GetSlotInfo(slotID, &amp;slotInfo);</P>
<P>assert(rv == CKR_OK);</P>
<P>.</P>
<P>.</P>
<P>.</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc405794723"><A NAME="_Toc410109061"></FONT><B><FONT FACE="Palatino">C_GetMechanismList</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetMechanismList)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_MECHANISM_TYPE_PTR pMechanismList,<BR>
  CK_ULONG_PTR pulCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetMechanismList</B> is used to obtain a list of mechanism types supported by a token.  <I>SlotID</I> is the ID of the token’s slot; <I>pulCount</I> points to the location that receives the number of mechanisms.</P>
<P ALIGN="JUSTIFY">There are two ways for an application to call <B>C_GetMechanismList</B>:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If <I>pMechanismList</I> is NULL_PTR, then all that <B>C_GetMechanismList</B> does is return (in *<I>pulCount</I>) the number of mechanisms, without actually returning a list of mechanisms.  The contents of *<I>pulCount</I> on entry to <B>C_GetMechanismList</B> has no meaning in this case, and the call returns the value CKR_OK.</LI></P>
<P ALIGN="JUSTIFY"><LI>If <I>pMechanismList</I> is not NULL_PTR, then *<I>pulCount</I> must contain the size (in terms of <B>CK_MECHANISM_TYPE</B> elements) of the buffer pointed to by <I>pMechanismList</I>.  If that buffer is large enough to hold the list of mechanisms, then the list is returned in it, and CKR_OK is returned.  If not, then the call to <B>C_GetMechanismList</B> returns the value CKR_BUFFER_TOO_SMALL.  In either case, the value *<I>pulCount</I> is set to hold the number of mechanisms.</LI></P></OL>

<P ALIGN="JUSTIFY">Because <B>C_GetMechanismList</B> does not allocate any space of its own, an application will often call <B>C_GetMechanismList</B> twice.  However, this behavior is by no means required.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT, CKR_TOKEN_NOT_RECOGNIZED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SLOT_ID slotID;</P>
<P>CK_ULONG ulCount;</P>
<P>CK_MECHANISM_TYPE_PTR pMechanismList;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_GetMechanismList(slotID, NULL_PTR, &amp;ulCount);</P>
<P>if ((rv == CKR_OK) &amp;&amp; (ulCount &gt; 0)) {</P>
<P>  pMechanismList =</P>
<P>    (CK_MECHANISM_TYPE_PTR)</P>
<P>    malloc(ulCount*sizeof(CK_MECHANISM_TYPE));</P>
<P>  rv = C_GetMechanismList(slotID, pMechanismList, &amp;ulCount);</P>
<P>  if (rv == CKR_OK) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>  free(pMechanismList);</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024109"><A NAME="_Toc323205441"><A NAME="_Toc323610871"><A NAME="_Toc383864878"><A NAME="_Toc385057904"><A NAME="_Toc405794724"><A NAME="_Toc410109062"></FONT><B><FONT FACE="Palatino">C_GetMechanismInfo</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetMechanismInfo)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_MECHANISM_TYPE type,<BR>
  CK_MECHANISM_INFO_PTR pInfo<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetMechanismInfo</B> obtains information about a particular mechanism possibly supported by a token. <I>slotID</I> is the ID of the token’s slot; <I>type</I> is the type of mechanism; <I>pInfo</I> points to the location that receives the mechanism information.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MECHANISM_INVALID, CKR_OK, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT, CKR_TOKEN_NOT_RECOGNIZED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SLOT_ID slotID;</P>
<P>CK_MECHANISM_INFO info;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Get information about the CKM_MD2 mechanism for this token */</P>
<P>rv = C_GetMechanismInfo(slotID, CKM_MD2, &amp;info);</P>
<P>if (rv == CKR_OK) {</P>
<P>  if (info.flags &amp; CKF_DIGEST) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024110"><A NAME="_Toc323205442"><A NAME="_Toc323610872"><A NAME="_Toc383864879"><A NAME="_Toc385057905"><A NAME="_Toc405794725"><A NAME="_Toc410109063"></FONT><B><FONT FACE="Palatino">C_InitToken</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_InitToken)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_CHAR_PTR pPin,<BR>
  CK_ULONG ulPinLen,<BR>
  CK_CHAR_PTR pLabel<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_InitToken</B> initializes a token. <I>slotID</I> is the ID of the token’s slot; <I>pPin</I> points to the SO’s initial PIN (which need <I>not</I> be null-terminated); <I>ulPinLen</I> is the length in bytes of the PIN; <I>pLabel</I> points to the 32-byte label of the token (which must be padded with blank characters, and which must <I>not</I> be null-terminated).</P>
<P ALIGN="JUSTIFY">When a token is initialized, all objects that can be destroyed are destroyed (<I>i.e.</I>, all except for &quot;indestructible&quot; objects such as keys built into the token).  Also, access by the normal user is disabled until the SO sets the normal user’s PIN.  Depending on the token, some &quot;default&quot; objects may be created, and attributes of some objects may be set to default values.</P>
<P ALIGN="JUSTIFY">If the token has a &quot;protected authentication path&quot;, as indicated by the CKF_PROTECTED_AUTHENTICATION_PATH flag in its <B>CK_TOKEN_INFO</B> being set, then that means that there is some way for a user to be authenticated to the token without having the application send a PIN through the Cryptoki library.  One such possibility is that the user enters a PIN on a PINpad on the token itself, or on the slot device.  To initialize a token with such a protected authentication path, the <I>pPin</I> parameter to <B>C_InitToken</B> should be NULL_PTR.  During the execution of <B>C_InitToken</B>, the SO’s PIN will be entered through the protected authentication path.</P>
<P ALIGN="JUSTIFY">If the token has a protected authentication path other than a PINpad, then it is token-dependent whether or not <B>C_InitToken</B> can be used to initialize the token.</P>
<P ALIGN="JUSTIFY">A token cannot be initialized if Cryptoki detects that <I>any</I> application has an open session with it; when a call to <B>C_InitToken</B> is made under such circumstances, the call fails with error CKR_SESSION_EXISTS.  Unfortunately, it may happen when <B>C_InitToken</B> is called that some other application <I>does</I> have an open session with the token, but Cryptoki cannot detect this, because it cannot detect anything about other applications using the token.  If this is the case, then the consequences of the <B>C_InitToken</B> call are undefined.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_PIN_INCORRECT, CKR_PIN_LOCKED, CKR_SESSION_EXISTS, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT, CKR_TOKEN_NOT_RECOGNIZED, CKR_TOKEN_WRITE_PROTECTED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SLOT_ID slotID;</P>
<P>CK_CHAR_PTR pin = &quot;MyPIN&quot;;</P>
<P>CK_CHAR label[32];</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>memset(label, ‘ ’, sizeof(label));</P>
<P>memcpy(label, &quot;My first token&quot;, strlen(&quot;My first token&quot;));</P>
<P>rv = C_InitToken(slotID, pin, strlen(pin), label);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024111"><A NAME="_Toc323205443"><A NAME="_Toc323610873"><A NAME="_Toc383864880"><A NAME="_Toc385057906"><A NAME="_Toc405794726"><A NAME="_Toc410109064"></FONT><B><FONT FACE="Palatino">C_InitPIN</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_InitPIN)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_CHAR_PTR pPin,<BR>
  CK_ULONG ulPinLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_InitPIN</B> initializes the normal user’s PIN.  <I>hSession</I> is the session’s handle; <I>pPin</I> points to the normal user’s PIN;<I> ulPinLen</I> is the length in bytes of the PIN.</P>
<B><P ALIGN="JUSTIFY">C_InitPIN</B> can only be called in the &quot;R/W SO Functions&quot; state.  An attempt to call it from a session in any other state fails with error CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">If the token has a &quot;protected authentication path&quot;, as indicated by the CKF_PROTECTED_AUTHENTICATION_PATH flag in its <B>CK_TOKEN_INFO</B> being set, then that means that there is some way for a user to be authenticated to the token without having the application send a PIN through the Cryptoki library.  One such possibility is that the user enters a PIN on a PINpad on the token itself, or on the slot device.  To initialize the normal user’s PIN on a token with such a protected authentication path, the <I>pPin</I> parameter to <B>C_InitPIN</B> should be NULL_PTR.  During the execution of <B>C_InitPIN</B>, the SO will enter the new PIN through the protected authentication path.</P>
<P ALIGN="JUSTIFY">If the token has a protected authentication path other than a PINpad, then it is token-dependent whether or not <B>C_InitPIN</B> can be used to initialize the normal user’s token access.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_PIN_INVALID, CKR_PIN_LEN_RANGE, CKR_SESSION_CLOSED, CKR_SESSION_READ_ONLY, CKR_SESSION_HANDLE_INVALID, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_CHAR newPin[]= {&quot;NewPIN&quot;};</P>
<P>CK_RV rv;</P>

<P>rv = C_InitPIN(hSession, newPin, sizeof(newPin));</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024112"><A NAME="_Toc323205444"><A NAME="_Toc323610874"><A NAME="_Toc383864881"><A NAME="_Toc385057907"><A NAME="_Toc405794727"><A NAME="_Toc410109065"></FONT><B><FONT FACE="Palatino">C_SetPIN</B></A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SetPIN)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_CHAR_PTR pOldPin,<BR>
  CK_ULONG ulOldLen,<BR>
  CK_CHAR_PTR pNewPin,<BR>
  CK_ULONG ulNewLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SetPIN</B> modifies the PIN of the user that is currently logged in.  <I>hSession</I> is the session’s handle; <I>pOldPin</I> points to the old PIN; <I>ulOldLen</I> is the length in bytes of the old PIN;<I> pNewPin</I> points to the new PIN; <I>ulNewLen</I> is the length in bytes of the new PIN.</P>
<B><P ALIGN="JUSTIFY">C_SetPIN</B> can only be called in the &quot;R/W SO Functions&quot; state or &quot;R/W User Functions&quot; state.  An attempt to call it from a session in any other state fails with error CKR_SESSION_READ_ONLY.</P>
<P ALIGN="JUSTIFY">If the token has a &quot;protected authentication path&quot;, as indicated by the CKF_PROTECTED_AUTHENTICATION_PATH flag in its <B>CK_TOKEN_INFO</B> being set, then that means that there is some way for a user to be authenticated to the token without having the application send a PIN through the Cryptoki library.  One such possibility is that the user enters a PIN on a PINpad on the token itself, or on the slot device.  To modify the current user’s PIN on a token with such a protected authentication path, the <I>pOldPin</I> and <I>pNewPin</I> parameters to <B>C_SetPIN</B> should be NULL_PTR.  During the execution of <B>C_SetPIN</B>, the current user will enter the old PIN and the new PIN through the protected authentication path.  It is not specified how the PINpad should be used to enter <I>two</I> PINs; this varies.</P>
<P ALIGN="JUSTIFY">If the token has a protected authentication path other than a PINpad, then it is token-dependent whether or not <B>C_SetPIN</B> can be used to modify the current user’s PIN.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_PIN_INCORRECT, CKR_PIN_INVALID, CKR_PIN_LEN_RANGE, CKR_PIN_LOCKED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TOKEN_WRITE_PROTECTED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_CHAR oldPin[] = {&quot;OldPIN&quot;};</P>
<P>CK_CHAR newPin[] = {&quot;NewPIN&quot;};</P>
<P>CK_RV rv;</P>

<P>rv = C_SetPIN(</P>
<P>  hSession, oldPin, sizeof(oldPin), newPin, sizeof(newPin));</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287673"><A NAME="_Toc319313513"><A NAME="_Toc319313706"><A NAME="_Toc319315699"><A NAME="_Toc322855300"><A NAME="_Toc322945142"><A NAME="_Toc323000709"><A NAME="_Toc323024113"><A NAME="_Toc323205445"><A NAME="_Toc323610875"><A NAME="_Toc383864882"><A NAME="_Toc385057908"><A NAME="_Toc405794728"><A NAME="_Toc410109066">10.6.&#9;Session management</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">A typical application might perform the following series of steps to make use of a token (note that there are other reasonable sequences of events that an application might perform):</P>
<OL>

<P ALIGN="JUSTIFY"><LI>Select a token.</LI></P>
<P ALIGN="JUSTIFY"><LI>Make one or more calls to <B>C_OpenSession</B> to obtain one or more sessions with the token.</LI></P>
<P ALIGN="JUSTIFY"><LI>Call <B>C_Login</B> to log the user into the token.  Since all sessions an application has with a token have a shared login state, <B>C_Login</B> only needs to be called for one of the sessions.</LI></P>
<P ALIGN="JUSTIFY"><LI>Perform cryptographic operations using the sessions with the token.</LI></P>
<P ALIGN="JUSTIFY"><LI>Call <B>C_CloseSession</B> once for each session that the application has with the token, or call <B>C_CloseAllSessions</B> to close all the application’s sessions simultaneously.</LI></P></OL>

<P ALIGN="JUSTIFY">As has been observed, an application may have concurrent sessions with more than one token.  It is also possible for a token to have concurrent sessions with more than one application.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc323024114"><A NAME="_Toc323205446"><A NAME="_Toc323610876"><A NAME="_Toc383864883"><A NAME="_Toc385057909"><A NAME="_Toc405794729">Cryptoki provides the following functions for session management:</P>

<UL>
<LI><A NAME="_Toc410109067"></FONT><B><FONT FACE="Palatino">C_OpenSession</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(<BR>
  CK_SLOT_ID slotID,<BR>
  CK_FLAGS flags,<BR>
  CK_VOID_PTR pApplication,<BR>
  CK_NOTIFY Notify,<BR>
  CK_SESSION_HANDLE_PTR phSession<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_OpenSession</B> opens a session between an application and a token in a particular slot.  <I>slotID</I> is the slot’s ID; <I>flags</I> indicates the type of session; <I>pApplication</I> is an application-defined pointer to be passed to the notification callback; <I>Notify</I> is the address of the notification callback function (see Section 10.17); <I>phSession</I> points to the location that receives the handle for the new session.</P>
<P ALIGN="JUSTIFY">When opening a session with <B>C_OpenSession</B>, the <I>flags</I> parameter consists of the logical OR of zero or more bit flags defined in the <B>CK_SESSION_INFO</B> data type.  For legacy reasons, the <B>CKF_SERIAL_SESSION</B> bit must always be set; if a call to <B>C_OpenSession</B> does not have this bit set, the call should return unsuccessfully with the error code CKR_PARALLEL_NOT_SUPPORTED.</P>
<P ALIGN="JUSTIFY">There may be a limit on the number of concurrent sessions an application may have with the token, which may depend on whether the session is &quot;read-only&quot; or &quot;read/write&quot;.  An attempt to open a session which does not succeed because there are too many existing sessions of some type should return CKR_SESSION_COUNT.</P>
<P ALIGN="JUSTIFY">If the token is write-protected (as indicated in the <B>CK_TOKEN_INFO</B> structure), then only read-only sessions may be opened with it.</P>
<P ALIGN="JUSTIFY">If the application calling <B>C_OpenSession</B> already has a R/W SO session open with the token, then any attempt to open a R/O session with the token fails with error code CKR_SESSION_READ_WRITE_SO_EXISTS (see Section 5.6.7).</P>
<P ALIGN="JUSTIFY">The <I>Notify</I> callback function is used by Cryptoki to notify the application of certain events.  If the application does not wish to support callbacks, it should pass a value of NULL_PTR as the <I>Notify</I> parameter.  See Section 10.17 for more information about application callbacks.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SESSION_COUNT, CKR_SESSION_PARALLEL_NOT_SUPPORTED, CKR_SESSION_READ_WRITE_SO_EXISTS, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT, CKR_TOKEN_NOT_RECOGNIZED, CKR_TOKEN_WRITE_PROTECTED.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_CloseSession</B>.</P>

<UL>
<LI><A NAME="_Toc323024115"><A NAME="_Toc323205447"><A NAME="_Toc323610877"><A NAME="_Toc383864884"><A NAME="_Toc385057910"><A NAME="_Toc405794730"><A NAME="_Toc410109068"></FONT><B><FONT FACE="Palatino">C_CloseSession</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_CloseSession)(<BR>
  CK_SESSION_HANDLE hSession<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_CloseSession</B> closes a session between an application and a token.  <I>hSession</I> is the session’s handle.</P>
<P ALIGN="JUSTIFY">When a session is closed, all session objects created by the session are destroyed automatically, even if the application has other sessions &quot;using&quot; the objects (see Sections 5.6.5-5.6.7 for more details).</P>
<P ALIGN="JUSTIFY">Depending on the token, when the last open session any application has with the token is closed, the token may be &quot;ejected&quot; from its reader (if this capability exists).</P>
<P ALIGN="JUSTIFY">Despite the fact this <B>C_CloseSession</B> is supposed to close a session, the return value CKR_SESSION_CLOSED is an <I>error</I> return.  It actually indicates the (probably somewhat unlikely) event that while this function call was executing, another call was made to <B>C_CloseSession</B> to close this particular session, and that call finished executing first.  Such uses of sessions are a bad idea, and Cryptoki makes little promise of what will occur in general if an application indulges in this sort of behavior.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SLOT_ID slotID;</P>
<P>CK_BYTE application;</P>
<P>CK_NOTIFY MyNotify;</P>
<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>application = 17;</P>
<P>MyNotify = &amp;EncryptionSessionCallback;</P>
<P>rv = C_OpenSession(</P>
<P>  slotID, CKF_RW_SESSION,(CK_VOID_PTR) &amp;application, MyNotify,</P>
<P>  &amp;hSession);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>  C_CloseSession(hSession);</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024116"><A NAME="_Toc323205448"><A NAME="_Toc323610878"><A NAME="_Toc383864885"><A NAME="_Toc385057911"><A NAME="_Toc405794731"><A NAME="_Toc410109069"></FONT><B><FONT FACE="Palatino">C_CloseAllSessions</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_CloseAllSessions)(<BR>
  CK_SLOT_ID slotID<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_CloseAllSessions</B> closes all sessions an application has with a token. <I>slotID</I> specifies the token’s slot.</P>
<P ALIGN="JUSTIFY">When a session is closed, all session objects created by the session are destroyed automatically.</P>
<P ALIGN="JUSTIFY">Depending on the token, when the last open session any application has with the token is closed, the token may be &quot;ejected&quot; from its reader (if this capability exists).</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SLOT_ID_INVALID, CKR_TOKEN_NOT_PRESENT.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SLOT_ID slotID;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_CloseAllSessions(slotID);</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024117"><A NAME="_Toc323205449"><A NAME="_Toc323610879"><A NAME="_Toc383864886"><A NAME="_Toc385057912"><A NAME="_Toc405794732"><A NAME="_Toc410109070"></FONT><B><FONT FACE="Palatino">C_GetSessionInfo</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetSessionInfo)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_SESSION_INFO_PTR pInfo<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetSessionInfo</B> obtains information about a session.  <I>hSession</I> is the session’s handle; <I>pInfo</I> points to the location that receives the session information.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_SESSION_INFO info;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_GetSessionInfo(hSession, &amp;info);</P>
<P>if (rv == CKR_OK) {</P>
<P>  if (info.state == CKS_RW_USER_FUNCTIONS) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057913"><A NAME="_Toc405794733"><A NAME="_Toc410109071"></FONT><B><FONT FACE="Palatino">C_GetOperationState</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetOperationState)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pOperationState,<BR>
  CK_ULONG_PTR pulOperationStateLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetOperationState</B> obtains a copy of the cryptographic operations state of a session, encoded as a string of bytes.  <I>hSession</I> is the session’s handle; <I>pOperationState</I> points to the location that receives the state; <I>pulOperationStateLen</I> points to the location that receives the length in bytes of the state.</P>
<P ALIGN="JUSTIFY">Although the saved state output by <B>C_GetOperationState</B> is not really produced by a &quot;cryptographic mechanism&quot;, <B>C_GetOperationState</B> nonetheless uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">Precisely what the &quot;cryptographic operations state&quot; this function saves is varies from token to token; however, this state is what is provided as input to <B>C_SetOperationState</B> to restore the cryptographic activities of a session.</P>
<P ALIGN="JUSTIFY">Consider a session which is performing a message digest operation using SHA-1 (<I>i.e.</I>, the session is using the <B>CKM_SHA_1</B> mechanism).  Suppose that the message digest operation was initialized properly, and that precisely 80 bytes of data have been supplied so far as input to SHA-1.  The application now wants to &quot;save the state&quot; of this digest operation, so that it can continue it later.  In this particular case, since SHA-1 processes 512 bits (64 bytes) of input at a time, the cryptographic operations state of the session most likely consists of three distinct parts: the state of SHA-1’s 160-bit internal chaining variable; the 16 bytes of unprocessed input data; and some administrative data indicating that this saved state comes from a session which was performing SHA-1 hashing.  Taken together, these three pieces of information suffice to continue the current hashing operation at a later time.</P>
<P ALIGN="JUSTIFY">Consider next a session which is performing an encryption operation with DES (a block cipher with a block size of 64 bits) in CBC (cipher-block chaining) mode (<I>i.e.</I>, the session is using the <B>CKM_DES_CBC</B> mechanism).  Suppose that precisely 22 bytes of data (in addition to an IV for the CBC mode) have been supplied so far as input to DES, which means that the first two 8-byte blocks of ciphertext have already been produced and output.  In this case, the cryptographic operations state of the session most likely consists of three or four distinct parts: the second 8-byte block of ciphertext (this will be used for cipher-block chaining to produce the next block of ciphertext); the 6 bytes of data still awaiting encryption; some administrative data indicating that this saved state comes from a session which was performing DES encryption in CBC mode; and possibly the DES key being used for encryption (see <B>C_SetOperationState</B> for more information on whether or not the key is present in the saved state).</P>
<P ALIGN="JUSTIFY">If a session is performing two cryptographic operations simultaneously (see Section 10.13), then the cryptographic operations state of the session will contain all the necessary information to restore both operations.</P>
<P ALIGN="JUSTIFY">An attempt to save the cryptographic operations state of a session which does not currently have some active saveable cryptographic operation(s) (encryption, decryption, digesting, signing without message recovery, verification without message recovery, or some legal combination of two of these) should fail with the error CKR_OPERATION_NOT_INITIALIZED.</P>
<P ALIGN="JUSTIFY">An attempt to save the cryptographic operations state of a session which is performing an appropriate cryptographic operation (or two), but which cannot be satisfied for any of various reasons (certain necessary state information and/or key information can’t leave the token, for example) should fail with the error CKR_STATE_UNSAVEABLE.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_STATE_UNSAVEABLE.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_SetOperationState</B>.</P>

<UL>
<LI><A NAME="_Toc385057914"><A NAME="_Toc405794734"><A NAME="_Toc410109072"></FONT><B><FONT FACE="Palatino">C_SetOperationState</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SetOperationState)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pOperationState,<BR>
  CK_ULONG ulOperationStateLen,<BR>
  CK_OBJECT_HANDLE hEncryptionKey,<BR>
  CK_OBJECT_HANDLE hAuthenticationKey<BR>
);</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024118"><A NAME="_Toc323205450"><A NAME="_Toc323610880"><A NAME="_Toc383864887">C_SetOperationState</B> restores the cryptographic operations state of a session from a string of bytes obtained with <B>C_GetOperationState</B>.  <I>hSession</I> is the session’s handle; <I>pOperationState</I> points to the location holding the saved state; <I>ulOperationStateLen</I> holds the length of the saved state; <I>hEncryptionKey</I> holds a handle to the key which will be used for an ongoing encryption or decryption operation in the restored session (or 0 if no encryption or decryption key is needed, either because no such operation is ongoing in the stored session or because all the necessary key information is present in the saved state); <I>hAuthenticationKey</I> holds a handle to the key which will be used for an ongoing signature, MACing, or verification operation in the restored session (or 0 if no such key is needed, either because no such operation is ongoing in the stored session or because all the necessary key information is present in the saved state).</P>
<P ALIGN="JUSTIFY">The state need not have been obtained from the same session (the &quot;source session&quot;) as it is being restored to (the &quot;destination session&quot;).  However, the source session and destination session should have a common session state (<I>e.g.</I>, CKS_RW_USER_FUNCTIONS), and should be with a common token.  There is also no guarantee that cryptographic operations state may be carried across logins, or across different Cryptoki implementations.</P>
<P ALIGN="JUSTIFY">If <B>C_SetOperationState</B> is supplied with alleged saved cryptographic operations state which it can determine is not valid saved state (or is cryptographic operations state from a session with a different session state, or is cryptographic operations state from a different token), it fails with the error CKR_SAVED_STATE_INVALID.</P>
<P ALIGN="JUSTIFY">Saved state obtained from calls to <B>C_GetOperationState</B> may or may not contain information about keys in use for ongoing cryptographic operations.  If a saved cryptographic operations state has an ongoing encryption or decryption operation, and the key in use for the operation is not saved in the state, then it must be supplied to <B>C_SetOperationState</B> in the <I>hEncryptionKey</I> argument.  If it is not, then <B>C_SetOperationState</B> will fail and return the error CKR_KEY_NEEDED.  If the key in use for the operation <I>is</I> saved in the state, then it <I>can</I> be supplied in the <I>hEncryptionKey</I> argument, but this is not required.</P>
<P ALIGN="JUSTIFY">Similarly, if a saved cryptographic operations state has an ongoing signature, MACing, or verification operation, and the key in use for the operation is not saved in the state, then it must be supplied to <B>C_SetOperationState</B> in the <I>hAuthenticationKey</I> argument.  If it is not, then <B>C_SetOperationState</B> will fail with the error CKR_KEY_NEEDED.  If the key in use for the operation <I>is</I> saved in the state, then it <I>can</I> be supplied in the <I>hAuthenticationKey</I> argument, but this is not required.</P>
<P ALIGN="JUSTIFY">If an <I>irrelevant</I> key is supplied to <B>C_SetOperationState</B> call (<I>e.g.</I>, a nonzero key handle is submitted in the <I>hEncryptionKey</I> argument, but the saved cryptographic operations state supplied does not have an ongoing encryption or decryption operation, then <B>C_SetOperationState</B> fails with the error CKR_KEY_NOT_NEEDED.</P>
<P ALIGN="JUSTIFY">If a key is supplied as an argument to <B>C_SetOperationState</B>, and <B>C_SetOperationState</B> can somehow detect that this key was not the key being used in the source session for the supplied cryptographic operations state (it may be able to detect this if the key or a hash of the key is present in the saved state, for example), then <B>C_SetOperationState</B> fails with the error CKR_KEY_CHANGED.</P>
<P ALIGN="JUSTIFY">An application can look at the <B>CKF_RESTORE_KEY_NOT_NEEDED</B> flag in the flags field of the <B>CK_TOKEN_INFO</B> field for a token to determine whether or not it needs to supply key handles to <B>C_SetOperationState</B> calls.  If this flag is TRUE, then a call to <B>C_SetOperationState</B> <I>never</I> needs a key handle to be supplied to it.  If this flag is FALSE, then at least some of the time, <B>C_SetOperationState</B> requires a key handle, and so the application should probably <I>always</I> pass in any relevant key handles when restoring cryptographic operations state to a session.</P>
<B><P ALIGN="JUSTIFY">C_SetOperationState</B> can successfully restore cryptographic operations state to a session even if that session has active cryptographic or object search operations when <B>C_SetOperationState</B> is called (the ongoing operations are abruptly cancelled).</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_CHANGED, CKR_KEY_NEEDED, CKR_KEY_NOT_NEEDED, CKR_OK, CKR_SAVED_STATE_INVALID, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_MECHANISM digestMechanism;</P>
<P>CK_ULONG ulStateLen;</P>
<P>CK_BYTE data1[] = {0x01, 0x03, 0x05, 0x07};</P>
<P>CK_BYTE data2[] = {0x02, 0x04, 0x08};</P>
<P>CK_BYTE data3[] = {0x10, 0x0F, 0x0E, 0x0D, 0x0C};</P>
<P>CK_BYTE pDigest[20];</P>
<P>CK_ULONG ulDigestLen;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Initialize hash operation */</P>
<P>rv = C_DigestInit(hSession, &amp;digestMechanism);</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Start hashing */</P>
<P>rv = C_DigestUpdate(hSession, data1, sizeof(data1));</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Find out how big the state might be */</P>
<P>rv = C_GetOperationState(hSession, NULL_PTR, &amp;ulStateLen);</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Allocate some memory and then get the state */</P>
<P>pState = (CK_BYTE_PTR) malloc(ulStateLen);</P>
<P>rv = C_GetOperationState(hSession, pState, &amp;ulStateLen);</P>

<P>/* Continue hashing */</P>
<P>rv = C_DigestUpdate(hSession, data2, sizeof(data2));</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Restore state.  No key handles needed */</P>
<P>rv = C_SetOperationState(hSession, pState, ulStateLen, 0, 0);</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Continue hashing from where we saved state */</P>
<P>rv = C_DigestUpdate(hSession, data3, sizeof(data3));</P>
<P>assert(rv == CKR_OK);</P>

<P>/* Conclude hashing operation */</P>
<P>ulDigestLen = sizeof(pDigest);</P>
<P>rv = C_DigestFinal(hSession, pDigest, &amp;ulDigestLen);</P>
<P>if (rv == CKR_OK) {</P>
<P>  /* pDigest[] now contains the hash of 0x01030507100F0E0D0C */</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057915"><A NAME="_Toc405794735"><A NAME="_Toc410109073"></FONT><B><FONT FACE="Palatino">C_Login</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Login)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_USER_TYPE userType,<BR>
  CK_CHAR_PTR pPin,<BR>
  CK_ULONG ulPinLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Login</B> logs a user into a token.  <I>hSession</I> is a session handle; <I>userType</I> is the user type; <I>pPin</I> points to the user’s PIN;<I> ulPinLen</I> is the length of the PIN.</P>
<P ALIGN="JUSTIFY">Depending on the user type, if the call succeeds, each of the application’s sessions will enter either the &quot;R/W SO Functions&quot; state, the &quot;R/W User Functions&quot; state, or the &quot;R/O User Functions&quot; state.</P>
<P ALIGN="JUSTIFY">If the token has a &quot;protected authentication path&quot;, as indicated by the <B>CKF_PROTECTED_AUTHENTICATION_PATH</B> flag in its <B>CK_TOKEN_INFO</B> being set, then that means that there is some way for a user to be authenticated to the token without having the application send a PIN through the Cryptoki library.  One such possibility is that the user enters a PIN on a PINpad on the token itself, or on the slot device.  Or the user might not even use a PIN—authentication could be achieved by some fingerprint-reading device, for example.  To log into a token with a protected authentication path, the <I>pPin</I> parameter to <B>C_Login</B> should be NULL_PTR.  When <B>C_Login</B> returns, whatever authentication method supported by the token will have been performed; a return value of CKR_OK means that the user was successfully authenticated, and a return value of CKR_PIN_INCORRECT means that the user was denied access.</P>
<P ALIGN="JUSTIFY">If there are any active cryptographic or object finding operations in an application’s session, and then <B>C_Login</B> is successfully executed by that application, it may or may not be the case that those operations are still active.  Therefore, before logging in, any active operations should be finished.</P>
<P ALIGN="JUSTIFY">If the application calling <B>C_Login</B> has a R/O session open with the token, then it will be unable to log the SO into a session (see Section 5.6.7).  An attempt to do this will result in the error code CKR_SESSION_READ_ONLY_EXISTS.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_PIN_EXPIRED, CKR_PIN_INCORRECT, CKR_PIN_LOCKED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY_EXISTS, CKR_USER_ALREADY_LOGGED_IN, CKR_USER_ANOTHER_ALREADY_LOGGED_IN, CKR_USER_PIN_NOT_INITIALIZED, CKR_USER_TOO_MANY_TYPES, CKR_USER_TYPE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_Logout</B>.</P>

<UL>
<LI><A NAME="_Toc323024119"><A NAME="_Toc323205451"><A NAME="_Toc323610881"><A NAME="_Toc383864888"><A NAME="_Toc385057916"><A NAME="_Toc405794736"><A NAME="_Toc410109074"></FONT><B><FONT FACE="Palatino">C_Logout</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Logout)(<BR>
  CK_SESSION_HANDLE hSession<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Logout</B> logs a user out from a token.  <I>hSession</I> is the session’s handle.</P>
<P ALIGN="JUSTIFY">Depending on the current user type, if the call succeeds, each of the application’s sessions will enter either the &quot;R/W Public Session&quot; state or the &quot;R/O Public Session&quot; state.</P>
<P ALIGN="JUSTIFY">When <B>C_Logout</B> successfully executes, any of the application’s handles to private objects become invalid (even if a user is later logged back into the token, those handles remain invalid).  In addition, all private session objects from sessions belonging to the application are destroyed.</P>
<P ALIGN="JUSTIFY">If there are any active cryptographic or object-finding operations in an application’s session, and then <B>C_Logout</B> is successfully executed by that application, it may or may not be the case that those operations are still active.  Therefore, before logging out, any active operations should be finished.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_CHAR userPIN[] = {&quot;MyPIN&quot;};</P>
<P>CK_RV rv;</P>

<P>rv = C_Login(hSession, CKU_USER, userPIN, sizeof(userPIN));</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>  rv == C_Logout(hSession);</P>
<P>  if (rv == CKR_OK) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287674"><A NAME="_Toc319313514"><A NAME="_Toc319313707"><A NAME="_Toc319315700"><A NAME="_Toc322855301"><A NAME="_Toc322945143"><A NAME="_Toc323000710"><A NAME="_Toc323024120"><A NAME="_Toc323205452"><A NAME="_Toc323610882"><A NAME="_Toc383864889"><A NAME="_Toc385057917"><A NAME="_Ref398614396"><A NAME="_Ref398614471"><A NAME="_Ref399147217"><A NAME="_Toc405794737"><A NAME="_Toc410109075">10.7.&#9;Object management</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for managing objects.  Additional functions provided specifically for managing key objects are described in Section 10.14.</P>

<UL>
<LI><A NAME="_Toc323024121"><A NAME="_Toc323205453"><A NAME="_Toc323610883"><A NAME="_Toc383864890"><A NAME="_Toc385057918"><A NAME="_Toc405794738"><A NAME="_Toc410109076"></FONT><B><FONT FACE="Palatino">C_CreateObject</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount,<BR>
  CK_OBJECT_HANDLE_PTR phObject<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_CreateObject</B> creates a new object. <I>hSession</I> is the session’s handle; <I>pTemplate</I> points to the object’s template; <I>ulCount</I> is the number of attributes in the template; <I>phObject</I> points to the location that receives the new object’s handle.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_CreateObject</B> cannot support the precise template supplied to it, it will fail and return without creating any object.</P>
<P ALIGN="JUSTIFY">If <B>C_CreateObject</B> is used to create a key object, the key object will have its <B>CKA_LOCAL</B> attribute set to FALSE.</P>
<P ALIGN="JUSTIFY">Only session objects can be created during a read-only session.  Only public objects can be created unless the normal user is logged in.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCOMPLETE, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE</P>
<P>  hData,</P>
<P>  hCertificate,</P>
<P>  hKey;</P>
<P>CK_OBJECT_CLASS</P>
<P>  dataClass = CKO_DATA,</P>
<P>  certificateClass = CKO_CERTIFICATE,</P>
<P>  keyClass = CKO_PUBLIC_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_RSA;</P>
<P>CK_CHAR application[] = {&quot;My Application&quot;};</P>
<P>CK_BYTE dataValue[] = {...};</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {...};</P>
<P>CK_BYTE certificateValue[] = {...};</P>
<P>CK_BYTE modulus[] = {...};</P>
<P>CK_BYTE exponent[] = {...};</P>
<P>CK_BYTE true = TRUE;</P>
<P>CK_ATTRIBUTE dataTemplate[] = {</P>
<P>  {CKA_CLASS, &amp;dataClass, sizeof(dataClass)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_APPLICATION, application, sizeof(application)},</P>
<P>  {CKA_VALUE, dataValue, sizeof(dataValue)}</P>
<P>};</P>
<P>CK_ATTRIBUTE certificateTemplate[] = {</P>
<P>  {CKA_CLASS, &amp;certificateClass, sizeof(certificateClass)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_VALUE, certificateValue, sizeof(certificateValue)}</P>
<P>};</P>
<P>CK_ATTRIBUTE keyTemplate[] = {</P>
<P>  {CKA_CLASS, &amp;keyClass, sizeof(keyClass)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>  {CKA_MODULUS, modulus, sizeof(modulus)},</P>
<P>  {CKA_PUBLIC_EXPONENT, exponent, sizeof(exponent)}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Create a data object */</P>
<P>rv = C_CreateObject(hSession, &amp;dataTemplate, 4, &amp;hData);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>/* Create a certificate object */</P>
<P>rv = C_CreateObject(</P>
<P>  hSession, &amp;certificateTemplate, 5, &amp;hCertificate);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>/* Create an RSA public key object */</P>
<P>rv = C_CreateObject(hSession, &amp;keyTemplate, 5, &amp;hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024122"><A NAME="_Toc323205454"><A NAME="_Toc323610884"><A NAME="_Toc383864891"><A NAME="_Toc385057919"><A NAME="_Toc405794739"><A NAME="_Toc410109077"></FONT><B><FONT FACE="Palatino">C_CopyObject</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_CopyObject)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hObject,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount,<BR>
  CK_OBJECT_HANDLE_PTR phNewObject<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_CopyObject</B> copies an object, creating a new object for the copy.  <I>hSession</I> is the session’s handle; <I>hObject</I> is the object’s handle; <I>pTemplate</I> points to the template for the new object; <I>ulCount</I> is the number of attributes in the template; <I>phNewObject</I> points to the location that receives the handle for the copy of the object.</P>
<P ALIGN="JUSTIFY">The template may specify new values for any attributes of the object that can ordinarily be modified (<I>e.g.</I>, in the course of copying a secret key, a key’s <B>CKA_EXTRACTABLE</B> attribute may be changed from TRUE to FALSE, but not the other way around.  If this change is made, the new key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute will have the value FALSE.  Similarly, the template may specify that the new key’s <B>CKA_SENSITIVE</B> attribute be TRUE; the new key will have the same value for its <B>CKA_ALWAYS_SENSITIVE</B> attribute as the original key).  It may also specify new values of the <B>CKA_TOKEN</B> and <B>CKA_PRIVATE</B> attributes (<I>e.g.</I>, to copy a session object to a token object).  If the template specifies a value of an attribute which is incompatible with other existing attributes of the object, the call fails with the return code CKR_TEMPLATE_INCONSISTENT.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_CopyObject</B> cannot support the precise template supplied to it, it will fail and return without creating any object.</P>
<P ALIGN="JUSTIFY">Only session objects can be created during a read-only session.  Only public objects can be created unless the normal user is logged in.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OBJECT_HANDLE_INVALID, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey, hNewKey;</P>
<P>CK_OBJECT_CLASS keyClass = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES;</P>
<P>CK_BYTE id[] = {...};</P>
<P>CK_BYTE keyValue[] = {...};</P>
<P>CK_BYTE false = FALSE;</P>
<P>CK_BYTE true = TRUE;</P>
<P>CK_ATTRIBUTE keyTemplate[] = {</P>
<P>  {CKA_CLASS, &amp;keyClass, sizeof(keyClass)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_TOKEN, &amp;false, sizeof(false)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_VALUE, keyValue, sizeof(keyValue)}</P>
<P>};</P>
<P>CK_ATTRIBUTE copyTemplate[] = {</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Create a DES secret key session object */</P>
<P>rv = C_CreateObject(hSession, &amp;keyTemplate, 5, &amp;hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  /* Create a copy which is a token object */</P>
<P>  rv = C_CopyObject(hSession, hKey, &amp;copyTemplate, 1, &amp;hNewKey);</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024123"><A NAME="_Toc323205455"><A NAME="_Toc323610885"><A NAME="_Toc383864892"><A NAME="_Toc385057920"><A NAME="_Toc405794740"><A NAME="_Toc410109078"></FONT><B><FONT FACE="Palatino">C_DestroyObject</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DestroyObject)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hObject<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DestroyObject</B> destroys an object.  <I>hSession</I> is the session’s handle;  and <I>hObject</I> is the object’s handle.</P>
<P ALIGN="JUSTIFY">Only session objects can be destroyed during a read-only session.  Only public objects can be destroyed unless the normal user is logged in.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OBJECT_HANDLE_INVALID, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TOKEN_WRITE_PROTECTED.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_GetObjectSize</B>.</P>

<UL>
<LI><A NAME="_Toc323024124"><A NAME="_Toc323205456"><A NAME="_Toc323610886"><A NAME="_Toc383864893"><A NAME="_Toc385057921"><A NAME="_Toc405794741"><A NAME="_Toc410109079"></FONT><B><FONT FACE="Palatino">C_GetObjectSize</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetObjectSize)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hObject,<BR>
  CK_ULONG_PTR pulSize<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetObjectSize</B> gets the size of an object in bytes.  <I>hSession</I> is the session’s handle; <I>hObject</I> is the object’s handle; <I>pulSize</I> points to the location that receives the size in bytes of the object.</P>
<P ALIGN="JUSTIFY">Cryptoki does not specify what the precise meaning of an object’s size is.  Intuitively, it is some measure of how much token memory the object takes up.  If an application deletes (say) a private object of size S, it might be reasonable to assume that the <I>ulFreePrivateMemory</I> field of the token’s <B>CK_TOKEN_INFO</B> structure increases by approximately S.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_INFORMATION_SENSITIVE, CKR_OBJECT_HANDLE_INVALID, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hObject;</P>
<P>CK_OBJECT_CLASS dataClass = CKO_DATA;</P>
<P>CK_CHAR application[] = {&quot;My Application&quot;};</P>
<P>CK_BYTE dataValue[] = {...};</P>
<P>CK_BYTE value[] = {...};</P>
<P>CK_BYTE true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;dataClass, sizeof(dataClass)},</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_APPLICATION, application, sizeof(application)},</P>
<P>  {CKA_VALUE, value, sizeof(value)}</P>
<P>};</P>
<P>CK_ULONG ulSize;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_CreateObject(hSession, &amp;template, 4, &amp;hObject);</P>
<P>if (rv == CKR_OK) {</P>
<P>  rv = C_GetObjectSize(hSession, hObject, &amp;ulSize);</P>
<P>  if (rv != CKR_INFORMATION_SENSITIVE) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>

<P>  rv = C_DestroyObject(hSession, hObject);</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024125"><A NAME="_Toc323205457"><A NAME="_Toc323610887"><A NAME="_Toc383864894"><A NAME="_Toc385057922"><A NAME="_Toc405794742"><A NAME="_Toc410109080"></FONT><B><FONT FACE="Palatino">C_GetAttributeValue</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetAttributeValue)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hObject,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GetAttributeValue</B> obtains the value of one or more attributes of an object.  <I>hSession</I> is the session’s handle; <I>hObject</I> is the object’s handle; <I>pTemplate</I> points to a template that specifies which attribute values are to be obtained, and receives the attribute values; <I>ulCount</I> is the number of attributes in the template.</P>
<P ALIGN="JUSTIFY">For each (<I>type</I>, <I>pValue</I>, <I>ulValueLen</I>) triple in the template, <B>C_GetAttributeValue</B> performs the following algorithm:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>If the specified attribute (<I>i.e.</I>, the attribute specified by the <I>type</I> field) for the object cannot be revealed because the object is sensitive or unextractable, then the <I>ulValueLen</I> field in that triple is modified to hold the value -1 (<I>i.e.</I>, when it is cast to a CK_LONG, it holds -1).</LI></P>
<P ALIGN="JUSTIFY"><LI>Otherwise, if the specified attribute for the object is invalid (the object does not possess such an attribute), then the <I>ulValueLen</I> field in that triple is modified to hold the value -1.</LI></P>
<P ALIGN="JUSTIFY"><LI>Otherwise, if the <I>pValue</I> field has the value NULL_PTR, then the <I>ulValueLen</I> field is modified to hold the exact length of the specified attribute for the object.</LI></P>
<P ALIGN="JUSTIFY"><LI>Otherwise, if the length specified in <I>ulValueLen</I> is large enough to hold the value of the specified attribute for the object, then that attribute is copied into the buffer located at <I>pValue</I>, and the <I>ulValueLen</I> field is modified to hold the exact length of the attribute.</LI></P>
<P ALIGN="JUSTIFY"><LI>Otherwise, the <I>ulValueLen</I> field is modified to hold the value -1.</LI></P></OL>

<P ALIGN="JUSTIFY">If case 1 applies to any of the requested attributes, then the call should return the value CKR_ATTRIBUTE_SENSITIVE.  If case 2 applies to any of the requested attributes, then the call should return the value CKR_ATTRIBUTE_TYPE_INVALID.  If case 5 applies to any of the requested attributes, then the call should return the value CKR_BUFFER_TOO_SMALL.  As usual, if more than one of these error codes is applicable, Cryptoki may return any of them.  Only if none of them applies to any of the requested attributes will CKR_OK be returned.</P>
<P ALIGN="JUSTIFY">Note that the error codes CKR_ATTRIBUTE_SENSITIVE, CKR_ATTRIBUTE_TYPE_INVALID, and CKR_BUFFER_TOO_SMALL  do not denote true errors for <B>C_GetAttributeValue</B>.  If a call to <B>C_GetAttributeValue</B> returns any of these three values, then the call must nonetheless have processed <I>every</I> attribute in the template supplied to <B>C_GetAttributeValue</B>.  Each attribute in the template whose value <I>can be</I> returned by the call to <B>C_GetAttributeValue</B> <I>will be</I> returned by the call to <B>C_GetAttributeValue</B>.</P>
<P>Return values: CKR_ATTRIBUTE_SENSITIVE, CKR_ATTRIBUTE_TYPE_INVALID, CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OBJECT_HANDLE_INVALID, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hObject;</P>
<P>CK_BYTE_PTR pModulus, pExponent;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_MODULUS, NULL_PTR, 0},</P>
<P>  {CKA_PUBLIC_EXPONENT, NULL_PTR, 0}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_GetAttributeValue(hSession, hObject, &amp;template, 2);</P>
<P>if (rv == CKR_OK) {</P>
<P>  pModulus = (CK_BYTE_PTR) malloc(template[0].ulValueLen);</P>
<P>  template[0].pValue = pModulus;</P>
<P>  /* template[0].ulValueLen was set by C_GetAttributeValue */</P>

<P>  pExponent = (CK_BYTE_PTR) malloc(template[1].ulValueLen);</P>
<P>  template[1].pValue = pExponent;</P>
<P>  /* template[1].ulValueLen was set by C_GetAttributeValue */</P>

<P>  rv = C_GetAttributeValue(hSession, hObject, &amp;template, 2);</P>
<P>  if (rv == CKR_OK) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>
<P>  free(pModulus);</P>
<P>  free(pExponent);</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024126"><A NAME="_Toc323205458"><A NAME="_Toc323610888"><A NAME="_Toc383864895"><A NAME="_Toc385057923"><A NAME="_Toc405794743"><A NAME="_Toc410109081"></FONT><B><FONT FACE="Palatino">C_SetAttributeValue</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SetAttributeValue)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hObject,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SetAttributeValue</B> modifies the value of one or more attributes of an object.  <I>hSession</I> is the session’s handle; <I>hObject</I> is the object’s handle; <I>pTemplate</I> points to a template that specifies which attribute values are to be modified and their new values; <I>ulCount</I> is the number of attributes in the template.</P>
<P ALIGN="JUSTIFY">Only session objects can be modified during a read-only session.</P>
<P ALIGN="JUSTIFY">The template may specify new values for any attributes of the object that can be modified.  If the template specifies a value of an attribute which is incompatible with other existing attributes of the object, the call fails with the return code CKR_TEMPLATE_INCONSISTENT.</P>
<P>Not all attributes can be modified; see Section 8.7 for more details.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OBJECT_HANDLE_INVALID, CKR_OK, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hObject;</P>
<P>CK_CHAR label[] = {&quot;New label&quot;};</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  CKA_LABEL, label, sizeof(label)</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_SetAttributeValue(hSession, hObject, &amp;template, 1);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323205460"><A NAME="_Toc323610889"><A NAME="_Toc383864896"><A NAME="_Toc385057924"><A NAME="_Toc405794744"><A NAME="_Toc410109082"></FONT><B><FONT FACE="Palatino">C_FindObjectsInit</A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_FindObjectsInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_FindObjectsInit</B> initializes a search for token and session objects that match a template. <I>hSession</I> is the session’s handle; <I>pTemplate</I> points to a search template that specifies the attribute values to match; <I>ulCount</I> is the number of attributes in the search template. The matching criterion is an exact byte-for-byte match with all attributes in the template. To find all objects, set <I>ulCount</I> to 0.</P>
<P ALIGN="JUSTIFY">After calling <B>C_FindObjectsInit</B>, the application may call <B>C_FindObjects</B> one or more times to obtain handles for objects matching the template, and then eventually call <B>C_FindObjectsFinal</B> to finish the active search operation.  At most one search operation may be active at a given time in a given session.</P>
<P ALIGN="JUSTIFY">The object search operation will only find objects that the session can view.  For example, an object search in an &quot;R/W Public Session&quot; will not find any private objects (even if one of the attributes in the search template specifies that the search is for private objects).</P>
<P ALIGN="JUSTIFY">If a search operation is active, and objects are created or destroyed which fit the search template for the active search operation, then those objects may or may not be found by the search operation.  Note that this means that, under these circumstances, the search operation may return invalid object handles.</P>
<P ALIGN="JUSTIFY">Even though <B>C_FindObjectsInit</B> can return the values CKR_ATTRIBUTE_TYPE_INVALID and CKR_ATTRIBUTE_VALUE_INVALID, it is not required to.  For example, if it is given a search template with nonexistent attributes in it, it can return CKR_ATTRIBUTE_TYPE_INVALID, or it can initialize a search operation which will match no objects and return CKR_OK.</P>
<P>Return values: CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_FindObjectsFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323205461"><A NAME="_Toc323610890"><A NAME="_Toc383864897"><A NAME="_Toc385057925"><A NAME="_Toc405794745"><A NAME="_Toc410109083"></FONT><B><FONT FACE="Palatino">C_FindObjects</A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_FindObjects)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE_PTR phObject,<BR>
  CK_ULONG ulMaxObjectCount,<BR>
  CK_ULONG_PTR pulObjectCount<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_FindObjects</B> continues a search for token and session objects that match a template, obtaining additional object handles. <I>hSession</I> is the session’s handle; <I>phObject</I> points to the location that receives the list (array) of additional object handles; <I>ulMaxObjectCount</I> is the maximum number of object handles to be returned; <I>pulObjectCount</I> points to the location that receives the actual number of object handles returned.</P>
<P ALIGN="JUSTIFY">If there are no more objects matching the template, then the location that <I>pulObjectCount</I> points to receives the value 0.</P>
<P ALIGN="JUSTIFY">The search must have been initialized with <B>C_FindObjectsInit</B>.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P>Example: see <B>C_FindObjectsFinal</B>.</P>

<UL>
<LI><A NAME="_Toc385057926"><A NAME="_Toc405794746"><A NAME="_Toc410109084"></FONT><B><FONT FACE="Palatino">C_FindObjectsFinal</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_FindObjectsFinal)(<BR>
  CK_SESSION_HANDLE hSession<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_FindObjectsFinal</B> terminates a search for token and session objects.  <I>hSession</I> is the session’s handle.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hObject;</P>
<P>CK_ULONG ulObjectCount;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_FindObjectsInit(hSession, NULL_PTR, 0);</P>
<P>assert(rv == CKR_OK);</P>
<P>while (1) {</P>
<P>  rv = C_FindObjects(hSession, &amp;hObject, 1, &amp;ulObjectCount);</P>
<P>  if (rv != CKR_OK || ulObjectCount == 0)</P>
<P>    break;</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>rv = C_FindObjectsFinal(hSession);</P>
<P>assert(rv == CKR_OK);</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc319287676"><A NAME="_Toc319313516"><A NAME="_Toc319313709"><A NAME="_Toc319315702"><A NAME="_Toc322855302"><A NAME="_Toc322945144"><A NAME="_Toc323000711"><A NAME="_Toc323024128"><A NAME="_Toc323205462"><A NAME="_Toc323610891"><A NAME="_Toc383864898"><A NAME="_Toc385057927"><A NAME="_Toc405794747"><A NAME="_Toc410109085"><A NAME="_Toc319287675"><A NAME="_Toc319313515"><A NAME="_Toc319313708"><A NAME="_Toc319315701"><A NAME="_Ref319839546">10.8.&#9;Encryption</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for encrypting data:<B> </P>

<UL>
</B><LI><A NAME="_Toc323024129"><A NAME="_Toc323205463"><A NAME="_Toc323610892"><A NAME="_Toc383864899"><A NAME="_Toc385057928"><A NAME="_Toc405794748"><A NAME="_Toc410109086"></FONT><B><FONT FACE="Palatino">C_EncryptInit<A NAME="encryptinit"></A></A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_EncryptInit</B> initializes an encryption operation. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the encryption mechanism; <I>hKey</I> is the handle of the encryption key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_ENCRYPT</B> attribute of the encryption key, which indicates whether the key supports encryption, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_EncryptInit</B>, the application can either call <B>C_Encrypt</B> to encrypt data in a single part; or call <B>C_EncryptUpdate</B> zero or more times, followed by <B>C_EncryptFinal</B>, to encrypt data in multiple parts.  The encryption operation is active until the application uses a call to <B>C_Encrypt</B> or <B>C_EncryptFinal</B> <I>to actually obtain</I> the final piece of ciphertext.  To process additional data (in single or multiple parts), the application must call <B>C_EncryptInit</B> again.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_EncryptFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024130"><A NAME="_Toc323205464"><A NAME="_Toc323610893"><A NAME="_Toc383864900"><A NAME="_Toc385057929"><A NAME="_Toc405794749"><A NAME="_Toc410109087"></FONT><B><FONT FACE="Palatino">C_Encrypt</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG ulDataLen,<BR>
  CK_BYTE_PTR pEncryptedData,<BR>
  CK_ULONG_PTR pulEncryptedDataLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Encrypt</B> encrypts single-part data. <I>hSession</I> is the session’s handle; <I>pData</I> points to the data; <I>ulDataLen</I> is the length in bytes of the data; <I>pEncryptedData</I> points to the location that receives the encrypted data; <I>pulEncryptedDataLen</I> points to the location that holds the length in bytes of the encrypted data.</P>
<B><P ALIGN="JUSTIFY">C_Encrypt</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The encryption operation must have been initialized with <B>C_EncryptInit</B>.  A call to <B>C_Encrypt</B> always terminates the active encryption operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the ciphertext.</P>
<P ALIGN="JUSTIFY">For some encryption mechanisms, the input plaintext data has certain length constraints (either because the mechanism can only encrypt relatively short pieces of plaintext, or because the mechanism’s input data must consist of an integral number of blocks).  If these constraints are not satisfied, then <B>C_Encrypt</B> will fail with return code CKR_DATA_LEN_RANGE.</P>
<P ALIGN="JUSTIFY">The plaintext and ciphertext can be in the same place, <I>i.e.</I>, it is OK if <I>pData</I> and <I>pEncryptedData</I> point to the same location.</P>
<P ALIGN="JUSTIFY">For most mechanisms, <B>C_Encrypt</B> is equivalent to a sequence of <B>C_EncryptUpdate</B> operations followed by <B>C_EncryptFinal</B>.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_EncryptFinal</B> for an example of similar functions.</P>

<UL>
<LI><A NAME="_Toc323024131"><A NAME="_Toc323205465"><A NAME="_Toc323610894"><A NAME="_Toc383864901"><A NAME="_Toc385057930"><A NAME="_Toc405794750"><A NAME="_Toc410109088"></FONT><B><FONT FACE="Palatino">C_EncryptUpdate</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_EncryptUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG_PTR pulEncryptedPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_EncryptUpdate</B> continues a multiple-part encryption operation, processing another data part. <I>hSession</I> is the session’s handle; <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part; <I>pEncryptedPart</I> points to the location that receives the encrypted data part; <I>pulEncryptedPartLen</I> points to the location that holds the length in bytes of the encrypted data part.</P>
<B><P ALIGN="JUSTIFY">C_EncryptUpdate</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The encryption operation must have been initialized with <B>C_EncryptInit</B>.  This function may be called any number of times in succession.  A call to <B>C_EncryptUpdate</B> which results in an error other than CKR_BUFFER_TOO_SMALL terminates the current encryption operation.</P>
<P ALIGN="JUSTIFY">The encryption operation must have been initialized with <B>C_EncryptInit</B>.  A call to <B>C_Encrypt</B> always terminates the active encryption operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the ciphertext.</P>
<P ALIGN="JUSTIFY">The plaintext and ciphertext can be in the same place, <I>i.e.</I>, it is OK if <I>pPart</I> and <I>pEncryptedPart</I> point to the same location.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_EncryptFinal.</P>

<UL>
</B><LI><A NAME="_Toc323024132"><A NAME="_Toc323205466"><A NAME="_Toc323610895"><A NAME="_Toc383864902"><A NAME="_Toc385057931"><A NAME="_Toc405794751"><A NAME="_Toc410109089"></FONT><B><FONT FACE="Palatino">C_EncryptFinal</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_EncryptFinal)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pLastEncryptedPart,<BR>
  CK_ULONG_PTR pulLastEncryptedPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_EncryptFinal</B> finishes a multiple-part encryption operation. <I>hSession</I> is the session’s handle; <I>pLastEncryptedPart</I> points to the location that receives the last encrypted data part, if any; <I>pulLastEncryptedPartLen</I> points to the location that holds the length of the last encrypted data part.</P>
<B><P ALIGN="JUSTIFY">C_EncryptFinal</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The encryption operation must have been initialized with <B>C_EncryptInit</B>.  A call to <B>C_EncryptFinal</B> always terminates the active encryption operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the ciphertext.</P>
<P ALIGN="JUSTIFY">For some multi-part encryption mechanisms, the input plaintext data has certain length constraints, because the mechanism’s input data must consist of an integral number of blocks.  If these constraints are not satisfied, then <B>C_EncryptFinal</B> will fail with return code CKR_DATA_LEN_RANGE.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define PLAINTEXT_BUF_SZ 200</P>
<P>#define CIPHERTEXT_BUF_SZ 256</P>

<P>CK_ULONG firstPieceLen, secondPieceLen;</P>
<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES_CBC_PAD, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_BYTE data[PLAINTEXT_BUF_SZ];</P>
<P>CK_BYTE encryptedData[CIPHERTEXT_BUF_SZ];</P>
<P>CK_ULONG ulEncryptedData1Len;</P>
<P>CK_ULONG ulEncryptedData2Len;</P>
<P>CK_ULONG ulEncryptedData3Len;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>firstPieceLen = 90;</P>
<P>secondPieceLen = PLAINTEXT_BUF_SZ-firstPieceLen;</P>
<P>rv = C_EncryptInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  /* Encrypt first piece */</P>
<P>  ulEncryptedData1Len = sizeof(encryptedData);</P>
<P>  rv = C_EncryptUpdate(</P>
<P>    hSession,</P>
<P>    &amp;data[0], firstPieceLen,</P>
<P>    &amp;encryptedData[0], &amp;ulEncryptedData1Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>     .</P>
<P>     .</P>
<P>     .</P>
<P>  }</P>

<P>  /* Encrypt second piece */</P>
<P>  ulEncryptedData2Len = sizeof(encryptedData)-ulEncryptedData1Len;</P>
<P>  rv = C_EncryptUpdate(</P>
<P>    hSession,</P>
<P>    &amp;data[firstPieceLen], secondPieceLen,</P>
<P>    &amp;encryptedData[ulEncryptedData1Len], &amp;ulEncryptedData2Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>     .</P>
<P>     .</P>
<P>     .</P>
<P>  }</P>

<P>  /* Get last little encrypted bit */</P>
<P>  ulEncryptedData3Len =</P>
<P>    sizeof(encryptedData)-ulEncryptedData1Len-ulEncryptedData2Len;</P>
<P>  rv = C_EncryptFinal(</P>
<P>    hSession,</P>
<P>    &amp;encryptedData[ulEncryptedData1Len+ulEncryptedData2Len],</P>
<P>    &amp;ulEncryptedData3Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>     .</P>
<P>     .</P>
<P>     .</P>
<P>  }</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057932"><A NAME="_Toc405794752"><A NAME="_Toc410109090">10.9.&#9;Decryption functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323024133"><A NAME="_Toc323205467"><A NAME="_Toc323610896"><A NAME="_Toc383864903">Cryptoki provides the following functions for decrypting data:<B> </P>

<UL>
</B><LI><A NAME="_Toc385057933"><A NAME="_Toc405794753"><A NAME="_Toc410109091"></FONT><B><FONT FACE="Palatino">C_DecryptInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DecryptInit</B> initializes a decryption operation. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the decryption mechanism; <I>hKey</I> is the handle of the decryption key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_DECRYPT</B> attribute of the decryption key, which indicates whether the key supports decryption, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_DecryptInit</B>, the application can either call <B>C_Decrypt</B> to decrypt data in a single part; or call <B>C_DecryptUpdate</B> zero or more times, followed by <B>C_DecryptFinal</B>, to decrypt data in multiple parts.  The decryption operation is active until the application uses a call to <B>C_Decrypt</B> or <B>C_DecryptFinal</B> <I>to actually obtain</I> the final piece of plaintext.  To process additional data (in single or multiple parts), the application must call <B>C_DecryptInit</B> again</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_DecryptFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024134"><A NAME="_Toc323205468"><A NAME="_Toc323610897"><A NAME="_Toc383864904"><A NAME="_Toc385057934"><A NAME="_Toc405794754"><A NAME="_Toc410109092"></FONT><B><FONT FACE="Palatino">C_Decrypt</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pEncryptedData,<BR>
  CK_ULONG ulEncryptedDataLen,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG_PTR pulDataLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Decrypt</B> decrypts encrypted data in a single part. <I>hSession</I> is the session’s handle; <I>pEncryptedData</I> points to the encrypted data; <I>ulEncryptedDataLen</I> is the length of the encrypted data; <I>pData</I> points to the location that receives the recovered data; <I>pulDataLen</I> points to the location that holds the length of the recovered data.</P>
<B><P ALIGN="JUSTIFY">C_Decrypt</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The decryption operation must have been initialized with <B>C_DecryptInit</B>.  A call to <B>C_Decrypt</B> always terminates the active decryption operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the plaintext.</P>
<P ALIGN="JUSTIFY">The ciphertext and plaintext can be in the same place, <I>i.e.</I>, it is OK if <I>pEncryptedData</I> and <I>pData</I> point to the same location.</P>
<P ALIGN="JUSTIFY">If the input ciphertext data cannot be decrypted because it has an inappropriate length, then either CKR_ENCRYPTED_DATA_INVALID or CKR_ENCRYPTED_DATA_LEN_RANGE may be returned.</P>
<P ALIGN="JUSTIFY">For most mechanisms, <B>C_Decrypt</B> is equivalent to a sequence of <B>C_DecryptUpdate</B> operations followed by <B>C_DecryptFinal</B>.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_ENCRYPTED_DATA_INVALID, CKR_ENCRYPTED_DATA_LEN_RANGE, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc323024135"><A NAME="_Toc323205469"><A NAME="_Toc323610898"><A NAME="_Toc383864905">Example: see <B>C_DecryptFinal</B> for an example of similar functions.</P>

<UL>
<LI><A NAME="_Toc385057935"><A NAME="_Toc405794755"><A NAME="_Toc410109093"></FONT><B><FONT FACE="Palatino">C_DecryptUpdate</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DecryptUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG ulEncryptedPartLen,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG_PTR pulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DecryptUpdate</B> continues a multiple-part decryption operation, processing another encrypted data part. <I>hSession</I> is the session’s handle; <I>pEncryptedPart</I> points to the encrypted data part; <I>ulEncryptedPartLen</I> is the length of the encrypted data part; <I>pPart</I> points to the location that receives the recovered data part; <I>pulPartLen</I> points to the location that holds the length of the recovered data part.</P>
<B><P ALIGN="JUSTIFY"><A NAME="_Toc319287678">C_DecryptUpdate</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The decryption operation must have been initialized with <B>C_DecryptInit</B>.  This function may be called any number of times in succession.  A call to <B>C_DecryptUpdate</B> which results in an error other than CKR_BUFFER_TOO_SMALL terminates the current decryption operation.</P>
<P ALIGN="JUSTIFY">The ciphertext and plaintext can be in the same place, <I>i.e.</I>, it is OK if <I>pEncryptedPart</I> and <I>pPart</I> point to the same location.</P>
<P></A>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_ENCRYPTED_DATA_INVALID, CKR_ENCRYPTED_DATA_LEN_RANGE, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:  See <B>C_DecryptFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024136"><A NAME="_Toc323205470"><A NAME="_Toc323610899"><A NAME="_Toc383864906"><A NAME="_Toc385057936"><A NAME="_Toc405794756"><A NAME="_Toc410109094"></FONT><B><FONT FACE="Palatino">C_DecryptFinal</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DecryptFinal)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pLastPart,<BR>
  CK_ULONG_PTR pulLastPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DecryptFinal</B> finishes a multiple-part decryption operation. <I>hSession</I> is the session’s handle; <I>pLastPart</I> points to the location that receives the last recovered data part, if any; <I>pulLastPartLen</I> points to the location that holds the length of the last recovered data part.</P>
<B><P ALIGN="JUSTIFY">C_DecryptFinal</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The decryption operation must have been initialized with <B>C_DecryptInit</B>.  A call to <B>C_DecryptFinal</B> always terminates the active decryption operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the plaintext.</P>
<P ALIGN="JUSTIFY">If the input ciphertext data cannot be decrypted because it has an inappropriate length, then either CKR_ENCRYPTED_DATA_INVALID or CKR_ENCRYPTED_DATA_LEN_RANGE may be returned.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_ENCRYPTED_DATA_INVALID, CKR_ENCRYPTED_DATA_LEN_RANGE, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287679"><A NAME="_Toc319313519"><A NAME="_Toc319313712"><A NAME="_Toc319315705"><A NAME="_Toc322855303"><A NAME="_Toc322945145"><A NAME="_Toc323000712"><A NAME="_Toc323024137"><A NAME="_Toc323205471"><A NAME="_Toc323610900"><A NAME="_Toc383864907">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define CIPHERTEXT_BUF_SZ 256</P>
<P>#define PLAINTEXT_BUF_SZ 256</P>

<P>CK_ULONG firstEncryptedPieceLen, secondEncryptedPieceLen;</P>
<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES_CBC_PAD, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_BYTE data[PLAINTEXT_BUF_SZ];</P>
<P>CK_BYTE encryptedData[CIPHERTEXT_BUF_SZ];</P>
<P>CK_ULONG ulData1Len, ulData2Len, ulData3Len;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>firstEncryptedPieceLen = 90;</P>
<P>secondEncryptedPieceLen = CIPHERTEXT_BUF_SZ-firstEncryptedPieceLen;</P>
<P>rv = C_DecryptInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  /* Decrypt first piece */</P>
<P>  ulData1Len = sizeof(data);</P>
<P>  rv = C_DecryptUpdate(</P>
<P>    hSession,</P>
<P>    &amp;encryptedData[0], firstEncryptedPieceLen,</P>
<P>    &amp;data[0], &amp;ulData1Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>

<P>  /* Decrypt second piece */</P>
<P>  ulData2Len = sizeof(data)-ulData1Len;</P>
<P>  rv = C_DecryptUpdate(</P>
<P>    hSession,</P>
<P>    &amp;encryptedData[firstEncryptedPieceLen],</P>
<P>    secondEncryptedPieceLen,</P>
<P>    &amp;data[ulData1Len], &amp;ulData2Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>  }</P>

<P>  /* Get last little decrypted bit */</P>
<P>  ulData3Len = sizeof(data)-ulData1Len-ulData2Len;</P>
<P>  rv = C_DecryptFinal(</P>
<P>    hSession,</P>
<P>    &amp;data[ulData1Len+ulData2Len], &amp;ulData3Len);</P>
<P>  if (rv != CKR_OK) {</P>
<P>     .</P>
<P>     .</P>
<P>     .</P>
<P>  }</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057937"><A NAME="_Toc405794757"><A NAME="_Toc410109095">10.10.&#9;Message digesting</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for digesting data:<B> </P>

<UL>
</B><LI><A NAME="_Toc323024138"><A NAME="_Toc323205472"><A NAME="_Toc323610901"><A NAME="_Toc383864908"><A NAME="_Toc385057938"><A NAME="_Toc405794758"><A NAME="_Toc410109096"></FONT><B><FONT FACE="Palatino">C_DigestInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DigestInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DigestInit</B> initializes a message-digesting operation. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the digesting mechanism.</P>
<P ALIGN="JUSTIFY">After calling <B>C_DigestInit</B>, the application can either call <B>C_Digest</B> to digest data in a single part; or call <B>C_DigestUpdate</B> zero or more times, followed by <B>C_DigestFinal</B>, to digest data in multiple parts.  The message-digesting operation is active until the application uses a call to <B>C_Digest</B> or <B>C_DigestFinal</B> <I>to actually obtain</I> the final piece of ciphertext.  To process additional data (in single or multiple parts), the application must call <B>C_DigestInit</B> again.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_DigestFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024139"><A NAME="_Toc323205473"><A NAME="_Toc323610902"><A NAME="_Toc383864909"><A NAME="_Toc385057939"><A NAME="_Toc405794759"><A NAME="_Toc410109097"></FONT><B><FONT FACE="Palatino">C_Digest</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Digest)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG ulDataLen,<BR>
  CK_BYTE_PTR pDigest,<BR>
  CK_ULONG_PTR pulDigestLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Digest</B> digests data in a single part. <I>hSession</I> is the session’s handle, <I>pData</I> points to the data; <I>ulDataLen</I> is the length of the data; <I>pDigest</I> points to the location that receives the message digest; <I>pulDigestLen</I> points to the location that holds the length of the message digest.</P>
<B><P ALIGN="JUSTIFY">C_Digest</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The digest operation must have been initialized with <B>C_DigestInit</B>.  A call to <B>C_Digest</B> always terminates the active digest operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the message digest.</P>
<P ALIGN="JUSTIFY">The input data and digest output can be in the same place, <I>i.e.</I>, it is OK if <I>pData</I> and <I>pDigest</I> point to the same location.</P>
<B><P ALIGN="JUSTIFY">C_Digest</B> is equivalent to a sequence of <B>C_DigestUpdate</B> operations followed by <B>C_DigestFinal</B>.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_DigestFinal</B> for an example of similar functions.</P>

<UL>
<LI><A NAME="_Toc323024140"><A NAME="_Toc323205474"><A NAME="_Toc323610903"><A NAME="_Toc383864910"><A NAME="_Toc385057940"><A NAME="_Toc405794760"><A NAME="_Toc410109098"></FONT><B><FONT FACE="Palatino">C_DigestUpdate</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DigestUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DigestUpdate</B> continues a multiple-part message-digesting operation, processing another data part. <I>hSession</I> is the session’s handle, <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287681">The message-digesting operation must have been initialized with <B>C_DigestInit</B>. Calls to this function and <B>C_DigestKey</B> may be interspersed any number of times in any order.  A call to <B>C_DigestUpdate</B> which results in an error terminates the current digest operation.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY"></A>Example:  see <B>C_DigestFinal</B>.</P>

<UL>
<LI><A NAME="_Toc385057941"><A NAME="_Toc405794761"><A NAME="_Toc410109099"><A NAME="_Toc323024141"><A NAME="_Toc323205475"><A NAME="_Toc323610904"><A NAME="_Toc383864911"></FONT><B><FONT FACE="Palatino">C_DigestKey</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DigestKey)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DigestKey</B> continues a multiple-part message-digesting operation by digesting the value of a secret key.  <I>hSession</I> is the session’s handle; <I>hKey</I> is the handle of the secret key to be digested.</P>
<P ALIGN="JUSTIFY">The message-digesting operation must have been initialized with <B>C_DigestInit</B>.  Calls to this function and <B>C_DigestUpdate</B> may be interspersed any number of times in any order.</P>
<P ALIGN="JUSTIFY">If the value of the supplied key cannot be digested purely for some reason related to its length, <B>C_DigestKey</B> should return the error code CKR_KEY_SIZE_RANGE.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_HANDLE_INVALID, CKR_KEY_INDIGESTIBLE, CKR_KEY_SIZE_RANGE, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_DigestFinal</B>.</P>

<UL>
<LI><A NAME="_Toc385057942"><A NAME="_Toc405794762"><A NAME="_Toc410109100"></FONT><B><FONT FACE="Palatino">C_DigestFinal</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DigestFinal)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pDigest,<BR>
  CK_ULONG_PTR pulDigestLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DigestFinal</B> finishes a multiple-part message-digesting operation, returning the message digest. <I>hSession</I> is the session’s handle; <I>pDigest</I> points to the location that receives the message digest; <I>pulDigestLen</I> points to the location that holds the length of the message digest.</P>
<B><P ALIGN="JUSTIFY">C_DigestFinal</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The digest operation must have been initialized with <B>C_DigestInit</B>.  A call to <B>C_DigestFinal</B> always terminates the active digest operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the message digest.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc319287682"><A NAME="_Toc319313522"><A NAME="_Toc319313715"><A NAME="_Toc319315708">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_MD5, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE data[] = {...};</P>
<P>CK_BYTE digest[16];</P>
<P>CK_ULONG ulDigestLen;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_DigestInit(hSession, &amp;mechanism);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>rv = C_DigestUpdate(hSession, data, sizeof(data));</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>rv = C_DigestKey(hSession, hKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>ulDigestLen = sizeof(digest);</P>
<P>rv = C_DigestFinal(hSession, digest, &amp;ulDigestLen);</P>
<P>.</P>
<P>.</P>
<P>.</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855304"><A NAME="_Toc322945146"><A NAME="_Toc323000713"><A NAME="_Toc323024142"><A NAME="_Toc323205476"><A NAME="_Toc323610905"><A NAME="_Toc383864912"><A NAME="_Toc385057943"><A NAME="_Toc405794763"><A NAME="_Toc410109101">10.11.&#9;Sign</A></A></A></A></A></A></A></A></A></A></A>ing and MACing functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for signing data (for the purposes of Cryptoki, these operations also encompass message authentication codes):<B> </P>

<UL>
</B><LI><A NAME="_Toc323024143"><A NAME="_Toc323205477"><A NAME="_Toc323610906"><A NAME="_Toc383864913"><A NAME="_Toc385057944"><A NAME="_Toc405794764"><A NAME="_Toc410109102"></FONT><B><FONT FACE="Palatino">C_SignInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignInit</B> initializes a signature operation, where the signature is an appendix to the data. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the signature mechanism; <I>hKey</I> is the handle of the signature key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_SIGN</B> attribute of the signature key, which indicates whether the key supports signatures with appendix, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_SignInit</B>, the application can either call <B>C_Sign</B> to sign in a single part; or call <B>C_SignUpdate</B> one or more times, followed by <B>C_SignFinal,</B> to sign data in multiple parts.  The signature operation is active until the application uses a call to <B>C_Sign</B> or <B>C_SignFinal</B> <I>to actually obtain</I> the signature.  To process additional data (in single or multiple parts), the application must call <B>C_SignInit</B> again.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED,CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_SignFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024144"><A NAME="_Toc323205478"><A NAME="_Toc323610907"><A NAME="_Toc383864914"><A NAME="_Toc385057945"><A NAME="_Toc405794765"><A NAME="_Toc410109103"></FONT><B><FONT FACE="Palatino">C_Sign</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Sign)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG ulDataLen,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG_PTR pulSignatureLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Sign</B> signs data in a single part, where the signature is an appendix to the data. <I>hSession</I> is the session’s handle; <I>pData</I> points to the data; <I>ulDataLen</I> is the length of the data; <I>pSignature</I> points to the location that receives the signature; <I>pulSignatureLen</I> points to the location that holds the length of the signature.</P>
<B><P ALIGN="JUSTIFY">C_Sign</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The signing operation must have been initialized with <B>C_SignInit</B>.  A call to <B>C_Sign</B> always terminates the active signing operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the signature.</P>
<P ALIGN="JUSTIFY">For most mechanisms, <B>C_Sign</B> is equivalent to a sequence of <B>C_SignUpdate</B> operations followed by <B>C_SignFinal</B>.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_SignFinal</B> for an example of similar functions.</P>

<UL>
<LI><A NAME="_Toc323024145"><A NAME="_Toc323205479"><A NAME="_Toc323610908"><A NAME="_Toc383864915"><A NAME="_Toc385057946"><A NAME="_Toc405794766"><A NAME="_Toc410109104"></FONT><B><FONT FACE="Palatino">C_SignUpdate</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignUpdate</B> continues a multiple-part signature operation, processing another data part. <I>hSession</I> is the session’s handle, <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part.</P>
<P ALIGN="JUSTIFY">The signature operation must have been initialized with <B>C_SignInit</B>. This function may be called any number of times in succession.  A call to <B>C_SignUpdate</B> which results in an error terminates the current signature operation.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_SignFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024146"><A NAME="_Toc323205480"><A NAME="_Toc323610909"><A NAME="_Toc383864916"><A NAME="_Toc385057947"><A NAME="_Toc405794767"><A NAME="_Toc410109105"></FONT><B><FONT FACE="Palatino">C_SignFinal</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignFinal)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG_PTR pulSignatureLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignFinal</B> finishes a multiple-part signature operation, returning the signature. <I>hSession</I> is the session’s handle; <I>pSignature</I> points to the location that receives the signature; <I>pulSignatureLen</I> points to the location that holds the length of the signature.</P>
<B><P ALIGN="JUSTIFY">C_SignFinal</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The signing operation must have been initialized with <B>C_SignInit</B>.  A call to <B>C_SignFinal</B> always terminates the active signing operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the signature.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example: </P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES_MAC, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE data[] = {...};</P>
<P>CK_BYTE mac[4];</P>
<P>CK_ULONG ulMacLen;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_SignInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  rv = C_SignUpdate(hSession, data, sizeof(data));</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>  ulMacLen = sizeof(mac);</P>
<P>  rv = C_SignFinal(hSession, mac, &amp;ulMacLen);</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024147"><A NAME="_Toc323205481"><A NAME="_Toc323610910"><A NAME="_Toc383864917"><A NAME="_Toc385057948"><A NAME="_Toc405794768"><A NAME="_Toc410109106"></FONT><B><FONT FACE="Palatino">C_SignRecoverInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignRecoverInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignRecoverInit</B> initializes a signature operation, where the data can be recovered from the signature. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the structure that specifies the signature mechanism; <I>hKey</I> is the handle of the signature key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_SIGN_RECOVER </B>attribute of the signature key, which indicates whether the key supports signatures where the data can be recovered from the signature, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_SignRecoverInit</B>, the application may call <B>C_SignRecover</B> to sign in a single part.  The signature operation is active until the application uses a call to <B>C_SignRecover</B> <I>to actually obtain</I> the signature.  To process additional data in a single part, the application must call <B>C_SignRecoverInit</B> again.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_SignRecover</B>.</P>

<UL>
<LI><A NAME="_Toc323024148"><A NAME="_Toc323205482"><A NAME="_Toc323610911"><A NAME="_Toc383864918"><A NAME="_Toc385057949"><A NAME="_Toc405794769"><A NAME="_Toc410109107"></FONT><B><FONT FACE="Palatino">C_SignRecover</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignRecover)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG ulDataLen,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG_PTR pulSignatureLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignRecover</B> signs data in a single operation, where the data can be recovered from the signature. <I>hSession</I> is the session’s handle; <I>pData</I> points to the data; <I>uLDataLen</I> is the length of the data; <I>pSignature</I> points to the location that receives the signature; <I>pulSignatureLen</I> points to the location that holds the length of the signature.</P>
<B><P ALIGN="JUSTIFY">C_SignRecover</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The signing operation must have been initialized with <B>C_SignRecoverInit</B>.  A call to <B>C_SignRecover</B> always terminates the active signing operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the signature.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_RSA_9796, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE data[] = {...};</P>
<P>CK_BYTE signature[128];</P>
<P>CK_ULONG ulSignatureLen;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_SignRecoverInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  ulSignatureLen = sizeof(signature);</P>
<P>  rv = C_SignRecover(</P>
<P>    hSession, data, sizeof(data), signature, &amp;ulSignatureLen);</P>
<P>  if (rv == CKR_OK) {</P>
<P>     .</P>
<P>     .</P>
<P>     .</P>
<P>  }</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057950"><A NAME="_Toc405794770"><A NAME="_Toc410109108">10.12.&#9;Functions for verifying signatures and MACs</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for verifying signatures on data (for the purposes of Cryptoki, these operations also encompass message authentication codes):<B> </P>

<UL>
</B><LI><A NAME="_Toc323024149"><A NAME="_Toc323205483"><A NAME="_Toc323610912"><A NAME="_Toc383864919"><A NAME="_Toc385057951"><A NAME="_Toc405794771"><A NAME="_Toc410109109"></FONT><B><FONT FACE="Palatino">C_VerifyInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_VerifyInit</B> initializes a verification operation, where the signature is an appendix to the data. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the structure that specifies the verification mechanism; <I>hKey</I> is the handle of the verification key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_VERIFY</B> attribute of the verification key, which indicates whether the key supports verification where the signature is an appendix to the data, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_VerifyInit</B>, the application can either call <B>C_Verify</B> to verify a signature on data in a single part; or call <B>C_VerifyUpdate</B> one or more times, followed by <B>C_VerifyFinal,</B> to verify a signature on data in multiple parts.  The verification operation is active until the application calls <B>C_Verify</B> or <B>C_VerifyFinal</B>. To process additional data (in single or multiple parts), the application must call <B>C_VerifyInit</B> again.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_VerifyFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024150"><A NAME="_Toc323205484"><A NAME="_Toc323610913"><A NAME="_Toc383864920"><A NAME="_Toc385057952"><A NAME="_Toc405794772"><A NAME="_Toc410109110"></FONT><B><FONT FACE="Palatino">C_Verify</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_Verify)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG ulDataLen,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG ulSignatureLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_Verify</B> verifies a signature in a single-part operation, where the signature is an appendix to the data. <I>hSession</I> is the session’s handle; <I>pData</I> points to the data; <I>ulDataLen</I> is the length of the data; <I>pSignature</I> points to the signature; <I>ulSignatureLen</I> is the length of the signature.</P>
<P ALIGN="JUSTIFY">The verification operation must have been initialized with <B>C_VerifyInit</B>.  A call to <B>C_Verify</B> always terminates the active verification operation.</P>
<P ALIGN="JUSTIFY">A successful call to <B>C_Verify</B> should return either the value CKR_OK (indicating that the supplied signature is valid) or CKR_SIGNATURE_INVALID (indicating that the supplied signature is invalid).  If the signature can be seen to be invalid purely on the basis of its length, then CKR_SIGNATURE_LEN_RANGE should be returned.  In any of these cases, the active signing operation is terminated.</P>
<P ALIGN="JUSTIFY">For most mechanisms, <B>C_Verify</B> is equivalent to a sequence of <B>C_VerifyUpdate</B> operations followed by <B>C_VerifyFinal</B>.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SIGNATURE_INVALID, CKR_SIGNATURE_LEN_RANGE.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_VerifyFinal</B> for an example of similar functions.</P>

<UL>
<LI><A NAME="_Toc323024151"><A NAME="_Toc323205485"><A NAME="_Toc323610914"><A NAME="_Toc383864921"><A NAME="_Toc385057953"><A NAME="_Toc405794773"><A NAME="_Toc410109111"></FONT><B><FONT FACE="Palatino">C_VerifyUpdate</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_VerifyUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_VerifyUpdate</B> continues a multiple-part verification operation, processing another data part. <I>hSession</I> is the session’s handle, <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part.</P>
<P ALIGN="JUSTIFY">The verification operation must have been initialized with <B>C_VerifyInit</B>. This function may be called any number of times in succession.  A call to <B>C_VerifyUpdate</B> which results in an error terminates the current verification operation.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_VerifyFinal</B>.</P>

<UL>
<LI><A NAME="_Toc323024152"><A NAME="_Toc323205486"><A NAME="_Toc323610915"><A NAME="_Toc383864922"><A NAME="_Toc385057954"><A NAME="_Toc405794774"><A NAME="_Toc410109112"></FONT><B><FONT FACE="Palatino">C_VerifyFinal</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_VerifyFinal)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG ulSignatureLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_VerifyFinal</B> finishes a multiple-part verification operation, checking the signature. <I>hSession</I> is the session’s handle; <I>pSignature</I> points to the signature; <I>ulSignatureLen</I> is the length of the signature.</P>
<P ALIGN="JUSTIFY">The verification operation must have been initialized with <B>C_VerifyInit</B>.  A call to <B>C_VerifyFinal</B> always terminates the active verification operation.</P>
<P ALIGN="JUSTIFY">A successful call to <B>C_VerifyFinal</B> should return either the value CKR_OK (indicating that the supplied signature is valid) or CKR_SIGNATURE_INVALID (indicating that the supplied signature is invalid).  If the signature can be seen to be invalid purely on the basis of its length, then CKR_SIGNATURE_LEN_RANGE should be returned.  In any of these cases, the active verifying operation is terminated.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SIGNATURE_INVALID, CKR_SIGNATURE_LEN_RANGE.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES_MAC, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE data[] = {...};</P>
<P>CK_BYTE mac[4];</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_VerifyInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  rv = C_VerifyUpdate(hSession, data, sizeof(data));</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>  rv = C_VerifyFinal(hSession, mac, sizeof(mac));</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024153"><A NAME="_Toc323205487"><A NAME="_Toc323610916"><A NAME="_Toc383864923"><A NAME="_Toc385057955"><A NAME="_Toc405794775"><A NAME="_Toc410109113"></FONT><B><FONT FACE="Palatino">C_VerifyRecoverInit</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_VerifyRecoverInit)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_VerifyRecoverInit</B> initializes a signature verification operation, where the data is recovered from the signature. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the structure that specifies the verification mechanism; <I>hKey</I> is the handle of the verification key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_VERIFY_RECOVER</B> attribute of the verification key, which indicates whether the key supports verification where the data is recovered from the signature, must be TRUE.</P>
<P ALIGN="JUSTIFY">After calling <B>C_VerifyRecoverInit</B>, the application may call <B>C_VerifyRecover</B> to verify a signature on data in a single part.  The verification operation is active until the application uses a call to <B>C_VerifyRecover</B> <I>to actually obtain</I> the recovered message.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_FUNCTION_NOT_PERMITTED, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:  see <B>C_VerifyRecover</B>.</P>

<UL>
<LI><A NAME="_Toc323024154"><A NAME="_Toc323205488"><A NAME="_Toc323610917"><A NAME="_Toc383864924"><A NAME="_Toc385057956"><A NAME="_Toc405794776"><A NAME="_Toc410109114"></FONT><B><FONT FACE="Palatino">C_VerifyRecover</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_VerifyRecover)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pSignature,<BR>
  CK_ULONG ulSignatureLen,<BR>
  CK_BYTE_PTR pData,<BR>
  CK_ULONG_PTR pulDataLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_VerifyRecover</B> verifies a signature in a single-part operation, where the data is recovered from the signature. <I>hSession</I> is the session’s handle; <I>pSignature</I> points to the signature; <I>ulSignatureLen</I> is the length of the signature; <I>pData </I>points to the location that receives the recovered data; and <I>pulDataLen</I> points to the location that holds the length of the recovered data.</P>
<B><P ALIGN="JUSTIFY"><A NAME="_Toc319287684">C_VerifyRecover</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The verification operation must have been initialized with <B>C_VerifyRecoverInit</B>.  A call to <B>C_VerifyRecover</B> always terminates the active verification operation unless it returns CKR_BUFFER_TOO_SMALL or is a successful call (<I>i.e.</I>, one which returns CKR_OK) to determine the length of the buffer needed to hold the recovered data.</P>
<P ALIGN="JUSTIFY">A successful call to <B>C_VerifyRecover</B> should return either the value CKR_OK (indicating that the supplied signature is valid) or CKR_SIGNATURE_INVALID (indicating that the supplied signature is invalid).  If the signature can be seen to be invalid purely on the basis of its length, then CKR_SIGNATURE_LEN_RANGE should be returned.  The return codes CKR_SIGNATURE_INVALID and CKR_SIGNATURE_LEN_RANGE have a higher priority than the return code CKR_BUFFER_TOO_SMALL, <I>i.e.</I>, if <B>C_VerifyRecover</B> is supplied with an invalid signature, it will never return CKR_BUFFER_TOO_SMALL.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_INVALID, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SIGNATURE_LEN_RANGE, CKR_SIGNATURE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>C<A NAME="_Ref320412176"></A>K_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_RSA_9796, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE data[] = {...};</P>
<P>CK_ULONG ulDataLen;</P>
<P>CK_BYTE signature[128];</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_VerifyRecoverInit(hSession, &amp;mechanism, hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  ulDataLen = sizeof(data);</P>
<P>  rv = C_VerifyRecover(</P>
<P>    hSession, signature, sizeof(signature), data, &amp;ulDataLen);</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384459019"><A NAME="_Ref384459262"><A NAME="_Ref384486862"><A NAME="_Toc385057957"><A NAME="_Toc405794777"><A NAME="_Toc410109115">10.13.&#9;Dual-function cryptographic functions</A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions to perform two cryptographic operations &quot;simultaneously&quot; within a session.  These functions are provided so as to avoid unnecessarily passing data back and forth to and from a token.</P>

<UL>
<LI><A NAME="_Toc385057958"><A NAME="_Toc405794778"><A NAME="_Toc410109116"></FONT><B><FONT FACE="Palatino">C_DigestEncryptUpdate</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DigestEncryptUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG_PTR pulEncryptedPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DigestEncryptUpdate</B> continues multiple-part digest and encryption operations, processing another data part. <I>hSession</I> is the session’s handle; <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part; <I>pEncryptedPart</I> points to the location that receives the digested and encrypted data part; <I>pulEncryptedPartLen</I> points to the location that holds the length of the encrypted data part.</P>
<B><P ALIGN="JUSTIFY">C_DigestEncryptUpdate</B> uses the convention described in Section 10.2 on producing output.  If a <B>C_DigestEncryptUpdate</B> call does not produce encrypted output (because an error occurs, or because <I>pEncryptedPart</I> has the value NULL_PTR, or because <I>pulEncryptedPartLen</I> is too small to hold the entire encrypted part output), then no plaintext is passed to the active digest operation.</P>
<P ALIGN="JUSTIFY">Digest and encryption operations must both be active (they must have been initialized with <B>C_DigestInit</B> and <B>C_EncryptInit,</B> respectively).  This function may be called any number of times in succession, and may be interspersed with <B>C_DigestUpdate</B>, <B>C_DigestKey</B>, and <B>C_EncryptUpdate</B> calls (it would be somewhat unusual to intersperse calls to <B>C_DigestEncryptUpdate</B> with calls to <B>C_DigestKey</B>, however).</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define BUF_SZ 512</P>

<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM digestMechanism = {</P>
<P>  CKM_MD5, NULL_PTR, 0</P>
<P>};</P>
<P>CK_MECHANISM encryptionMechanism = {</P>
<P>  CKM_DES_ECB, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_BYTE encryptedData[BUF_SZ];</P>
<P>CK_ULONG ulEncryptedDataLen;</P>
<P>CK_BYTE digest[16];</P>
<P>CK_ULONG ulDigestLen;</P>
<P>CK_BYTE data[(2*BUF_SZ)+8];</P>
<P>CK_RV rv;</P>
<P>int i;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>memset(iv, 0, sizeof(iv));</P>
<P>memset(data, ‘A’, ((2*BUF_SZ)+5));</P>
<P>rv = C_EncryptInit(hSession, &amp;encryptionMechanism, hKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_DigestInit(hSession, &amp;digestMechanism);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_DigestEncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[0], BUF_SZ,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_DigestEncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[BUF_SZ], BUF_SZ,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/*</P>
<P> * The last portion of the buffer needs to be handled with </P>
<P> * separate calls to deal with padding issues in ECB mode</P>
<P> */</P>

<P>/* First, complete the digest on the buffer */</P>
<P>rv = C_DigestUpdate(hSession, &amp;data[BUF_SZ*2], 5);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulDigestLen = sizeof(digest);</P>
<P>rv = C_DigestFinal(hSession, digest, &amp;ulDigestLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/* Then, pad last part with 3 0x00 bytes, and complete encryption */</P>
<P>for(i=0;i&lt;3;i++)</P>
<P>  data[((BUF_SZ*2)+5)+i] = 0x00;</P>

<P>/* Now, get second-to-last piece of ciphertext */</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_EncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[BUF_SZ*2], 8,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/* Get last piece of ciphertext (should have length 0, here) */</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_EncryptFinal(hSession, encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057959"><A NAME="_Toc405794779"><A NAME="_Toc410109117"></FONT><B><FONT FACE="Palatino">C_DecryptDigestUpdate</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DecryptDigestUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG ulEncryptedPartLen,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG_PTR pulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DecryptDigestUpdate</B> continues a multiple-part combined decryption and digest operation, processing another data part. <I>hSession</I> is the session’s handle; <I>pEncryptedPart</I> points to the encrypted data part; <I>ulEncryptedPartLen</I> is the length of the encrypted data part; <I>pPart</I> points to the location that receives the recovered data part; <I>pulPartLen</I> points to the location that holds the length of the recovered data part.</P>
<B><P ALIGN="JUSTIFY">C_DecryptDigestUpdate</B> uses the convention described in Section 10.2 on producing output. If a <B>C_DecryptDigestUpdate</B> call does not produce decrypted output (because an error occurs, or because <I>pPart</I> has the value NULL_PTR, or because <I>pulPartLen</I> is too small to hold the entire decrypted part output), then no plaintext is passed to the active digest operation.</P>
<P ALIGN="JUSTIFY">Decryption and digesting operations must both be active (they must have been initialized with <B>C_DecryptInit</B> and <B>C_DigestInit,</B> respectively).  This function may be called any number of times in succession, and may be interspersed with <B>C_DecryptUpdate</B>, <B>C_DigestUpdate</B>, and <B>C_DigestKey</B> calls (it would be somewhat unusual to intersperse calls to <B>C_DigestEncryptUpdate</B> with calls to <B>C_DigestKey</B>, however).</P>
<P ALIGN="JUSTIFY">Use of <B>C_DecryptDigestUpdate</B> involves a pipelining issue that does not arise when using <B>C_DigestEncryptUpdate</B>, the &quot;inverse function&quot; of <B>C_DecryptDigestUpdate</B>.  This is because when <B>C_DigestEncryptUpdate</B> is called, precisely the same input is passed to both the active digesting operation and the active encryption operation; however, when <B>C_DecryptDigestUpdate</B> is called, the input passed to the active digesting operation is the <I>output of</I> the active decryption operation.  This issue comes up only when the mechanism used for decryption performs padding.</P>
<P ALIGN="JUSTIFY">In particular, envision a 24-byte ciphertext which was obtained by encrypting an 18-byte plaintext with DES in CBC mode with PKCS padding.  Consider an application which will simultaneously decrypt this ciphertext and digest the original plaintext thereby obtained.</P>
<P ALIGN="JUSTIFY">After initializing decryption and digesting operations, the application passes the 24-byte ciphertext (3 DES blocks) into <B>C_DecryptDigestUpdate</B>.  <B>C_DecryptDigestUpdate</B> returns exactly 16 bytes of plaintext, since at this point, Cryptoki doesn’t know if there’s more ciphertext coming, or if the last block of ciphertext held any padding.  These 16 bytes of plaintext are passed into the active digesting operation.</P>
<P ALIGN="JUSTIFY">Since there is no more ciphertext, the application calls <B>C_DecryptFinal</B>.  This tells Cryptoki that there’s no more ciphertext coming, and the call returns the last 2 bytes of plaintext.  However, since the active decryption and digesting operations are linked <I>only</I> through the <B>C_DecryptDigestUpdate</B> call, these 2 bytes of plaintext are <I>not</I> passed on to be digested.</P>
<P ALIGN="JUSTIFY">A call to <B>C_DigestFinal</B>, therefore, would compute the message digest of <I>the first 16 bytes of the plaintext</I>, not the message digest of the entire plaintext.  It is crucial that, before <B>C_DigestFinal</B> is called, the last 2 bytes of plaintext get passed into the active digesting operation via a <B>C_DigestUpdate</B> call.</P>
<P ALIGN="JUSTIFY">Because of this, it is critical that when an application uses a padded decryption mechanism with <B>C_DecryptDigestUpdate</B>, it knows exactly how much plaintext has been passed into the active digesting operation.  <I>Extreme caution is warranted when using a padded decryption mechanism with <B>C_DecryptDigestUpdate</B>.</P>
</I><P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_ENCRYPTED_DATA_INVALID, CKR_ENCRYPTED_DATA_LEN_RANGE, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define BUF_SZ 512</P>

<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM decryptionMechanism = {</P>
<P>  CKM_DES_ECB, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_MECHANISM digestMechanism = {</P>
<P>  CKM_MD5, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE encryptedData[(2*BUF_SZ)+8];</P>
<P>CK_BYTE digest[16];</P>
<P>CK_ULONG ulDigestLen;</P>
<P>CK_BYTE data[BUF_SZ];</P>
<P>CK_ULONG ulDataLen, ulLastUpdateSize;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>memset(iv, 0, sizeof(iv));</P>
<P>memset(encryptedData, ‘A’, ((2*BUF_SZ)+8));</P>
<P>rv = C_DecryptInit(hSession, &amp;decryptionMechanism, hKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_DigestInit(hSession, &amp;digestMechanism);</P>
<P>if (rv != CKR_OK){</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>ulDataLen = sizeof(data);</P>
<P>rv = C_DecryptDigestUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[0], BUF_SZ,</P>
<P>  data, &amp;ulDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulDataLen = sizeof(data);</P>
<P>rv = C_DecryptDigestUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[BUF_SZ], BUF_SZ,</P>
<P>  data, &amp;ulDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/*</P>
<P> * The last portion of the buffer needs to be handled with </P>
<P> * separate calls to deal with padding issues in ECB mode</P>
<P> */</P>

<P>/* First, complete the decryption of the buffer */</P>
<P>ulLastUpdateSize = sizeof(data);</P>
<P>rv = C_DecryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[BUF_SZ*2], 8,</P>
<P>  data, &amp;ulLastUpdateSize);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Get last piece of plaintext (should have length 0, here) */</P>
<P>ulDataLen = sizeof(data)-ulLastUpdateSize;</P>
<P>rv = C_DecryptFinal(hSession, &amp;data[ulLastUpdateSize], &amp;ulDataLen);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>/* Digest last bit of plaintext */</P>
<P>rv = C_DigestUpdate(hSession, &amp;data[BUF_SZ*2], 5);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>ulDigestLen = sizeof(digest);</P>
<P>rv = C_DigestFinal(hSession, digest, &amp;ulDigestLen);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057960"><A NAME="_Toc405794780"><A NAME="_Toc410109118"></FONT><B><FONT FACE="Palatino">C_SignEncryptUpdate</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SignEncryptUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG ulPartLen,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG_PTR pulEncryptedPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SignEncryptUpdate</B> continues a multiple-part combined signature and encryption operation, processing another data part. <I>hSession</I> is the session’s handle; <I>pPart</I> points to the data part; <I>ulPartLen</I> is the length of the data part; <I>pEncryptedPart</I> points to the location that receives the digested and encrypted data part; and <I>pulEncryptedPart</I> points to the location that holds the length of the encrypted data part.</P>
<B><P ALIGN="JUSTIFY">C_SignEncryptUpdate</B> uses the convention described in Section 10.2 on producing output.  If a <B>C_SignEncryptUpdate</B> call does not produce encrypted output (because an error occurs, or because <I>pEncryptedPart</I> has the value NULL_PTR, or because <I>pulEncryptedPartLen</I> is too small to hold the entire encrypted part output), then no plaintext is passed to the active signing operation.</P>
<P ALIGN="JUSTIFY">Signature and encryption operations must both be active (they must have been initialized with <B>C_SignInit</B> and <B>C_EncryptInit,</B> respectively).  This function may be called any number of times in succession, and may be interspersed with <B>C_SignUpdate</B> and <B>C_EncryptUpdate</B> calls.</P>
<P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define BUF_SZ 512</P>

<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hEncryptionKey, hMacKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM signMechanism = {</P>
<P>  CKM_DES_MAC, NULL_PTR, 0</P>
<P>};</P>
<P>CK_MECHANISM encryptionMechanism = {</P>
<P>  CKM_DES_ECB, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_BYTE encryptedData[BUF_SZ];</P>
<P>CK_ULONG ulEncryptedDataLen;</P>
<P>CK_BYTE MAC[4];</P>
<P>CK_ULONG ulMacLen;</P>
<P>CK_BYTE data[(2*BUF_SZ)+8];</P>
<P>CK_RV rv;</P>
<P>int i;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>memset(iv, 0, sizeof(iv));</P>
<P>memset(data, ‘A’, ((2*BUF_SZ)+5));</P>
<P>rv = C_EncryptInit(hSession, &amp;encryptionMechanism, hEncryptionKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_SignInit(hSession, &amp;signMechanism, hMacKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_SignEncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[0], BUF_SZ,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_SignEncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[BUF_SZ], BUF_SZ,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/*</P>
<P> * The last portion of the buffer needs to be handled with </P>
<P> * separate calls to deal with padding issues in ECB mode</P>
<P> */</P>

<P>/* First, complete the signature on the buffer */</P>
<P>rv = C_SignUpdate(hSession, &amp;data[BUF_SZ*2], 5);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulMacLen = sizeof(MAC);</P>
<P>rv = C_DigestFinal(hSession, MAC, &amp;ulMacLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/* Then pad last part with 3 0x00 bytes, and complete encryption */</P>
<P>for(i=0;i&lt;3;i++)</P>
<P>  data[((BUF_SZ*2)+5)+i] = 0x00;</P>

<P>/* Now, get second-to-last piece of ciphertext */</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_EncryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;data[BUF_SZ*2], 8,</P>
<P>  encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/* Get last piece of ciphertext (should have length 0, here) */</P>
<P>ulEncryptedDataLen = sizeof(encryptedData);</P>
<P>rv = C_EncryptFinal(hSession, encryptedData, &amp;ulEncryptedDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc385057961"><A NAME="_Toc405794781"><A NAME="_Toc410109119"></FONT><B><FONT FACE="Palatino">C_DecryptVerifyUpdate</A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DecryptVerifyUpdate)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pEncryptedPart,<BR>
  CK_ULONG ulEncryptedPartLen,<BR>
  CK_BYTE_PTR pPart,<BR>
  CK_ULONG_PTR pulPartLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Ref320514967"><A NAME="_Toc322855305"><A NAME="_Toc322945147"><A NAME="_Toc323000714"><A NAME="_Toc323024155"><A NAME="_Toc323205489"><A NAME="_Toc323610918"><A NAME="_Toc383864925">C_DecryptVerifyUpdate</B> continues a multiple-part combined decryption and verification operation, processing another data part. <I>hSession</I> is the session’s handle; <I>pEncryptedPart</I> points to the encrypted data; <I>ulEncryptedPartLen</I> is the length of the encrypted data; <I>pPart</I> points to the location that receives the recovered data; and <I>pulPartLen</I> points to the location that holds the length of the recovered data.</P>
<B><P ALIGN="JUSTIFY">C_DecryptVerifyUpdate</B> uses the convention described in Section 10.2 on producing output.  If a <B>C_DecryptVerifyUpdate</B> call does not produce decrypted output (because an error occurs, or because <I>pPart</I> has the value NULL_PTR, or because <I>pulPartLen</I> is too small to hold the entire encrypted part output), then no plaintext is passed to the active verification operation.</P>
<P ALIGN="JUSTIFY">Decryption and signature operations must both be active (they must have been initialized with <B>C_DecryptInit</B> and <B>C_VerifyInit,</B> respectively).  This function may be called any number of times in succession, and may be interspersed with <B>C_DecryptUpdate</B> and <B>C_VerifyUpdate</B> calls.</P>
<P ALIGN="JUSTIFY">Use of <B>C_DecryptVerifyUpdate</B> involves a pipelining issue that does not arise when using <B>C_SignEncryptUpdate</B>, the &quot;inverse function&quot; of <B>C_DecryptVerifyUpdate</B>.  This is because when <B>C_SignEncryptUpdate</B> is called, precisely the same input is passed to both the active signing operation and the active encryption operation; however, when <B>C_DecryptVerifyUpdate</B> is called, the input passed to the active verifying operation is the <I>output of</I> the active decryption operation.  This issue comes up only when the mechanism used for decryption performs padding.</P>
<P ALIGN="JUSTIFY">In particular, envision a 24-byte ciphertext which was obtained by encrypting an 18-byte plaintext with DES in CBC mode with PKCS padding.  Consider an application which will simultaneously decrypt this ciphertext and verify a signature on the original plaintext thereby obtained.</P>
<P ALIGN="JUSTIFY">After initializing decryption and verification operations, the application passes the 24-byte ciphertext (3 DES blocks) into <B>C_DecryptVerifyUpdate</B>.  <B>C_DecryptVerifyUpdate</B> returns exactly 16 bytes of plaintext, since at this point, Cryptoki doesn’t know if there’s more ciphertext coming, or if the last block of ciphertext held any padding.  These 16 bytes of plaintext are passed into the active verification operation.</P>
<P ALIGN="JUSTIFY">Since there is no more ciphertext, the application calls <B>C_DecryptFinal</B>.  This tells Cryptoki that there’s no more ciphertext coming, and the call returns the last 2 bytes of plaintext.  However, since the active decryption and verification operations are linked <I>only</I> through the <B>C_DecryptVerifyUpdate</B> call, these 2 bytes of plaintext are <I>not</I> passed on to the verification mechanism.</P>
<P ALIGN="JUSTIFY">A call to <B>C_VerifyFinal</B>, therefore, would verify whether or not the signature supplied is a valid signature on <I>the first 16 bytes of the plaintext</I>, not on the entire plaintext.  It is crucial that, before <B>C_VerifyFinal</B> is called, the last 2 bytes of plaintext get passed into the active verification operation via a <B>C_VerifyUpdate</B> call.</P>
<P ALIGN="JUSTIFY">Because of this, it is critical that when an application uses a padded decryption mechanism with <B>C_DecryptVerifyUpdate</B>, it knows exactly how much plaintext has been passed into the active verification operation.  <I>Extreme caution is warranted when using a padded decryption mechanism with <B>C_DecryptVerifyUpdate</B>.</P>
</I><P>Return values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DATA_LEN_RANGE, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_ENCRYPTED_DATA_INVALID, CKR_ENCRYPTED_DATA_LEN_RANGE, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_NOT_INITIALIZED, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>#define BUF_SZ 512</P>

<P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hDecryptionKey, hMacKey;</P>
<P>CK_BYTE iv[8];</P>
<P>CK_MECHANISM decryptionMechanism = {</P>
<P>  CKM_DES_ECB, iv, sizeof(iv)</P>
<P>};</P>
<P>CK_MECHANISM verifyMechanism = {</P>
<P>  CKM_DES_MAC, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE encryptedData[(2*BUF_SZ)+8];</P>
<P>CK_BYTE MAC[4];</P>
<P>CK_ULONG ulMacLen;</P>
<P>CK_BYTE data[BUF_SZ];</P>
<P>CK_ULONG ulDataLen, ulLastUpdateSize;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>memset(iv, 0, sizeof(iv));</P>
<P>memset(encryptedData, ‘A’, ((2*BUF_SZ)+8));</P>
<P>rv = C_DecryptInit(hSession, &amp;decryptionMechanism, hDecryptionKey);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_VerifyInit(hSession, &amp;verifyMechanism, hMacKey);</P>
<P>if (rv != CKR_OK){</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>ulDataLen = sizeof(data);</P>
<P>rv = C_DecryptVerifyUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[0], BUF_SZ,</P>
<P>  data, &amp;ulDataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>ulDataLen = sizeof(data);</P>
<P>rv = C_DecryptVerifyUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[BUF_SZ], BUF_SZ,</P>
<P>  data, &amp;uldataLen);</P>
<P>.</P>
<P>.</P>
<P>.</P>

<P>/*</P>
<P> * The last portion of the buffer needs to be handled with </P>
<P> * separate calls to deal with padding issues in ECB mode</P>
<P> */</P>

<P>/* First, complete the decryption of the buffer */</P>
<P>ulLastUpdateSize = sizeof(data);</P>
<P>rv = C_DecryptUpdate(</P>
<P>  hSession,</P>
<P>  &amp;encryptedData[BUF_SZ*2], 8,</P>
<P>  data, &amp;ulLastUpdateSize);</P>
<P>.</P>
<P>.</P>
<P>.</P>
<P>/* Get last little piece of plaintext.  Should have length 0 */</P>
<P>ulDataLen = sizeof(data)-ulLastUpdateSize;</P>
<P>rv = C_DecryptFinal(hSession, &amp;data[ulLastUpdateSize], &amp;ulDataLen);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>

<P>/* Send last bit of plaintext to verification operation */</P>
<P>rv = C_VerifyUpdate(hSession, &amp;data[BUF_SZ*2], 5);</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_VerifyFinal(hSession, MAC, ulMacLen);</P>
<P>if (rv == CKR_SIGNATURE_INVALID) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057962"><A NAME="_Ref385149143"><A NAME="_Ref399141071"><A NAME="_Ref399147279"><A NAME="_Toc405794782"><A NAME="_Toc410109120">10.14.&#9;Key management</A></A></A></A></A></A></A></A></A> functions</A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for key management:</P>

<UL>
<LI><A NAME="_Toc323024156"><A NAME="_Toc323205490"><A NAME="_Toc323610919"><A NAME="_Toc383864926"><A NAME="_Toc385057963"><A NAME="_Toc405794783"><A NAME="_Toc410109121"></FONT><B><FONT FACE="Palatino">C_GenerateKey</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GenerateKey)(<BR>
  CK_SESSION_HANDLE hSession<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulCount,<BR>
  CK_OBJECT_HANDLE_PTR phKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GenerateKey</B> generates a secret key, creating a new key object. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the key generation mechanism; <I>pTemplate</I> points to the template for the new key; <I>ulCount</I> is the number of attributes in the template; <I>phKey</I> points to the location that receives the handle of the new key.</P>
<P ALIGN="JUSTIFY">Since the type of key to be generated is implicit in the key generation mechanism, the template does not need to supply a key type.  If it does supply a key type which is inconsistent with the key generation mechanism, <B>C_GenerateKey</B> fails and returns the error code CKR_TEMPLATE_INCONSISTENT.  The CKA_CLASS attribute is treated similarly.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_GenerateKey</B> cannot support the precise template supplied to it, it will fail and return without creating any key object.</P>
<P ALIGN="JUSTIFY">The key object created by a successful call to <B>C_GenerateKey</B> will have its <B>CKA_LOCAL</B> attribute set to TRUE.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCOMPLETE, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES_KEY_GEN, NULL_PTR, 0</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_GenerateKey(hSession, &amp;mechanism, NULL_PTR, 0, &amp;hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024157"><A NAME="_Toc323205491"><A NAME="_Toc323610920"><A NAME="_Toc383864927"><A NAME="_Toc385057964"><A NAME="_Toc405794784"><A NAME="_Toc410109122"></FONT><B><FONT FACE="Palatino">C_GenerateKeyPair</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GenerateKeyPair)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_ATTRIBUTE_PTR pPublicKeyTemplate,<BR>
  CK_ULONG ulPublicKeyAttributeCount,<BR>
  CK_ATTRIBUTE_PTR pPrivateKeyTemplate,<BR>
  CK_ULONG ulPrivateKeyAttributeCount,<BR>
  CK_OBJECT_HANDLE_PTR phPublicKey,<BR>
  CK_OBJECT_HANDLE_PTR phPrivateKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GenerateKeyPair</B> generates a public/private key pair, creating new key objects.  <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the key generation mechanism; <I>pPublicKeyTemplate</I> points to the template for the public key; <I>ulPublicKeyAttributeCount</I> is the number of attributes in the public-key template; <I>pPrivateKeyTemplate</I> points to the template for the private key; <I>ulPrivateKeyAttributeCount</I> is the number of attributes in the private-key template; <I>phPublicKey</I> points to the location that receives the handle of the new public key; <I>phPrivateKey</I> points to the location that receives the handle of the new private key.</P>
<P ALIGN="JUSTIFY">Since the types of keys to be generated are implicit in the key pair generation mechanism, the templates do not need to supply key types.  If one of the templates does supply a key type which is inconsistent with the key generation mechanism, <B>C_GenerateKeyPair</B> fails and returns the error code CKR_TEMPLATE_INCONSISTENT.  The CKA_CLASS attribute is treated similarly.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_GenerateKeyPair</B> cannot support the precise templates supplied to it, it will fail and return without creating any key objects.</P>
<P ALIGN="JUSTIFY">A call to <B>C_GenerateKeyPair</B> will never create just one key and return.  A call can fail, and create no keys; or it can succeed, and create a matching public/private key pair.</P>
<P ALIGN="JUSTIFY">The key objects created by a successful call to <B>C_GenerateKeyPair</B> will have their <B>CKA_LOCAL</B> attributes set to TRUE.</P>
<I><P ALIGN="JUSTIFY">Note carefully the order of the arguments to <B>C_GenerateKeyPair</B>.  The last two arguments do not have the same order as they did in the original Cryptoki Version 1.0 document.  The order of these two arguments has caused some unfortunate confusion.</P>
</I><P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCOMPLETE, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hPublicKey, hPrivateKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0</P>
<P>};</P>
<P>CK_ULONG modulusBits = 768;</P>
<P>CK_BYTE publicExponent[] = { 3 };</P>
<P>CK_BYTE subject[] = {...};</P>
<P>CK_BYTE id[] = {123};</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE publicKeyTemplate[] = {</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_VERIFY, &amp;true, sizeof(true)},</P>
<P>  {CKA_WRAP, &amp;true, sizeof(true)},</P>
<P>  {CKA_MODULUS_BITS, &amp;modulusBits, sizeof(modulusBits)},</P>
<P>  {CKA_PUBLIC_EXPONENT, publicExponent, sizeof (publicExponent)}</P>
<P>};</P>
<P>CK_ATTRIBUTE privateKeyTemplate[] = {</P>
<P>  {CKA_TOKEN, &amp;true, sizeof(true)},</P>
<P>  {CKA_PRIVATE, &amp;true, sizeof(true)},</P>
<P>  {CKA_SUBJECT, subject, sizeof(subject)},</P>
<P>  {CKA_ID, id, sizeof(id)},</P>
<P>  {CKA_SENSITIVE, &amp;true, sizeof(true)},</P>
<P>  {CKA_DECRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_SIGN, &amp;true, sizeof(true)},</P>
<P>  {CKA_UNWRAP, &amp;true, sizeof(true)}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>rv = C_GenerateKeyPair(</P>
<P>  hSession, &amp;mechanism,</P>
<P>  publicKeyTemplate, 5,</P>
<P>  privateKeyTemplate, 8,</P>
<P>  &amp;hPublicKey, &amp;hPrivateKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024158"><A NAME="_Toc323205492"><A NAME="_Toc323610921"><A NAME="_Toc383864928"><A NAME="_Toc385057965"><A NAME="_Toc405794785"><A NAME="_Toc410109123"></FONT><B><FONT FACE="Palatino">C_WrapKey</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_WrapKey)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hWrappingKey,<BR>
  CK_OBJECT_HANDLE hKey,<BR>
  CK_BYTE_PTR pWrappedKey,<BR>
  CK_ULONG_PTR pulWrappedKeyLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_WrapKey</B> wraps (<I>i.e.</I>, encrypts) a private or secret key. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the wrapping mechanism; <I>hWrappingKey</I> is the handle of the wrapping key;<I> hKey</I> is the handle of the key to be wrapped; <I>pWrappedKey</I> points to the location that receives the wrapped key; and<I> pulWrappedKeyLen</I> points to the location that receives the length of the wrapped key.</P>
<B><P ALIGN="JUSTIFY">C_WrapKey</B> uses the convention described in Section 10.2 on producing output.</P>
<P ALIGN="JUSTIFY">The <B>CKA_WRAP</B> attribute of the wrapping key, which indicates whether the key supports wrapping, must be TRUE.  The <B>CKA_EXTRACTABLE</B> attribute of the key to be wrapped must also be TRUE.</P>
<P ALIGN="JUSTIFY">If the key to be wrapped cannot be wrapped for some token-specific reason, despite its having its <B>CKA_EXTRACTABLE</B> attribute set to TRUE, then <B>C_WrapKey</B> fails with error code CKR_KEY_NOT_WRAPPABLE.  If it cannot be wrapped with the specified wrapping key and mechanism solely because of its length, then <B>C_WrapKey</B> fails with error code CKR_KEY_SIZE_RANGE.</P>
<B><P ALIGN="JUSTIFY">C_WrapKey</B> can be used in the following situations:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>To wrap any secret key with an RSA public key.</LI></P>
<P ALIGN="JUSTIFY"><LI>To wrap any secret key with any other secret key other than a SKIPJACK, BATON, or JUNIPER key.</LI></P>
<P ALIGN="JUSTIFY"><LI>To wrap a SKIPJACK, BATON, or JUNIPER key with another SKIPJACK, BATON, or JUNIPER key (the two keys need not be the same type of key).</LI></P>
<P ALIGN="JUSTIFY"><LI>To wrap an RSA, Diffie-Hellman, or DSA private key with any secret key other than a SKIPJACK, BATON, or JUNIPER key.</LI></P>
<P ALIGN="JUSTIFY"><LI>To wrap a KEA or DSA private key with a SKIPJACK key.</LI></P></UL>

<P ALIGN="JUSTIFY">Of course, tokens vary in which types of keys can actually be wrapped with which mechanisms.</P>
<P>Return Values: CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_HANDLE_INVALID, CKR_KEY_NOT_WRAPPABLE, CKR_KEY_SIZE_RANGE, CKR_KEY_UNEXTRACTABLE, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN, CKR_WRAPPING_KEY_HANDLE_INVALID, CKR_WRAPPING_KEY_SIZE_RANGE, CKR_WRAPPING_KEY_TYPE_INCONSISTENT.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hWrappingKey, hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES3_ECB, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE wrappedKey[8];</P>
<P>CK_ULONG ulWrappedKeyLen;</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>ulWrappedKeyLen = sizeof(wrappedKey);</P>
<P>rv = C_WrapKey(</P>
<P>  hSession, &amp;mechanism,</P>
<P>  hWrappingKey, hKey,</P>
<P>  wrappedKey, &amp;ulWrappedKeyLen);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024159"><A NAME="_Toc323205493"><A NAME="_Toc323610922"><A NAME="_Toc383864929"><A NAME="_Toc385057966"><A NAME="_Toc405794786"><A NAME="_Toc410109124"></FONT><B><FONT FACE="Palatino">C_UnwrapKey</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_UnwrapKey)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hUnwrappingKey,<BR>
  CK_BYTE_PTR pWrappedKey,<BR>
  CK_ULONG ulWrappedKeyLen,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulAttributeCount,<BR>
  CK_OBJECT_HANDLE_PTR phKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_UnwrapKey</B> unwraps (<I>i.e.</I> decrypts) a wrapped key, creating a new private key or secret key object. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to the unwrapping mechanism; <I>hUnwrappingKey</I> is the handle of the unwrapping key;<I> pWrappedKey</I> points to the wrapped key; <I>ulWrappedKeyLen</I> is the length of the wrapped key; <I>pTemplate</I> points to the template for the new key; <I>ulAttributeCount</I> is the number of attributes in the template; <I>phKey</I> points to the location that receives the handle of the recovered key.</P>
<P ALIGN="JUSTIFY">The <B>CKA_UNWRAP</B> attribute of the unwrapping key, which indicates whether the key supports unwrapping, must be TRUE.</P>
<P ALIGN="JUSTIFY">The new key will have the <B>CKA_ALWAYS_SENSITIVE</B> attribute set to FALSE, and the <B>CKA_EXTRACTABLE</B> attribute set to TRUE.</P>
<P ALIGN="JUSTIFY">When <B>C_UnwrapKey</B> is used to unwrap a key with the <B>CKM_KEY_WRAP_SET_OAEP</B> mechanism (see Section 11.32.1), additional &quot;extra data&quot; is decrypted at the same time that the key is unwrapped.  The return of this data follows the convention in Section 10.2 on producing output.  If the extra data is not returned from a call to <B>C_UnwrapKey</B> (either because the call was only to find out how large the extra data is, or because the buffer provided for the extra data was too small), then <B>C_UnwrapKey</B> will not create a new key, either.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_UnwrapKey</B> cannot support the precise template supplied to it, it will fail and return without creating any key object.</P>
<P ALIGN="JUSTIFY">The key object created by a successful call to <B>C_UnwrapKey</B> will have its <B>CKA_LOCAL</B> attribute set to FALSE.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_BUFFER_TOO_SMALL, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCOMPLETE, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_UNWRAPPING_KEY_HANDLE_INVALID, CKR_UNWRAPPING_KEY_SIZE_RANGE, CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT, CKR_USER_NOT_LOGGED_IN, CKR_WRAPPED_KEY_INVALID, CKR_WRAPPED_KEY_LEN_RANGE.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hUnwrappingKey, hKey;</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DES3_ECB, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE wrappedKey[8] = {...};</P>
<P>CK_OBJECT_CLASS keyClass = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES;</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;keyClass, sizeof(keyClass)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_DECRYPT, &amp;true, sizeof(true)}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_UnwrapKey(</P>
<P>  hSession, &amp;mechanism, hUnwrappingKey,</P>
<P>  wrappedKey, sizeof(wrappedKey), template, 4, &amp;hKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc323024160"><A NAME="_Toc323205494"><A NAME="_Toc323610923"><A NAME="_Toc383864930"><A NAME="_Toc385057967"><A NAME="_Toc405794787"><A NAME="_Toc410109125"></FONT><B><FONT FACE="Palatino">C_DeriveKey</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_DeriveKey)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_MECHANISM_PTR pMechanism,<BR>
  CK_OBJECT_HANDLE hBaseKey,<BR>
  CK_ATTRIBUTE_PTR pTemplate,<BR>
  CK_ULONG ulAttributeCount,<BR>
  CK_OBJECT_HANDLE_PTR phKey<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_DeriveKey</B> derives a key from a base key, creating a new key object. <I>hSession</I> is the session’s handle; <I>pMechanism</I> points to a structure that specifies the key derivation mechanism;  <I>hBaseKey</I> is the handle of the base key; <I>pTemplate</I> points to the template for the new key; <I>ulAttributeCount</I> is the number of  attributes in the template; and <I>phKey</I> points to the location that receives the handle of the derived key.</P>
<P ALIGN="JUSTIFY">The values of the <B>CK_SENSITIVE</B>, <B>CK_ALWAYS_SENSITIVE</B>, <B>CK_EXTRACTABLE</B>, and <B>CK_NEVER_EXTRACTABLE</B> attributes for the base key affect the values that these attributes can hold for the newly-derived key.  See the description of each particular key-derivation mechanism in Section 10.17.2 for any constraints of this type.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_DeriveKey</B> cannot support the precise template supplied to it, it will fail and return without creating any key object.</P>
<P ALIGN="JUSTIFY">The key object created by a successful call to <B>C_DeriveKey</B> will have its <B>CKA_LOCAL</B> attribute set to FALSE.</P>
<P>Return values: CKR_ATTRIBUTE_READ_ONLY, CKR_ATTRIBUTE_TYPE_INVALID, CKR_ATTRIBUTE_VALUE_INVALID, CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_KEY_HANDLE_INVALID, CKR_KEY_SIZE_RANGE, CKR_KEY_TYPE_INCONSISTENT, CKR_MECHANISM_INVALID, CKR_MECHANISM_PARAM_INVALID, CKR_OK, CKR_OPERATION_ACTIVE, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_SESSION_READ_ONLY, CKR_TEMPLATE_INCOMPLETE, CKR_TEMPLATE_INCONSISTENT, CKR_TOKEN_WRITE_PROTECTED, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_OBJECT_HANDLE hPublicKey, hPrivateKey, hKey;</P>
<P>CK_MECHANISM keyPairMechanism = {</P>
<P>  CKM_DH_PKCS_KEY_PAIR_GEN, NULL_PTR, 0</P>
<P>};</P>
<P>CK_BYTE prime[] = {...};</P>
<P>CK_BYTE base[] = {...};</P>
<P>CK_BYTE publicValue[128];</P>
<P>CK_BYTE otherPublicValue[128];</P>
<P>CK_MECHANISM mechanism = {</P>
<P>  CKM_DH_PKCS_DERIVE, otherPublicValue, sizeof(otherPublicValue)</P>
<P>};</P>
<P>CK_ATTRIBUTE pTemplate[] = {</P>
<P>  CKA_VALUE, &amp;publicValue, sizeof(publicValue)}</P>
<P>};</P>
<P>CK_OBJECT_CLASS keyClass = CKO_SECRET_KEY;</P>
<P>CK_KEY_TYPE keyType = CKK_DES;</P>
<P>CK_BBOOL true = TRUE;</P>
<P>CK_ATTRIBUTE publicKeyTemplate[] = {</P>
<P>  {CKA_PRIME, prime, sizeof(prime)},</P>
<P>  {CKA_BASE, base, sizeof(base)}</P>
<P>};</P>
<P>CK_ATTRIBUTE privateKeyTemplate[] = {</P>
<P>  {CKA_DERIVE, &amp;true, sizeof(true)}</P>
<P>};</P>
<P>CK_ATTRIBUTE template[] = {</P>
<P>  {CKA_CLASS, &amp;keyClass, sizeof(keyClass)},</P>
<P>  {CKA_KEY_TYPE, &amp;keyType, sizeof(keyType)},</P>
<P>  {CKA_ENCRYPT, &amp;true, sizeof(true)},</P>
<P>  {CKA_DECRYPT, &amp;true, sizeof(true)}</P>
<P>};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_GenerateKeyPair(</P>
<P>  hSession, &amp;keyPairMechanism,</P>
<P>  publicKeyTemplate, 2,</P>
<P>  privateKeyTemplate, 1,</P>
<P>  &amp;hPublicKey, &amp;hPrivateKey);</P>
<P>if (rv == CKR_OK) {</P>
<P>  rv = C_GetAttributeValue(hSession, hPublicKey, &amp;pTemplate, 1);</P>
<P>  if (rv == CKR_OK) {</P>
<P>    /* Put other guy’s public value in otherPublicValue */</P>
<P>    .</P>
<P>    .</P>
<P>    .</P>
<P>    rv = C_DeriveKey(</P>
<P>      hSession, &amp;mechanism,</P>
<P>      hPrivateKey, template, 4, &amp;hKey);</P>
<P>    if (rv == CKR_OK) {</P>
<P>      .</P>
<P>      .</P>
<P>      .</P>
<P>    }</P>
<P>  }</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323205495"><A NAME="_Toc323610924"><A NAME="_Toc383864931"><A NAME="_Toc385057968"><A NAME="_Toc405794788"><A NAME="_Toc410109126"><A NAME="_Toc323024162">10.15.&#9;Random number generation</A></A></A> functions</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"><A NAME="_Toc323205496">Cryptoki provides the following functions for generating random numbers:</P>

<UL>
<LI><A NAME="_Toc323610925"><A NAME="_Toc383864932"><A NAME="_Toc385057969"><A NAME="_Toc405794789"><A NAME="_Toc410109127"></FONT><B><FONT FACE="Palatino">C_SeedRandom</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_SeedRandom)(<BR>
  CK_SESSION_HANDLE hSession,<BR>
  CK_BYTE_PTR pSeed,<BR>
  CK_ULONG ulSeedLen<BR>
);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_SeedRandom</B> mixes additional seed material into the token’s random number generator. <I>hSession</I> is the session’s handle; <I>pSeed</I> points to the seed material; and<I> ulSeedLen</I> is the length in bytes of the seed material.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_ACTIVE, CKR_RANDOM_SEED_NOT_SUPPORTED, CKR_RANDOM_NO_RNG, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example: see <B>C_GenerateRandom</B>.</P>

<UL>
<LI><A NAME="_Toc323024163"><A NAME="_Toc323205497"><A NAME="_Toc323610926"><A NAME="_Toc383864933"><A NAME="_Toc385057970"><A NAME="_Toc405794790"><A NAME="_Toc410109128"></FONT><B><FONT FACE="Palatino">C_GenerateRandom</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GenerateRandom)(</P>
<P>  CK_SESSION_HANDLE hSession,</P>
<P>  CK_BYTE_PTR pRandomData,</P>
<P>  CK_ULONG ulRandomLen</P>
<P>);</P>
</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">C_GenerateRandom</B> generates random or pseudo-random data. <I>hSession</I> is the session’s handle; <I>pRandomData</I> points to the location that receives the random data; and<I> ulRandomLen</I> is the length in bytes of the random or pseudo-random data to be generated.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_DEVICE_ERROR, CKR_DEVICE_MEMORY, CKR_DEVICE_REMOVED, CKR_FUNCTION_CANCELED, CKR_FUNCTION_FAILED, CKR_GENERAL_ERROR, CKR_HOST_MEMORY, CKR_OK, CKR_OPERATION_ACTIVE, CKR_RANDOM_NO_RNG, CKR_SESSION_CLOSED, CKR_SESSION_HANDLE_INVALID, CKR_USER_NOT_LOGGED_IN.</P>
<P ALIGN="JUSTIFY">Example:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>CK_SESSION_HANDLE hSession;</P>
<P>CK_BYTE seed[] = {...};</P>
<P>CK_BYTE randomData[] = {...};</P>
<P>CK_RV rv;</P>

<P>.</P>
<P>.</P>
<P>.</P>
<P>rv = C_SeedRandom(hSession, seed, sizeof(seed));</P>
<P>if (rv != CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P>
<P>rv = C_GenerateRandom(hSession, randomData, sizeof(randomData));</P>
<P>if (rv == CKR_OK) {</P>
<P>  .</P>
<P>  .</P>
<P>  .</P>
<P>}</P></ul>
</ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855307"><A NAME="_Toc322945149"><A NAME="_Toc323000716"><A NAME="_Toc323024164"><A NAME="_Toc323205498"><A NAME="_Toc323610927"><A NAME="_Toc383864934"><A NAME="_Toc385057971"><A NAME="_Ref399575137"><A NAME="_Toc405794791"><A NAME="_Toc410109129">10.16.&#9;Parallel function management</A></A></A></A></A></A></A></A></A></A></A> functions</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki provides the following functions for managing parallel execution of cryptographic functions.  These functions exist only for backwards compatibility.</P>

<UL>
<LI><A NAME="_Toc323024165"><A NAME="_Toc323205499"><A NAME="_Toc323610928"><A NAME="_Toc383864935"><A NAME="_Toc385057972"><A NAME="_Toc405794792"><A NAME="_Toc410109130"></FONT><B><FONT FACE="Palatino">C_GetFunctionStatus</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_GetFunctionStatus)(<BR>
  CK_SESSION_HANDLE hSession<BR>
);</P>
</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In previous versions of Cryptoki, <B>C_GetFunctionStatus</B> obtained the status of a function running in parallel with an application.  Now, however, <B>C_GetFunctionStatus</B> is a legacy function which should simply return the value CKR_FUNCTION_NOT_PARALLEL.</P>
<P>Return values:    CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_FUNCTION_NOT_PARALLEL, CKR_GENERAL_ERROR, CKR_HOST_MEMORY.   </P>

<UL>
<LI><A NAME="_Toc323024166"><A NAME="_Toc323205500"><A NAME="_Toc323610929"><A NAME="_Toc383864936"><A NAME="_Toc385057973"><A NAME="_Toc405794793"><A NAME="_Toc410109131"></FONT><B><FONT FACE="Palatino">C_CancelFunction</A></A></A></A></A></A></A></LI></UL>

</B></FONT><FONT FACE="Courier New" SIZE=2><P>CK_DEFINE_FUNCTION(CK_RV, C_CancelFunction)(<BR>
  CK_SESSION_HANDLE hSession<BR>
);</P>
</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In previous versions of Cryptoki, <B>C_CancelFunction</B> cancelled a function running in parallel with an application.  Now, however, <B>C_CancelFunction</B> is a legacy function which should simply return the value CKR_FUNCTION_NOT_PARALLEL.</P>
<P>Return values: CKR_CRYPTOKI_NOT_INITIALIZED, CKR_FUNCTION_FAILED, CKR_FUNCTION_NOT_PARALLEL, CKR_GENERAL_ERROR, CKR_HOST_MEMORY.  </P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref320505795"><A NAME="_Toc322855308"><A NAME="_Ref322938213"><A NAME="_Toc322945150"><A NAME="_Toc323000717"><A NAME="_Toc323024167"><A NAME="_Toc323205501"><A NAME="_Toc323610930"><A NAME="_Toc383864937"><A NAME="_Ref384828675"><A NAME="_Toc385057974"><A NAME="_Ref385351071"><A NAME="_Toc405794794"><A NAME="_Toc410109132"><A NAME="_Ref319997130"></A>10.17.&#9;Callback function</A></A></A></A></A></A></A></A></A></A></A>s</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki sessions can use function pointers of type <B>CK_NOTIFY</B> to notify the application of certain events.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref394400826"><A NAME="_Toc405794795"><A NAME="_Toc410109133">10.17.1.&#9;Surrender callbacks</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptographic functions (<I>i.e.</I>, any functions falling under one of these categories: encryption functions; decryption functions; message digesting functions; signing and MACing functions; functions for verifying signatures and MACs; dual-purpose cryptographic functions; key management functions; random number generation functions) executing in Cryptoki sessions can periodically surrender control to the application who called them if the session they are executing in had a notification callback function associated with it when it was opened.  They do this by calling the session’s callback with the arguments </FONT><FONT FACE="Courier New" SIZE=2>(hSession, CKN_SURRENDER, pApplication)</FONT><FONT FACE="Palatino" SIZE=2>, where </FONT><FONT FACE="Courier New" SIZE=2>hSession</FONT><FONT FACE="Palatino" SIZE=2> is the session’s handle and </FONT><FONT FACE="Courier New" SIZE=2>pApplication</FONT><FONT FACE="Palatino" SIZE=2> was supplied to <B>C_OpenSession</B> when the session was opened.  Surrender callbacks should return either the value CKR_OK (to indicate that Cryptoki should continue executing the function) or the value CKR_CANCEL (to indicate that Cryptoki should abort execution of the function).  Of course, before returning one of these values, the callback function can perform some computation, if desired.</P>
<P ALIGN="JUSTIFY">A typical use of a surrender callback might be to give an application user feedback during a lengthy key pair generation operation.  Each time the application receives a callback, it could display an additional &quot;.&quot; to the user.  It might also examine the keyboard’s activity since the last surrender callback, and abort the key pair generation operation (probably by returning the value CKR_CANCEL) if the user hit &lt;ESCAPE&gt;.</P>
<P ALIGN="JUSTIFY">A Cryptoki library is not <I>required</I> to make <I>any</I> surrender callbacks.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794796"><A NAME="_Toc410109134"><A NAME="_Ref320514897"><A NAME="_Toc322855309"><A NAME="_Toc322945151"><A NAME="_Toc323000718"><A NAME="_Toc323024169"><A NAME="_Toc323205503"><A NAME="_Toc323610932"><A NAME="_Toc383864939"><A NAME="_Toc385057976">10.17.2.&#9;Vendor-defined callbacks</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Library vendors can also define additional types of callbacks.  Because of this extension capability, application-supplied notification callback routines should examine each callback they receive, and if they are unfamiliar with the type of that callback, they should immediately give control back to the library by returning with the value CKR_OK.</P>
</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Ref407099471"><A NAME="_Toc410109135">11.&#9;Mechanisms</A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"></A></A></A></A></A></A></A></A></A></A>A mechanism specifies precisely how a certain cryptographic process is to be performed.  </P>
<P ALIGN="JUSTIFY">The following table shows which Cryptoki mechanisms are supported by different cryptographic operations.  For any particular token, of course, a particular operation may well support only a subset of the mechanisms listed.  There is also no guarantee that a token which supports one mechanism for some operation supports any other mechanism for any other operation (or even supports that same mechanism for any other operation).  For example, even if a token is able to create RSA digital signatures with the <B>CKM_RSA_PKCS</B> mechanism, it may or may not be the case that the same token can also perform RSA encryption with <B>CKM_RSA_PKCS</B>.</P>
<B><P><A NAME="_Toc323204916"><A NAME="_Toc383864546"><A NAME="_Toc405795010"><A NAME="_Toc410108879">Table 48, Mechanisms vs. Functions</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=570>
<TR><TD WIDTH="41%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="59%" VALIGN="TOP" COLSPAN=7>
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Functions</B></FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1>
<P>Mechanism</B></FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Encrypt</P>
<P ALIGN="CENTER">&amp;</P>
<P ALIGN="CENTER">Decrypt</B></FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Sign</P>
<P ALIGN="CENTER">&amp;</P>
<P ALIGN="CENTER">Verify</B></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">SR</P>
<P ALIGN="CENTER">&amp;</P>
<P ALIGN="CENTER">VR</B><SUP>1</SUP></FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"></P>
<P ALIGN="CENTER">Digest</B></FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Gen.</P>
<P ALIGN="CENTER"> Key/</P>
<P ALIGN="CENTER">Key</P>
<P ALIGN="CENTER">Pair</B></FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Wrap</P>
<P ALIGN="CENTER">&amp;</P>
<P ALIGN="CENTER">Unwrap</B></FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"></P>
<P ALIGN="CENTER">Derive</B></FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RSA_PKCS_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RSA_PKCS</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RSA_9796</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RSA_X_509</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD2_RSA_PKCS</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD5_RSA_PKCS</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA1_RSA_PKCS</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DSA_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DSA</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DSA_SHA1</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_FORTEZZA_TIMESTAMP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_ECDSA_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_ECDSA</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>2</SUP></FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_ECDSA_SHA1</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DH_PKCS_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DH_PKCS_DERIVE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_KEA_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_KEA_KEY_DERIVE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_GENERIC_SECRET_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC2_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC4_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC4</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC5_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES2_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DES3_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST3_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_KEY_GEN (CKM_CAST5_KEY_GEN)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_ECB (CKM_CAST5_ECB)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_CBC (CKM_CAST5_CBC)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_CBC_PAD (CKM_CAST5_CBC_PAD)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_MAC_GENERAL (CKM_CAST5_MAC_GENERAL)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CAST128_MAC (CKM_CAST5_MAC)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_IDEA_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_ECB</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_CBC_PAD</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_MAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CDMF_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_ECB64</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_CBC64</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_OFB64</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_CFB64</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_CFB32</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_CFB16</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_CFB8</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_WRAP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_PRIVATE_WRAP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SKIPJACK_RELAYX</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
<SUP>3</SUP></FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_ECB128</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_ECB96</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_CBC128</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_COUNTER</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_SHUFFLE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_BATON_WRAP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_ECB128</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_CBC128</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_COUNTER</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_SHUFFLE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_JUNIPER_WRAP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD2</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD2_HMAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD2_HMAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD2_KEY_DERIVATION</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD5</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD5_HMAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD5_HMAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_MD5_KEY_DERIVATION</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA_1</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA_1_HMAC_GENERAL</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA_1_HMAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA1_KEY_DERIVATION</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_FASTHASH</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_MD2_DES_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_MD5_DES_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_MD5_CAST_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_MD5_CAST3_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_MD5_CAST128_CBC (CKM_PBE_MD5_CAST5_CBC)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_CAST128_CBC (CKM_PBE_SHA1_CAST5_CBC)</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_RC4_128</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_RC4_40</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_DES3_EDE_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_DES2_EDE_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_RC2_128_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBE_SHA1_RC2_40_CBC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_PBA_SHA1_WITH_SHA1_HMAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_KEY_WRAP_SET_OAEP</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_KEY_WRAP_LYNKS</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SSL3_PRE_MASTER_KEY_GEN</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SSL3_MASTER_KEY_DERIVE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SSL3_KEY_AND_MAC_DERIVE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SSL3_MD5_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SSL3_SHA1_MAC</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CONCATENATE_BASE_AND_KEY</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CONCATENATE_BASE_AND_DATA</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_CONCATENATE_DATA_AND_BASE</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_XOR_BASE_AND_DATA</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_EXTRACT_KEY_FROM_KEY</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="8%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> SR = SignRecover, VR = VerifyRecover.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">3</SUP> Mechanism can only be used for wrapping, not unwrapping.</P>
<P ALIGN="JUSTIFY">The remainder of Section 10.17.2 will present in detail the mechanisms supported by Cryptoki Version 2.01 and the parameters which are supplied to them.</P>
<P ALIGN="JUSTIFY">In general, if a mechanism makes no mention of the <I>ulMinKeyLen</I> and <I>ulMaxKeyLen</I> fields of the CK_MECHANISM_INFO structure, then those fields have no meaning for that particular mechanism.<A NAME="_Toc385057977"><A NAME="_Toc322855310"><A NAME="_Toc322945152"><A NAME="_Toc323000719"><A NAME="_Toc323024170"><A NAME="_Toc323205504"><A NAME="_Toc323610933"><A NAME="_Toc383864950"></P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794798"><A NAME="_Toc410109136">11.1.&#9;RSA mechanisms</A></A></A></P>
<P><A NAME="_Toc385057978"><A NAME="_Toc405794799"><A NAME="_Toc410109137">11.1.1.&#9;PKCS #1 RSA key pair generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The PKCS #1 RSA key pair generation mechanism, denoted <B>CKM_RSA_PKCS_KEY_PAIR_GEN</B>, is a key pair generation mechanism based on the RSA public-key cryptosystem, as defined in PKCS #1.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates RSA public/private key pairs with a particular modulus length in bits and public exponent, as specified in the <B>CKA_MODULUS_BITS</B> and <B>CKA_PUBLIC_EXPONENT</B> attributes of the template for the public key.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, <B>CKA_MODULUS</B>, and <B>CKA_PUBLIC_EXPONENT </B>attributes to the new public key.  It contributes the <B>CKA_CLASS</B> and <B>CKA_KEY_TYPE</B> attributes to the new private key; it may also contribute some of the following attributes to the new private key: <B>CKA_MODULUS</B>, <B>CKA_PUBLIC_EXPONENT</B>, <B>CKA_PRIVATE_EXPONENT</B>, <B>CKA_PRIME_1</B>, <B>CKA_PRIME_2</B>, <B>CKA_EXPONENT_1</B>, <B>CKA_EXPONENT_2</B>, <B>CKA_COEFFICIENT</B> (see Section 9.7.1).  Other attributes supported by the RSA public and private key types (specifically, the flags indicating which functions the keys support) may also be specified in the templates for the keys, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">Keys generated with this mechanism can be used with the following mechanisms: PKCS #1 RSA; ISO/IEC 9796 RSA; X.509 (raw) RSA; PKCS #1 RSA with MD2; PKCS #1 RSA with MD5; PKCS #1 RSA with SHA-1; and OAEP key wrapping for SET.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RSA modulus sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855311"><A NAME="_Toc322945153"><A NAME="_Toc323000720"><A NAME="_Toc323024171"><A NAME="_Toc323205505"><A NAME="_Toc323610934"><A NAME="_Toc383864951"><A NAME="_Toc385057979"><A NAME="_Toc405794800"><A NAME="_Toc410109138">11.1.2.&#9;PKCS #1 RSA</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The PKCS #1 RSA mechanism, denoted <B>CKM_RSA_PKCS</B>, is a multi-purpose mechanism based on the RSA public-key cryptosystem and the block formats defined in PKCS #1.  It supports single-part encryption and decryption; single-part signatures and verification with and without message recovery; key wrapping; and key unwrapping.  This mechanism corresponds only to the part of PKCS #1 that involves RSA; it does not compute a message digest or a DigestInfo encoding as specified for the </FONT><FONT FACE="Courier New" SIZE=2>md2withRSAEncryption</FONT><FONT FACE="Palatino" SIZE=2> and </FONT><FONT FACE="Courier New" SIZE=2>md5withRSAEncryption</FONT><FONT FACE="Palatino" SIZE=2> algorithms in PKCS #1.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key of appropriate length.  Of course, a particular token may not be able to wrap/unwrap every appropriate-length secret key that it supports.  For wrapping, the &quot;input&quot; to the encryption operation is the value of the <B>CKA_VALUE</B> attribute of the key that is wrapped; similarly for unwrapping.  The mechanism does not wrap the key type or any other information about the key, except the key length; the application must convey these separately.  In particular, the mechanism contributes only the <B>CKA_CLASS</B> and <B>CKA_VALUE</B> (and <B>CKA_VALUE_LEN</B>, if the key has it) attributes to the recovered key during unwrapping; other attributes must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of the data are summarized in the following table.  For encryption, decryption, signatures and signature verification, the input and output data may begin at the same location in memory.  In the table, <I>k</I> is the length in bytes of the RSA modulus.</P>
<B><P><A NAME="_Toc323204899"><A NAME="_Toc383864548"><A NAME="_Toc405795011"><A NAME="_Toc410108880">Table 49, PKCS #1 RSA: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=543>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt<SUP>1</SUP></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>02</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt<SUP>1</SUP></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>02</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignRecover</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11, <I>k</I><SUP>2</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyRecover</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>02</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>-11</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>02</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RSA modulus sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323000721"><A NAME="_Toc323024172"><A NAME="_Toc323205506"><A NAME="_Toc323610935"><A NAME="_Toc383864952"><A NAME="_Toc385057980"><A NAME="_Toc405794801"><A NAME="_Toc410109139">11.1.3.&#9;ISO/IEC 9796 RSA</A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The ISO/IEC 9796 RSA mechanism, denoted <B>CKM_RSA_9796</B>, is a mechanism for single-part signatures and verification with and without message recovery based on the RSA public-key cryptosystem and the block formats defined in ISO/IEC 9796 and its annex A.  This mechanism is compatible with the draft ANSI X9.31 (assuming the length in bits of the X9.31 hash value is a multiple of 8).</P>
<P ALIGN="JUSTIFY">This mechanism processes only byte strings, whereas ISO/IEC 9796 operates on bit strings.  Accordingly, the following transformations are performed:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Data is converted between byte and bit string formats by interpreting the most-significant bit of the leading byte of the byte string as the leftmost bit of the bit string, and the least-significant bit of the trailing byte of the byte string as the rightmost bit of the bit string (this assumes the length in bits of the data is a multiple of 8).</LI></P>
<P ALIGN="JUSTIFY"><LI>A signature is converted from a bit string to a byte string by padding the bit string on the left with 0 to 7 zero bits so that the resulting length in bits is a multiple of 8, and converting the resulting bit string as above; it is converted from a byte string to a bit string by converting the byte string as above, and removing bits from the left so that the resulting length in bits is the same as that of the RSA modulus.</LI></P></UL>

<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table.  In the table, <I>k</I> is the length in bytes of the RSA modulus.<A NAME="x"></A></P>
<B><P><A NAME="_Toc323204900"><A NAME="_Toc383864549"><A NAME="_Toc405795012"><A NAME="_Toc410108881">Table 50, ISO/IEC 9796 RSA: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=445>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <FONT FACE="Symbol">&#235;</FONT>
<I>k</I>/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignRecover</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <FONT FACE="Symbol">&#235;</FONT>
<I>k</I>/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <FONT FACE="Symbol">&#235;</FONT>
<I>k</I>/2<FONT FACE="Symbol">&#251;</FONT>
, <I>k</I><SUP>2</SUP></FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyRecover</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <FONT FACE="Symbol">&#235;</FONT>
<I>k</I>/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RSA modulus sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc323000722"><A NAME="_Toc323024173"><A NAME="_Toc323205507"><A NAME="_Toc323610936"><A NAME="_Toc383864953"><A NAME="_Toc385057981"><A NAME="_Toc405794802"><A NAME="_Toc410109140">11.1.4.&#9;X.509 (raw) RSA</A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The X.509 (raw) RSA mechanism, denoted <B>CKM_RSA_X_509</B>, is a multi-purpose mechanism based on the RSA public-key cryptosystem. It supports single-part encryption and decryption; single-part signatures and verification with and without message recovery; key wrapping; and key unwrapping.  All these operations are based on so-called &quot;raw&quot; RSA, as assumed in X.509.</P>
<P ALIGN="JUSTIFY">&quot;Raw&quot; RSA as defined here encrypts a byte string by converting it to an integer, most-significant byte first, applying &quot;raw&quot; RSA exponentiation, and converting the result to a byte string, most-significant byte first.  The input string, considered as an integer, must be less than the modulus; the output string is also less than the modulus.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key of appropriate length.  Of course, a particular token may not be able to wrap/unwrap every appropriate-length secret key that it supports.  For wrapping, the &quot;input&quot; to the encryption operation is the value of the <B>CKA_VALUE </B>attribute of the key that is wrapped; similarly for unwrapping.  The mechanism does not wrap the key type, key length, or any other information about the key; the application must convey these separately, and supply them when unwrapping the key.<A NAME="y"></A></P>
<P ALIGN="JUSTIFY">Unfortunately, X.509 does not specify how to perform padding for RSA encryption.  For this mechanism, padding should be performed by prepending plaintext data with 0-valued bytes.  In effect, to encrypt the sequence of plaintext bytes b<SUB>1</SUB> b<SUB>2</SUB> … b<SUB>n</SUB> (n <FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>), Cryptoki forms P=2<SUP>n-1</SUP>b<SUB>1</SUB>+2<SUP>n-2</SUP>b<SUB>2</SUB>+…+b<SUB>n</SUB>.  This number must be less than the RSA modulus.  The <I>k</I>-byte ciphertext (<I>k</I> is the length in bytes of the RSA modulus) is produced by raising P to the RSA public exponent modulo the RSA modulus.  Decryption of a <I>k</I>-byte ciphertext C is accomplished by raising C to the RSA private exponent modulo the RSA modulus, and returning the resulting value as a sequence of exactly <I>k</I> bytes.  If the resulting plaintext is to be used to produce an unwrapped key, then however many bytes are specified in the template for the length of the key are taken <I>from the end</I> of this sequence of bytes.</P>
<P ALIGN="JUSTIFY">Technically, the above procedures may differ very slightly from certain details of what is specified in X.509.</P>
<P ALIGN="JUSTIFY">Executing cryptographic operations using this mechanism can result in the error returns CKR_DATA_INVALID (if plaintext is supplied which has the same length as the RSA modulus and is numerically at least as large as the modulus) and CKR_ENCRYPTED_DATA_INVALID (if ciphertext is supplied which has the same length as the RSA modulus and is numerically at least as large as the modulus).</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table.  In the table, <I>k</I> is the length in bytes of the RSA modulus.</P>
<B><P><A NAME="_Toc323204901"><A NAME="_Toc383864550"><A NAME="_Toc405795013"><A NAME="_Toc410108882">Table 51, X.509 (Raw) RSA: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=510>
<TR><TD WIDTH="24%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt<SUP>1</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt<SUP>1</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignRecover</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I>, <I>k</I><SUP>2</SUP></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyRecover</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#163;</FONT>
 <I>k</I> (specified in template)</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc322855314"><A NAME="_Toc322945156">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RSA modulus sizes, in bits.</P>
<P ALIGN="JUSTIFY">This mechanism is intended for compatibility with applications that do not follow the PKCS #1 or ISO/IEC 9796 block formats.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057982"><A NAME="_Toc405794803"><A NAME="_Toc410109141">11.1.5.&#9;PKCS #1 RSA signature with MD2, MD5, or SHA-1</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The PKCS #1 RSA signature with MD2 mechanism, denoted <B>CKM_MD2_RSA_PKCS</B>, performs single- and multiple-part digital signatures and verification operations without message recovery.  The operations performed are as described in PKCS #1 with the object identifier md2WithRSAEncryption.</P>
<P ALIGN="JUSTIFY">Similarly, the PKCS #1 RSA signature with MD5 mechanism, denoted <B>CKM_MD5_RSA_PKCS</B>, performs the same operations described in PKCS #1 with the object identifier md5WithRSAEncryption.  The PKCS #1 RSA signature with SHA-1 mechanism, denoted <B>CKM_SHA1_RSA_PKCS</B>, performs the same operations, except that it uses the hash function SHA-1, instead of MD2 or MD5.</P>
<P ALIGN="JUSTIFY">None of these mechanisms has a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of the data for these mechanisms are summarized in the following table.  In the table, <I>k</I> is the length in bytes of the RSA modulus.  For the PKCS #1 RSA signature with MD2 and PKCS #1 RSA signature with MD5 mechanisms, <I>k</I> must be at least 27; for the PKCS #1 RSA signature with SHA-1 mechanism, <I>k</I> must be at least 31.</P>
<B><P><A NAME="_Toc405795014"><A NAME="_Toc410108883">Table 52, PKCS #1 RSA Signatures with MD2, MD5, or SHA-1: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=543>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA private key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<I><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">k</I></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RSA public key</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any, <I>k</I><SUP>2</SUP></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">block type </FONT><FONT FACE="Courier New" SIZE=2>01</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For these mechanisms, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RSA modulus sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057983"><A NAME="_Toc405794804"><A NAME="_Toc410109142"><A NAME="_Toc323000723"><A NAME="_Toc323024174"><A NAME="_Toc323205508"><A NAME="_Toc323610937"><A NAME="_Toc383864954">11.2.&#9;DSA mechanisms</A></A></A></P>
<P><A NAME="_Toc385057984"><A NAME="_Toc405794805"><A NAME="_Toc410109143">11.2.1.&#9;DSA key pair generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The DSA key pair generation mechanism, denoted <B>CKM_DSA_KEY_PAIR_GEN</B>, is a key pair generation mechanism based on the Digital Signature Algorithm defined in FIPS PUB 186.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates DSA public/private key pairs with a particular prime, subprime and base, as specified in the <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B>, and <B>CKA_BASE</B> attributes of the template for the public key.  Note that this version of Cryptoki does not include a mechanism for generating these DSA parameters.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new public key and the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B>, <B>CKA_BASE</B>, and <B>CKA_VALUE</B> attributes to the new private key. Other attributes supported by the DSA public and private key types (specifically, the flags indicating which functions the keys support) may also be specified in the templates for the keys, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of DSA prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855315"><A NAME="_Toc322945157"><A NAME="_Toc323000724"><A NAME="_Toc323024175"><A NAME="_Toc323205509"><A NAME="_Toc323610938"><A NAME="_Toc383864955"><A NAME="_Toc385057985"><A NAME="_Toc405794806"><A NAME="_Toc410109144">11.2.2.&#9;DSA</A></A></A></A></A></A></A></A></A> without hashing</A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The DSA without hashing mechanism, denoted <B>CKM_DSA</B>, is a mechanism for single-part signatures and verification based on the Digital Signature Algorithm defined in FIPS PUB 186. (This mechanism corresponds only to the part of DSA that processes the 20-byte hash value; it does not compute the hash value.)</P>
<P ALIGN="JUSTIFY">For the purposes of this mechanism, a DSA signature is a 40-byte string, corresponding to the concatenation of the DSA values <I>r</I> and <I>s</I>, each represented most-significant byte first.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204902"><A NAME="_Toc383864551"><A NAME="_Toc405795015"><A NAME="_Toc410108884">Table 53, DSA: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=438>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA private key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA public key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20, 40<SUP>2</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO </B>structure specify the supported range of DSA prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057986"><A NAME="_Toc405794807"><A NAME="_Toc410109145">11.2.3.&#9;DSA with SHA-1</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The DSA with SHA-1 mechanism, denoted <B>CKM_DSA_SHA1</B>, is a mechanism for single- and multiple-part signatures and verification based on the Digital Signature Algorithm defined in FIPS PUB 186.  This mechanism computes the entire DSA specification, including the hashing with SHA-1.</P>
<P ALIGN="JUSTIFY">For the purposes of this mechanism, a DSA signature is a 40-byte string, corresponding to the concatenation of the DSA values <I>r</I> and <I>s</I>, each represented most-significant byte first.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795016"><A NAME="_Toc410108885">Table 54, DSA with SHA-1: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=438>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA private key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA public key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any, 40<SUP>2</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of DSA prime sizes, in bits.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057987"><A NAME="_Toc405794808"><A NAME="_Toc410109146">11.2.4.&#9;FORTEZZA timestamp</A></A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The FORTEZZA timestamp mechanism, denoted  <B>CKM_FORTEZZA_TIMESTAMP</B>, is a mechanism for single-part signatures and verification.  The signatures it produces and verifies are DSA digital signatures over the provided hash value and the current time.</P>
<P ALIGN="JUSTIFY">It has no parameters.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table. The input and output data may begin at the same location in memory.</P>
<B><P><A NAME="_Toc405795017"><A NAME="_Toc410108886">Table 55, FORTEZZA Timestamp: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=438>
<TR><TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA private key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>DSA public key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20, 40<SUP>2</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of DSA prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057988"><A NAME="_Toc405794809"><A NAME="_Ref407416671"><A NAME="_Toc410109147"><A NAME="_Toc322855316"><A NAME="_Toc322945158"><A NAME="_Toc323000725"><A NAME="_Toc323024176"><A NAME="_Toc323205510"><A NAME="_Toc323610939"><A NAME="_Toc383864956">11.3.&#9;About ECDSA</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The ECDSA (Elliptic Curve Digital Signature Algorithm) in this document is the one described in the ANSI X9.62 working draft specification of November 17, 1997.  It is hoped that the parts of this document that Cryptoki references will not change in the final ANSI X9.62 document, but there is no guarantee that this will be the case.</P>
<P ALIGN="JUSTIFY">In this working draft, there are 3 different varieties of ECDSA defined:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>ECDSA using a field with an odd prime number of elements.</LI></P>
<P ALIGN="JUSTIFY"><LI>ECDSA using a field of characteristic 2 whose elements are represented using a polynomial basis.</LI></P>
<P ALIGN="JUSTIFY"><LI>ECDSA using a field of characteristic 2 whose elements are represented using an optimal normal basis.</LI></P></OL>

<P ALIGN="JUSTIFY">An ECDSA key in Cryptoki contains information about which variety of ECDSA it is suited for.  It is preferable that a Cryptoki library which can perform ECDSA mechanisms be capable of performing operations with all 3 varieties of ECDSA; however, this is not required.</P>
<P ALIGN="JUSTIFY">If an attempt to create, generate, derive, or unwrap an ECDSA key of an unsupported variety (or of an unsupported size of a supported variety)  is made, that attempt should fail with the error code CKR_TEMPLATE_INCONSISTENT.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109148"><A NAME="_Toc385057989"><A NAME="_Toc405794810">11.4.&#9;ECDSA mechanisms</A></P><ul>
<ul>

<P><A NAME="_Toc410109149">11.4.1.&#9;ECDSA key pair generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The ECDSA key pair generation mechanism, denoted <B>CKM_DSA_KEY_PAIR_GEN</B>, is a key pair generation mechanism for ECDSA.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates ECDSA public/private key pairs with particular ECDSA parameters, as specified in the <B>CKA_ECDSA_PARAMS</B> attribute of the template for the public key.  Note that this version of Cryptoki does not include a mechanism for generating these ECDSA parameters.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_EC_POINT</B> attributes to the new public key and the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, <B>CKA_ECDSA_PARAMS</B> and <B>CKA_CKA_VALUE</B> attributes to the new private key. Other attributes supported by the ECDSA public and private key types (specifically, the flags indicating which functions the keys support) may also be specified in the templates for the keys, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the minimum and maximum supported number of bits in the field sizes, respectively.  For example, if a Cryptoki library supports only ECDSA using a field of characteristic 2 which has between 2<SUP>200</SUP> and 2<SUP>300</SUP> elements, then <I>ulMinKeySize</I> = 201 and <I>ulMaxKeySize</I> = 301 (when written in binary notation, the number 2<SUP>200</SUP> consists of a 1 bit followed by 200 0 bits.  It is therefore a 201-bit number.  Similarly, 2<SUP>300</SUP> is a 301-bit number).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057990"><A NAME="_Toc405794811"><A NAME="_Toc410109150">11.4.2.&#9;ECDSA</A></A> without hashing</A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The ECDSA without hashing mechanism, denoted <B>CKM_ECDSA</B>, is a mechanism for single-part signatures and verification for ECDSA.  (This mechanism corresponds only to the part of ECDSA that processes the 20-byte hash value; it does not compute the hash value.)</P>
<P ALIGN="JUSTIFY">For the purposes of this mechanism, an ECDSA signature is a 40-byte string, corresponding to the concatenation of the ECDSA values <I>r</I> and <I>s</I>, each represented most-significant byte first.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795018"><A NAME="_Toc410108887">Table 56, ECDSA: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=444>
<TR><TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign<SUP>1</SUP></FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ECDSA private key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify<SUP>1</SUP></FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ECDSA public key</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20, 40<SUP>2</SUP></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">1</SUP> Single-part operations only.</P>
<SUP><P ALIGN="JUSTIFY">2 </SUP>Data length, signature length.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc385057991"><A NAME="_Toc405794812">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the minimum and maximum supported number of bits in the field sizes, respectively.  For example, if a Cryptoki library supports only ECDSA using a field of characteristic 2 which has between 2<SUP>200</SUP> and 2<SUP>300</SUP> elements (inclusive), then <I>ulMinKeySize</I> = 201 and <I>ulMaxKeySize</I> = 301 (when written in binary notation, the number 2<SUP>200</SUP> consists of a 1 bit followed by 200 0 bits.  It is therefore a 201-bit number.  Similarly, 2<SUP>300</SUP> is a 301-bit number).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109151">11.4.3.&#9;ECDSA with SHA-1</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The ECDSA with SHA-1 mechanism, denoted <B>CKM_ECDSA_SHA1</B>, is a mechanism for single- and multiple-part signatures and verification for ECDSA.  This mechanism computes the entire ECDSA specification, including the hashing with SHA-1.</P>
<P ALIGN="JUSTIFY">For the purposes of this mechanism, an ECDSA signature is a 40-byte string, corresponding to the concatenation of the ECDSA values <I>r</I> and <I>s</I>, each represented most-significant byte first.</P>
<P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795019"><A NAME="_Toc410108888">Table 57, ECDSA with SHA-1: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=427>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="31%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="26%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ECDSA private key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="26%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>ECDSA public key</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any, 40<SUP>2</SUP></FONT></TD>
<TD WIDTH="26%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">N/A</FONT></TD>
</TR>
</TABLE>

<SUP><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">2</SUP> Data length, signature length.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc385057992"><A NAME="_Toc405794813">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the minimum and maximum supported number of bits in the field sizes, respectively.  For example, if a Cryptoki library supports only ECDSA using a field of characteristic 2 which has between 2<SUP>200</SUP> and 2<SUP>300</SUP> elements, then <I>ulMinKeySize</I> = 201 and <I>ulMaxKeySize</I> = 301 (when written in binary notation, the number 2<SUP>200</SUP> consists of a 1 bit followed by 200 0 bits.  It is therefore a 201-bit number.  Similarly, 2<SUP>300</SUP> is a 301-bit number).</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109152">11.5.&#9;Diffie-Hellman mechanisms</A></A></A></P>
<P><A NAME="_Toc385057993"><A NAME="_Toc405794814"><A NAME="_Toc410109153">11.5.1.&#9;PKCS #3 Diffie-Hellman key pair generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The PKCS #3 Diffie-Hellman key pair generation mechanism, denoted <B>CKM_DH_PKCS_KEY_PAIR_GEN</B>, is a key pair generation mechanism based on Diffie-Hellman key agreement, as defined in PKCS #3.  This is what PKCS #3 calls &quot;phase I&quot;.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates Diffie-Hellman public/private key pairs with a particular prime and base, as specified in the <B>CKA_PRIME</B> and <B>CKA_BASE</B> attributes of the template for the public key. If the <B>CKA_VALUE_BITS</B> attribute of the private key is specified, the mechanism limits the length in bits of the private value, as described in PKCS #3.  Note that this version of Cryptoki does not include a mechanism for generating a prime and base.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new public key and the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, <B>CKA_PRIME</B>, <B>CKA_BASE</B>, and <B>CKA_VALUE</B> (and the <B>CKA_VALUE_BITS</B> attribute, if it is not already provided in the template) attributes to the new private key; other attributes required by the Diffie-Hellman public and private key types must be specified in the templates.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of Diffie-Hellman prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855317"><A NAME="_Toc322945159"><A NAME="_Toc323000726"><A NAME="_Toc323024177"><A NAME="_Toc323205511"><A NAME="_Toc323610940"><A NAME="_Toc383864957"><A NAME="_Toc385057994"><A NAME="_Toc405794815"><A NAME="_Toc410109154">11.5.2.&#9;PKCS #3 Diffie-Hellman key derivation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The PKCS #3 Diffie-Hellman key derivation mechanism, denoted <B>CKM_DH_PKCS_DERIVE</B>, is a mechanism for key derivation based on Diffie-Hellman key agreement, as defined in PKCS #3. This is what PKCS #3 calls &quot;phase II&quot;.</P>
<P ALIGN="JUSTIFY">It has a parameter, which is the public value of the other party in the key agreement protocol, represented as a Cryptoki &quot;Big integer&quot; (<I>i.e.</I>, a sequence of bytes, most-significant byte first).</P>
<P ALIGN="JUSTIFY">This mechanism derives a secret key from a Diffie-Hellman private key and the public value of the other party.  It computes a Diffie-Hellman secret value from the public value and private key according to PKCS #3, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template. (The truncation removes bytes from the leading end of the secret value.) The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">The derived key inherits the values of the <B>CKA_SENSITIVE</B>, <B>CKA_ALWAYS_SENSITIVE</B>, <B>CKA_EXTRACTABLE</B>, and <B>CKA_NEVER_EXTRACTABLE</B> attributes from the base key.  The values of the <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes may be overridden in the template for the derived key, however.  Of course, if the base key has the <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the template may not specify that the derived key should have the <B>CKA_SENSITIVE</B> attribute set to FALSE; similarly, if the base key has the <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the template may not specify that the derived key should have the <B>CKA_EXTRACTABLE</B> attribute set to TRUE.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of Diffie-Hellman prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057995"><A NAME="_Toc405794816"><A NAME="_Toc410109155"><A NAME="_Toc322855318"><A NAME="_Toc322945160"><A NAME="_Toc323000727"><A NAME="_Toc323024178"><A NAME="_Toc323205512"><A NAME="_Toc323610941"><A NAME="_Toc383864958">11.6.&#9;KEA mechanism parameters</A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc385057996"><A NAME="_Toc405794817"><A NAME="_Toc410109156">CK_KEA_DERIVE_PARAMS</A>; CK_KEA_DERIVE_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_KEA_DERIVE_PARAMS</B> is a structure that provides the parameters to the <B>CKM_KEA_DERIVE</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_KEA_DERIVE_PARAMS {</P>
<P>  CK_BBOOL isSender;&#9;&#9;</P>
<P>  CK_ULONG ulRandomLen;</P>
<P>  CK_BYTE_PTR pRandomA;</P>
<P>  CK_BYTE_PTR pRandomB;</P>
<P>  CK_ULONG ulPublicDataLen;</P>
<P>  CK_BYTE_PTR pPublicData;</P>
<P>} CK_KEA_DERIVE_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>isSender</I>&#9;Option for generating the key (called a TEK). The value is TRUE if the sender (originator) generates the TEK, FALSE if the recipient is regenerating the TEK.</P>
<P>&#9;<I>ulRandomLen</I>&#9;size of random Ra and Rb, in bytes</P>
<P>&#9;<I>pRandomA</I> &#9;pointer to Ra data</P>
<P>&#9;<I>pRandomB</I>&#9;pointer to Rb data</P>
<P>&#9;<I>ulPublicDataLen</I> &#9;other party’s KEA public key size</P><ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>pPublicData</I>&#9;pointer to other party’s KEA public key value</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_KEA_DERIVE_PARAMS_PTR</B> is a pointer to a <B>CK_KEA_DERIVE_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385057998"><A NAME="_Toc405794818"><A NAME="_Toc410109157">11.7.&#9;KEA mechanisms</A></A></A></P>
<P><A NAME="_Toc385057999"><A NAME="_Toc405794819"><A NAME="_Toc410109158">11.7.1.&#9;KEA key pair generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The KEA key pair generation mechanism, denoted <B>CKM_KEA_KEY_PAIR_GEN</B>, is a key pair generation mechanism</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates KEA public/private key pairs with a particular prime, subprime and base, as specified in the <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B>, and <B>CKA_BASE</B> attributes of the template for the public key.  Note that this version of Cryptoki does not include a mechanism for generating these KEA parameters.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B> and <B>CKA_VALUE</B> attributes to the new public key and the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, <B>CKA_PRIME</B>, <B>CKA_SUBPRIME</B>, <B>CKA_BASE</B>, and <B>CKA_VALUE</B> attributes to the new private key. Other attributes supported by the KEA public and private key types (specifically, the flags indicating which functions the keys support) may also be specified in the templates for the keys, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of KEA prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794820"><A NAME="_Toc385058000"><A NAME="_Toc410109159">11.7.2.&#9;KEA key derivation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The KEA key derivation mechanism, denoted <B>CKM_KEA_DERIVE</B>, is a mechanism for key derivation based on KEA, the Key Exchange Algorithm.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_KEA_DERIVE_PARAMS</B> structure.</P>
<P ALIGN="JUSTIFY">This mechanism derives a secret value, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template.  (The truncation removes bytes from the leading end of the secret value.)  The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">The derived key inherits the values of the <B>CKA_SENSITIVE</B>, <B>CKA_ALWAYS_SENSITIVE</B>, <B>CKA_EXTRACTABLE</B>, and <B>CKA_NEVER_EXTRACTABLE</B> attributes from the base key.  The values of the <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes may be overridden in the template for the derived key, however.  Of course, if the base key has the <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the template may not specify that the derived key should have the <B>CKA_SENSITIVE</B> attribute set to FALSE; similarly, if the base key has the <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the template may not specify that the derived key should have the <B>CKA_EXTRACTABLE</B> attribute set to TRUE.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of KEA prime sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058007"><A NAME="_Toc405794821"><A NAME="_Toc410109160"><A NAME="_Toc323624147">11.8.&#9;Generic secret key mechanisms</A></A></A></P>
<P><A NAME="_Toc385058008"><A NAME="_Toc405794822"><A NAME="_Toc410109161">11.8.1.&#9;Generic secret key generation</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The generic secret key generation mechanism, denoted <B>CKM_GENERIC_SECRET_KEY_GEN</B>, is used to generate generic secret keys. The generated keys take on any attributes provided in the template passed to the <B>C_GenerateKey</B> call, and the <B>CKA_VALUE_LEN</B> attribute specifies the length of the key to be generated. </P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The template supplied must specify a value for the <B>CKA_VALUE_LEN </B>attribute.  If the template specifies an object type and a class, they must have the following values:</P>
<P ALIGN="JUSTIFY">&#9;<B>CK_OBJECT_CLASS</B> = <B>CKO_SECRET_KEY</B>;</P>
<P ALIGN="JUSTIFY">&#9;<B>CK_KEY_TYPE</B> = <B>CKK_GENERIC_SECRET</B>;</P>
<P ALIGN="JUSTIFY"><A NAME="_Ref384745181"><A NAME="_Toc385058009">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO </B>structure specify the supported range of key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref388945866"><A NAME="_Ref388945927"><A NAME="_Ref388945963"><A NAME="_Toc405794823"><A NAME="_Toc410109162">11.9.&#9;Wrapping/unwrapping private keys (RSA, Diffie-Hellman, and DSA)</A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cryptoki Version 2.01 allows the use of secret keys for wrapping and unwrapping RSA private keys, Diffie-Hellman private keys, and DSA private keys.  For wrapping, a private key is BER-encoded according to PKCS #8’s PrivateKeyInfo ASN.1 type.  PKCS #8 requires an algorithm identifier for the type of the secret key.  The object identifiers for the required algorithm identifiers are as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>rsaEncryption OBJECT IDENTIFIER ::= { pkcs-1 1 }</P>

<P>dhKeyAgreement OBJECT IDENTIFIER ::= { pkcs-3 1 }</P>

<P>id-dsa OBJECT IDENTIFIER ::= {</P>
<P>  iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 }</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">where</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>pkcs-1 OBJECT IDENTIFIER ::= {</P>
<P>  iso(1) member-body(2) US(840) rsadsi(113549) pkcs(1) 1 }</P>

<P>pkcs-3 OBJECT IDENTIFIER ::= {</P>
<P>  iso(1) member-body(2) US(840) rsadsi(113549) pkcs(1) 3 }</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">These parameters for the algorithm identifiers have the following types, respectively:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>NULL</P>

<P>DHParameter ::= SEQUENCE {</P>
<P>  prime INTEGER,  -- p</P>
<P>  base INTEGER,  -- g</P>
<P>  privateValueLength INTEGER OPTIONAL</P>
<P>}</P>

<P>Dss-Parms ::= SEQUENCE {</P>
<P>  p INTEGER,</P>
<P>  q INTEGER,</P>
<P>  g INTEGER</P>
<P>}</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Within the PrivateKeyInfo type:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>RSA private keys are BER-encoded according to PKCS #1’s RSAPrivateKey ASN.1 type.  This type requires values to be present for <I>all</I> the attributes specific to Cryptoki’s RSA private key objects.  In other words,  if a Cryptoki library does not have values for an RSA private key’s <B>CKA_MODULUS</B>, <B>CKA_PUBLIC_EXPONENT</B>, <B>CKA_PRIVATE_EXPONENT</B>, <B>CKA_PRIME_1</B>, <B>CKA_PRIME_2</B>, <B>CKA_EXPONENT_1</B>, <B>CKA_EXPONENT2</B>, and <B>CKA_COEFFICIENT</B> values, it cannot create an RSAPrivateKey BER-encoding of the key, and so it cannot prepare it for wrapping.</LI></P>
<P ALIGN="JUSTIFY"><LI>Diffie-Hellman private keys are represented as BER-encoded ASN.1 type INTEGER.</LI></P>
<P ALIGN="JUSTIFY"><LI>DSA private keys are represented as BER-encoded ASN.1 type INTEGER.</LI></P></UL>

<P ALIGN="JUSTIFY">Once a private key has been BER-encoded as a PrivateKeyInfo type, the resulting string of bytes is encrypted with the secret key.  This encryption must be done in CBC mode with PKCS padding.</P>
<P ALIGN="JUSTIFY">Unwrapping a wrapped private key undoes the above procedure.  The CBC-encrypted ciphertext is decrypted, and the PKCS padding is removed.  The data thereby obtained are parsed as a PrivateKeyInfo type, and the wrapped key is produced.  An error will result if the original wrapped key does not decrypt properly, or if the decrypted unpadded data does not parse properly, or its type does not match the key type specified in the template for the new key.  The unwrapping mechanism contributes only those attributes specified in the PrivateKeyInfo type to the newly-unwrapped key; other attributes must be specified in the template, or will take their default values.</P>
<P ALIGN="JUSTIFY">Earlier drafts of PKCS #11 Version 2.0 and Version 2.01 used the object identifier</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>DSA OBJECT IDENTIFIER ::= { algorithm 12 }</P>
<P>algorithm OBJECT IDENTIFIER ::= {</P>
<P>  iso(1) identifier-organization(3) oiw(14) secsig(3) algorithm(2) }</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">with associated parameters</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>DSAParameters ::= SEQUENCE {</P>
<P>  prime1 INTEGER,  -- modulus p</P>
<P>  prime2 INTEGER,  -- modulus q</P>
<P>  base INTEGER  -- base g</P>
<P>}</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">for wrapping DSA private keys.  Note that although the two structures for holding DSA parameters appear identical when instances of them are encoded, the two corresponding object identifiers are different.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058010"><A NAME="_Toc405794824"><A NAME="_Toc410109163">11.10.&#9;About RC2</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2 is a block cipher which is trademarked by RSA Data Security.  It has a variable keysize and an additional parameter, the &quot;effective number of bits in the RC2 search space&quot;, which can take on values in the range 1-1024, inclusive.  The effective number of bits in the RC2 search space is sometimes specified by an RC2 &quot;version number&quot;; this &quot;version number&quot; is <I>not</I> the same thing as the &quot;effective number of bits&quot;, however.  There is a canonical way to convert from one to the other.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058011"><A NAME="_Toc405794825"><A NAME="_Toc410109164">11.11.&#9;RC2 mechanism parameters</A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc385058012"><A NAME="_Toc405794826"><A NAME="_Toc410109165"><A NAME="_Toc323024077"><A NAME="_Toc323205408"><A NAME="_Toc323610838"><A NAME="_Toc383864947">CK_RC2_PARAMS</A>; CK_RC2_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC2_PARAMS</B> provides the parameters to the <B>CKM_RC2_ECB</B> and <B>CKM_RC2_MAC</B> mechanisms.  It holds the effective number of bits in the RC2 search space.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_RC2_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC2_PARAMS_PTR</B> is a pointer to a <B>CK_RC2_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc385058014"><A NAME="_Toc405794827"><A NAME="_Toc410109166"></FONT><B><FONT FACE="Palatino">CK_RC2_CBC</A>_PARAMS</A></A></A></A>; CK_RC2_CBC_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC2_CBC_PARAMS</B> is a structure that provides the parameters to the <B>CKM_RC2_CBC</B> and <B>CKM_RC2_CBC_PAD</B> mechanisms.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_RC2_CBC_PARAMS {</P>
<P>  CK_ULONG ulEffectiveBits;</P>
<P>  CK_BYTE iv[8];</P>
<P>} CK_RC2_CBC_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulEffectiveBits</I>&#9;the effective number of bits in the RC2 search space</P>
<P>&#9;<I>iv</I>&#9;the initialization vector (IV) for cipher block chaining mode</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_RC2_CBC_PARAMS_PTR</B> is a pointer to a <B>CK_RC2_CBC_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc385058016"><A NAME="_Toc405794828"><A NAME="_Toc410109167"></FONT><B><FONT FACE="Palatino">CK_RC2_MAC_GENERAL_PARAMS</A>; CK_RC2_MAC_GENERAL_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC2_MAC_GENERAL_PARAMS</B> is a structure that provides the parameters to the <B>CKM_RC2_MAC_GENERAL</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_RC2_MAC_GENERAL_PARAMS {</P>
<P>  CK_ULONG ulEffectiveBits;</P>
<P>  CK_ULONG ulMacLength;</P>
<P>} CK_RC2_MAC_GENERAL_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulEffectiveBits</I>&#9;the effective number of bits in the RC2 search space</P>
<P>&#9;<I>ulMacLength</I>&#9;length of the MAC produced, in bytes</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_RC2_MAC_GENERAL_PARAMS_PTR</B> is a pointer to a <B>CK_RC2_MAC_GENERAL_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058018"><A NAME="_Toc405794829"><A NAME="_Toc410109168">11.12.&#9;RC2 mechanisms</A></A></A></P>
<P><A NAME="_Toc385058019"><A NAME="_Toc405794830"><A NAME="_Toc410109169">11.12.1.&#9;RC2 key generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The RC2 key generation mechanism, denoted <B>CKM_RC2_KEY_GEN</B>, is a key generation mechanism for RSA Data Security’s block cipher RC2.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates RC2 keys with a particular length in bytes, as specified in the <B>CKA_VALUE_LEN</B> attribute of the template for the key.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key. Other attributes supported by the RC2 key type (specifically, the flags indicating which functions the key supports) may be specified in the template for the key, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC2 key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855319"><A NAME="_Toc322945161"><A NAME="_Toc323000728"><A NAME="_Toc323024179"><A NAME="_Toc323205513"><A NAME="_Toc323610942"><A NAME="_Toc383864959"><A NAME="_Toc385058020"><A NAME="_Toc405794831"><A NAME="_Toc410109170">11.12.2.&#9;RC2-ECB</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2-ECB, denoted <B>CKM_RC2_ECB</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC2 and electronic codebook mode as defined in FIPS PUB 81.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC2_PARAMS</B>, which indicates the effective number of bits in the RC2 search space.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key.  Of course, a particular token may not be able to wrap/unwrap every secret key that it supports.  For wrapping, the mechanism encrypts the value of the <B>CKA_VALUE</B> attribute of the key that is wrapped, padded on the trailing end with up to seven null bytes so that the resulting length is a multiple of eight. The output data is the same length as the padded input data. It does not wrap the key type, key length, or any other information about the key; the application must convey these separately.</P>
<P ALIGN="JUSTIFY">For unwrapping, the mechanism decrypts the wrapped key, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one, and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template.  The mechanism contributes the result as the <B>CKA_VALUE </B>attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204903"><A NAME="_Toc383864552"><A NAME="_Toc405795020"><A NAME="_Toc410108889">Table 58, RC2-ECB: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of 8</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC2 effective number of bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855320"><A NAME="_Toc322945162"><A NAME="_Toc323000729"><A NAME="_Toc323024180"><A NAME="_Toc323205514"><A NAME="_Toc323610943"><A NAME="_Toc383864960"><A NAME="_Toc385058021"><A NAME="_Toc405794832"><A NAME="_Toc410109171">11.12.3.&#9;RC2-CBC</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2-CBC, denoted <B>CKM_RC2_CBC</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC2 and cipher-block chaining mode as defined in FIPS PUB 81.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC2_CBC_PARAMS</B> structure, where the first field indicates the effective number of bits in the RC2 search space, and the next field is the initialization vector for cipher block chaining mode.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key.  Of course, a particular token may not be able to wrap/unwrap every secret key that it supports.  For wrapping, the mechanism encrypts the value of the <B>CKA_VALUE</B> attribute of the key that is wrapped, padded on the trailing end with up to seven null bytes so that the resulting length is a multiple of eight. The output data is the same length as the padded input data. It does not wrap the key type, key length, or any other information about the key; the application must convey these separately.</P>
<P ALIGN="JUSTIFY">For unwrapping, the mechanism decrypts the wrapped key, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one, and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template.  The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204904"><A NAME="_Toc383864553"><A NAME="_Toc405795021"><A NAME="_Toc410108890">Table 59, RC2-CBC: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of 8</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO </B>structure specify the supported range of RC2 effective number of bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058022"><A NAME="_Toc405794833"><A NAME="_Toc410109172"><A NAME="_Toc322855321"><A NAME="_Toc322945163"><A NAME="_Toc323000730"><A NAME="_Toc323024181"><A NAME="_Toc323205515"><A NAME="_Toc323610944"><A NAME="_Toc383864961">11.12.4.&#9;RC2-CBC with PKCS padding</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2-CBC with PKCS padding, denoted <B>CKM_RC2_CBC_PAD</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC2; cipher-block chaining mode as defined in FIPS PUB 81; and the block cipher padding method detailed in PKCS #7.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC2_CBC_PARAMS</B> structure, where the first field indicates the effective number of bits in the RC2 search space, and the next field is the initialization vector.</P>
<P ALIGN="JUSTIFY">The PKCS padding in this mechanism allows the length of the plaintext value to be recovered from the ciphertext value.  Therefore, when unwrapping keys with this mechanism, no value should be specified for the <B>CKA_VALUE_LEN</B> attribute.</P>
<P ALIGN="JUSTIFY">In addition to being able to wrap and unwrap secret keys, this mechanism can wrap and unwrap RSA, Diffie-Hellman, and DSA private keys (see Section 11.9 for details).  The entries in Table 60 for data length constraints when wrapping and unwrapping keys do not apply to wrapping and unwrapping private keys.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Ref384745443"><A NAME="_Toc405795022"><A NAME="_Toc410108891">Table 60</A>, RC2-CBC with PKCS Padding: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=486>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of 8</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and 8 bytes shorter than input length</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of 8</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and 8 bytes shorter than input length</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC2 effective number of bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384721393"><A NAME="_Toc385058023"><A NAME="_Toc405794834"><A NAME="_Toc410109173">11.12.5.&#9;General-length RC2-MAC</A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">General-length RC2-MAC, denoted <B>CKM_RC2_MAC_GENERAL</B>, is a mechanism for single- and multiple-part signatures and verification, based on RSA Data Security’s block cipher RC2 and data authentication as defined in FIPS PUB 113.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC2_MAC_GENERAL_PARAMS </B>structure, which specifies the effective number of bits in the RC2 search space and the output length desired from the mechanism.</P>
<P ALIGN="JUSTIFY">The output bytes from this mechanism are taken from the start of the final RC2 cipher block produced in the MACing process.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204905"><A NAME="_Toc383864554"><A NAME="_Toc405795023"><A NAME="_Toc410108892">Table 61, General-length RC2-MAC: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=498>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-8, as specified in parameters</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-8, as specified in parameters</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC2 effective number of bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058024"><A NAME="_Toc405794835"><A NAME="_Toc410109174"><A NAME="_Toc322855322"><A NAME="_Toc322945164"><A NAME="_Toc323000731"><A NAME="_Toc323024182"><A NAME="_Toc323205516"><A NAME="_Toc323610945"><A NAME="_Toc383864962">11.12.6.&#9;RC2-MAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC2-MAC, denoted by <B>CKM_RC2_MAC</B>, is a special case of the general-length RC2-MAC mechanism (see Section 11.12.5).  Instead of taking a <B>CK_RC2_MAC_GENERAL_PARAMS</B> parameter, it takes a <B>CK_RC2_PARAMS</B> parameter, which only contains the effective number of bits in the RC2 search space.  RC2-MAC always produces and verifies 4-byte MACs.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795024"><A NAME="_Toc410108893">Table 62, RC2-MAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=498>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC2 effective number of bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058025"><A NAME="_Toc405794836"><A NAME="_Toc410109175">11.13.&#9;RC4 mechanisms</A></A></A></P>
<P><A NAME="_Toc385058026"><A NAME="_Toc405794837"><A NAME="_Toc410109176">11.13.1.&#9;RC4 key generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The RC4 key generation mechanism, denoted <B>CKM_RC4_KEY_GEN</B>, is a key generation mechanism for RSA Data Security’s proprietary stream cipher RC4.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates RC4 keys with a particular length in bytes, as specified in the CK<B>A_VALUE_LEN</B> attribute of the template for the key.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key. Other attributes supported by the RC4 key type (specifically, the flags indicating which functions the key supports) may be specified in the template for the key, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO </B>structure specify the supported range of RC4 key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855323"><A NAME="_Toc322945165"><A NAME="_Toc323000732"><A NAME="_Toc323024183"><A NAME="_Toc323205517"><A NAME="_Toc323610946"><A NAME="_Toc383864963"><A NAME="_Toc385058027"><A NAME="_Toc405794838"><A NAME="_Toc410109177">11.13.2.&#9;RC4</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC4, denoted <B>CKM_RC4</B>, is a mechanism for single- and multiple-part encryption and decryption based on RSA Data Security’s proprietary stream cipher RC4.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204906"><A NAME="_Toc383864555"><A NAME="_Toc405795025"><A NAME="_Toc410108894">Table 63, RC4: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=526>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC4</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC4</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC4 key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058028"><A NAME="_Toc405794839"><A NAME="_Toc410109178">11.14.&#9;About RC5</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5 is a parametrizable block cipher for which RSA Data Security has patent pending.  It has a variable wordsize, a variable keysize, and a variable number of rounds.  The blocksize of RC5 is always equal to twice its wordsize.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058029"><A NAME="_Toc405794840"><A NAME="_Toc410109179">11.15.&#9;RC5 mechanism parameters</A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc385058030"><A NAME="_Toc405794841"><A NAME="_Toc410109180">CK_RC5_PARAMS</A>; CK_RC5_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC5_PARAMS</B> provides the parameters to the <B>CKM_RC5_ECB</B> and <B>CKM_RC5_MAC</B> mechanisms.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_RC5_PARAMS {</P>
<P>  CK_ULONG ulWordsize;</P>
<P>  CK_ULONG ulRounds;</P>
<P>} CK_RC5_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulWordsize</I>&#9;wordsize of RC5 cipher in bytes</P>
<P>&#9;<I>ulRounds</I>&#9;number of rounds of RC5 encipherment</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY"><A NAME="_Toc385058031">CK_RC5_PARAMS_PTR</B> is a pointer to a <B>CK_RC5_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc385058032"><A NAME="_Toc405794842"><A NAME="_Toc410109181"></A></FONT><B><FONT FACE="Palatino">CK_RC5_CBC_PARAMS</A>; CK_RC5_CBC_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC5_CBC_PARAMS</B> is a structure that provides the parameters to the <B>CKM_RC5_CBC</B> and <B>CKM_RC5_CBC_PAD</B> mechanisms.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_RC5_CBC_PARAMS {</P>
<P>  CK_ULONG ulWordsize;</P>
<P>  CK_ULONG ulRounds;</P>
<P>  CK_BYTE_PTR pIv;</P>
<P>  CK_ULONG ulIvLen;</P>
<P>} CK_RC5_CBC_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulWordsize</I>&#9;wordsize of RC5 cipher in bytes</P>
<P>&#9;<I>ulRounds</I>&#9;number of rounds of RC5 encipherment</P>
<P>&#9;<I>pIv</I>&#9;pointer to initialization vector (IV) for CBC encryption</P>
<P>&#9;<I>ulIvLen</I>&#9;length of initialization vector (must be same as blocksize)</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_RC5_CBC_PARAMS_PTR</B> is a pointer to a <B>CK_RC5_CBC_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc385058034"><A NAME="_Toc405794843"><A NAME="_Toc410109182"></FONT><B><FONT FACE="Palatino">CK_RC5_MAC_GENERAL_PARAMS</A>; CK_RC5_MAC_GENERAL_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_RC5_MAC_GENERAL_PARAMS</B> is a structure that provides the parameters to the <B>CKM_RC5_MAC_GENERAL</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_RC5_MAC_GENERAL_PARAMS {</P>
<P>  CK_ULONG ulWordsize;</P>
<P>  CK_ULONG ulRounds;</P>
<P>  CK_ULONG ulMacLength;</P>
<P>} CK_RC5_MAC_GENERAL_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulWordsize</I>&#9;wordsize of RC5 cipher in bytes</P>
<P>&#9;<I>ulRounds</I>&#9;number of rounds of RC5 encipherment</P>
<P>&#9;<I>ulMacLength</I>&#9;length of the MAC produced, in bytes</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_RC5_MAC_GENERAL_PARAMS_PTR</B> is a pointer to a <B>CK_RC5_MAC_GENERAL_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058036"><A NAME="_Toc405794844"><A NAME="_Toc410109183">11.16.&#9;RC5 mechanisms</A></A></A></P>
<P><A NAME="_Toc385058037"><A NAME="_Toc405794845"><A NAME="_Toc410109184"><A NAME="_Toc322855324"><A NAME="_Toc322945166"><A NAME="_Toc323000733"><A NAME="_Toc323024184"><A NAME="_Toc323205518"><A NAME="_Toc323610947"><A NAME="_Toc383864964">11.16.1.&#9;RC5 key generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The RC5 key generation mechanism, denoted <B>CKM_RC5_KEY_GEN</B>, is a key generation mechanism for RSA Data Security’s block cipher RC5.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism generates RC5 keys with a particular length in bytes, as specified in the <B>CKA_VALUE_LEN</B> attribute of the template for the key.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key. Other attributes supported by the RC5 key type (specifically, the flags indicating which functions the key supports) may be specified in the template for the key, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of RC5 key sizes, in bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058038"><A NAME="_Toc405794846"><A NAME="_Toc410109185">11.16.2.&#9;RC5-ECB</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5-ECB, denoted <B>CKM_RC5_ECB</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC5 and electronic codebook mode as defined in FIPS PUB 81.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC5_PARAMS</B>, which indicates the wordsize and number of rounds of encryption to use.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key.  Of course, a particular token may not be able to wrap/unwrap every secret key that it supports.  For wrapping, the mechanism encrypts the value of the <B>CKA_VALUE</B> attribute of the key that is wrapped, padded on the trailing end with null bytes so that the resulting length is a multiple of the cipher blocksize (twice the wordsize). The output data is the same length as the padded input data. It does not wrap the key type, key length, or any other information about the key; the application must convey these separately.</P>
<P ALIGN="JUSTIFY">For unwrapping, the mechanism decrypts the wrapped key, and truncates the result according to the <B>CKA_KEY_TYPE</B> attributes of the template and, if it has one, and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template.  The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795026"><A NAME="_Toc410108895">Table 64, RC5-ECB: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058039"><A NAME="_Toc405794847"><A NAME="_Toc410109186">11.16.3.&#9;RC5-CBC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5-CBC, denoted <B>CKM_RC5_CBC</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC5 and cipher-block chaining mode as defined in FIPS PUB 81.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC5_CBC_PARAMS</B> structure, which specifies the wordsize and number of rounds of encryption to use, as well as the initialization vector for cipher block chaining mode.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key.  Of course, a particular token may not be able to wrap/unwrap every secret key that it supports.  For wrapping, the mechanism encrypts the value of the <B>CKA_VALUE </B>attribute of the key that is wrapped, padded on the trailing end with up to seven null bytes so that the resulting length is a multiple of eight. The output data is the same length as the padded input data. It does not wrap the key type, key length, or any other information about the key; the application must convey these separately.</P>
<P ALIGN="JUSTIFY">For unwrapping, the mechanism decrypts the wrapped key, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one, and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template.  The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795027"><A NAME="_Toc410108896">Table 65, RC5-CBC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=564>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058040"><A NAME="_Toc405794848"><A NAME="_Toc410109187">11.16.4.&#9;RC5-CBC with PKCS padding</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5-CBC with PKCS padding, denoted <B>CKM_RC5_CBC_PAD</B>, is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping, based on RSA Data Security’s block cipher RC5; cipher-block chaining mode as defined in FIPS PUB 81; and the block cipher padding method detailed in PKCS #7.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC5_CBC_PARAMS</B> structure, which specifies the wordsize and number of rounds of encryption to use, as well as the initialization vector for cipher block chaining mode.</P>
<P ALIGN="JUSTIFY">The PKCS padding in this mechanism allows the length of the plaintext value to be recovered from the ciphertext value.  Therefore, when unwrapping keys with this mechanism, no value should be specified for the <B>CKA_VALUE_LEN</B> attribute.</P>
<P ALIGN="JUSTIFY">In addition to being able to wrap and unwrap secret keys, this mechanism can wrap and unwrap RSA, Diffie-Hellman, and DSA private keys (see Section11.9 for details).  The entries in Table 66 for data length constraints when wrapping and unwrapping keys do not apply to wrapping and unwrapping private keys.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Ref384745401"><A NAME="_Toc405795028"><A NAME="_Toc410108897">Table 66</A>, RC5-CBC with PKCS Padding: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=486>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and blocksize bytes shorter than input length</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and blocksize bytes shorter than input length</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384721311"><A NAME="_Toc385058041"><A NAME="_Toc405794849"><A NAME="_Toc410109188">11.16.5.&#9;General-length RC5-MAC</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">General-length RC5-MAC, denoted <B>CKM_RC5_MAC_GENERAL</B>, is a mechanism for single- and multiple-part signatures and verification, based on RSA Data Security’s block cipher RC5 and data authentication as defined in FIPS PUB 113.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_RC5_MAC_GENERAL_PARAMS</B> structure, which specifies the wordsize and number of rounds of encryption to use and the output length desired from the mechanism.</P>
<P ALIGN="JUSTIFY">The output bytes from this mechanism are taken from the start of the final RC5 cipher block produced in the MACing process.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795029"><A NAME="_Toc410108898">Table 67, General-length RC2-MAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=534>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-blocksize, as specified in parameters</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC2</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-blocksize, as specified in parameters</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058042"><A NAME="_Toc405794850"><A NAME="_Toc410109189">11.16.6.&#9;RC5-MAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">RC5-MAC, denoted by <B>CKM_RC5_MAC</B>, is a special case of the general-length RC5-MAC mechanism (see Section 11.16.5).  Instead of taking a <B>CK_RC5_MAC_GENERAL_PARAMS</B> parameter, it takes a <B>CK_RC5_PARAMS</B> parameter.  RC5-MAC always produces and verifies MACs half as large as the RC5 blocksize.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795030"><A NAME="_Toc410108899">Table 68, RC5-MAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=498>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">RC5 wordsize = <FONT FACE="Symbol">&#235;</FONT>
blocksize/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>RC5</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">RC5 wordsize = <FONT FACE="Symbol">&#235;</FONT>
blocksize/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384737733"><A NAME="_Toc385058043"><A NAME="_Toc405794851"><A NAME="_Toc410109190">11.17.&#9;General block cipher mechanism parameters</A></A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc385058044"><A NAME="_Toc405794852"><A NAME="_Toc410109191">CK_MAC_GENERAL_PARAMS</A>; CK_MAC_GENERAL_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_MAC_GENERAL_PARAMS</B> provides the parameters to the general-length MACing mechanisms of the DES, DES3 (triple-DES), CAST, CAST3, CAST128 (CAST5), IDEA, and CDMF ciphers.  It holds the length of the MAC that these mechanisms will produce.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_MAC_GENERAL_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_MAC_GENERAL_PARAMS_PTR</B> is a pointer to a <B>CK_MAC_GENERAL_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384737734"><A NAME="_Toc385058046"><A NAME="_Toc405794853"><A NAME="_Toc410109192">11.18.&#9;General block cipher mechanisms</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">For brevity’s sake, the mechanisms for the DES, DES3 (triple-DES), CAST, CAST3, CAST128 (CAST5), IDEA, and CDMF block ciphers will be described together here.  Each of these ciphers has the following mechanisms, which will be described in a templatized form:</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058047"><A NAME="_Toc405794854"><A NAME="_Toc410109193">11.18.1.&#9;General block cipher key generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has a key generation mechanism, &quot;&lt;NAME&gt; key generation&quot;, denoted <B>CKM_&lt;NAME&gt;_KEY_GEN.</P>
</B><P ALIGN="JUSTIFY">This mechanism does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key. Other attributes supported by the key type (specifically, the flags indicating which functions the key supports) may be specified in the template for the key, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">When DES keys or CDMF keys are generated, their parity bits are set properly, as specified in FIPS PUB 46-2.  Similarly, when a triple-DES key is generated, each of the DES keys comprising it has its parity bits set properly.</P>
<P ALIGN="JUSTIFY">When DES or CDMF keys are generated, it is token-dependent whether or not it is possible for &quot;weak&quot; or &quot;semi-weak&quot; keys to be generated.  Similarly, when triple-DES keys are generated, it is token dependent whether or not it is possible for any of the component DES keys to be &quot;weak&quot; or &quot;semi-weak&quot; keys.</P>
<P ALIGN="JUSTIFY">When CAST, CAST3, or CAST128 (CAST5) keys are generated, the template for the secret key must specify a <B>CKA_VALUE_LEN</B> attribute.</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure may or may not be used.  The CAST, CAST3, and CAST128 (CAST5) ciphers have variable key sizes, and so for the key generation mechanisms for these ciphers, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of key sizes, in bytes.  For the DES, DES3 (triple-DES), IDEA, and CDMF ciphers, these fields are not used.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc322855325"><A NAME="_Toc322945167"><A NAME="_Toc323000734"><A NAME="_Toc323024185"><A NAME="_Toc323205519"><A NAME="_Toc323610948"><A NAME="_Toc383864965"><A NAME="_Toc385058048"><A NAME="_Toc405794855"><A NAME="_Toc410109194">11.18.2.&#9;General block cipher ECB</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has an electronic codebook mechanism, &quot;&lt;NAME&gt;-ECB&quot;, denoted <B>CKM_&lt;NAME&gt;_ECB</B>.  It is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping with &lt;NAME&gt;.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">This mechanism can wrap and unwrap any secret key.  Of course, a particular token may not be able to wrap/unwrap every secret key that it supports.  For wrapping, the mechanism encrypts the value of the <B>CKA_VALUE</B> attribute of the key that is wrapped, padded on the trailing end with null bytes so that the resulting length is a multiple of &lt;NAME&gt;’s blocksize.  The output data is the same length as the padded input data. It does not wrap the key type, key length or any other information about the key; the application must convey these separately.</P>
<P ALIGN="JUSTIFY">For unwrapping, the mechanism decrypts the wrapped key, and truncates the result according to the <B>CKA_KEY_TYPE</B> attribute of the template and, if it has one, and the key type supports it, the <B>CKA_VALUE_LEN</B> attribute of the template. The mechanism contributes the result as the <B>CKA_VALUE</B> attribute of the new key; other attributes required by the key type must be specified in the template.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204907"><A NAME="_Toc383864556"><A NAME="_Toc405795031"><A NAME="_Toc410108900">Table 69, General Block Cipher ECB: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=564>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc322855326"><A NAME="_Toc322945168"><A NAME="_Toc323000735"><A NAME="_Toc323024186"><A NAME="_Toc323205520"><A NAME="_Toc323610949"><A NAME="_Toc383864966"><A NAME="_Toc385058049"><A NAME="_Toc405794856"><A NAME="_Toc410109195">11.18.3.&#9;General block cipher CBC</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has a cipher-block chaining mode, &quot;&lt;NAME&gt;-CBC&quot;, denoted <B>CKM_&lt;NAME&gt;_CBC</B>.  It is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping with &lt;NAME&gt;.</P>
<P ALIGN="JUSTIFY">It has a parameter, an initialization vector for cipher block chaining mode.  The initialization vector has the same length as &lt;NAME&gt;’s blocksize.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204908"><A NAME="_Toc383864557"><A NAME="_Toc405795032"><A NAME="_Toc410108901">Table 70, General Block Cipher CBC: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=564>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P><A NAME="_Toc322855327"><A NAME="_Toc322945169"><A NAME="_Toc323000736"><A NAME="_Toc323024187">C_WrapKey</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">determined by type of key being unwrapped or CKA_VALUE_LEN</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058050"><A NAME="_Toc405794857"><A NAME="_Toc410109196"><A NAME="_Toc323205521"><A NAME="_Toc323610950"><A NAME="_Toc383864967">11.18.4.&#9;General block cipher CBC with PKCS padding</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has a cipher-block chaining mode with PKCS padding, &quot;&lt;NAME&gt;-CBC with PKCS padding&quot;, denoted <B>CKM_&lt;NAME&gt;_CBC_PAD</B>.  It is a mechanism for single- and multiple-part encryption and decryption; key wrapping; and key unwrapping with &lt;NAME&gt;.  All ciphertext is padded with PKCS padding.</P>
<P ALIGN="JUSTIFY">It has a parameter, an initialization vector for cipher block chaining mode.  The initialization vector has the same length as &lt;NAME&gt;’s blocksize.</P>
<P ALIGN="JUSTIFY">The PKCS padding in this mechanism allows the length of the plaintext value to be recovered from the ciphertext value.  Therefore, when unwrapping keys with this mechanism, no value should be specified for the <B>CKA_VALUE_LEN</B> attribute.</P>
<P ALIGN="JUSTIFY">In addition to being able to wrap and unwrap secret keys, this mechanism can wrap and unwrap RSA, Diffie-Hellman, and DSA private keys (see Section 11.9 for details).  The entries in Table 71 for data length constraints when wrapping and unwrapping keys do not apply to wrapping and unwrapping private keys.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Ref384745320"><A NAME="_Ref384745271"><A NAME="_Toc405795033"><A NAME="_Toc410108902">Table 71</A>, General Block Cipher CBC with PKCS Padding: Key And Data Length</A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=486>
<TR><TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and blocksize bytes shorter than input length</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">input length rounded up to multiple of blocksize</FONT></TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of blocksize</FONT></TD>
<TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">between 1 and blocksize bytes shorter than input length</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384723682"><A NAME="_Toc385058051"><A NAME="_Toc405794858"><A NAME="_Toc410109197">11.18.5.&#9;General-length general block cipher MAC</A></A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has a general-length MACing mode, &quot;General-length &lt;NAME&gt;-MAC&quot;, denoted <B>CKM_&lt;NAME&gt;_MAC_GENERAL</B>.  It is a mechanism for single- and multiple-part signatures and verification.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which specifies the size of the output.</P>
<P ALIGN="JUSTIFY">The output bytes from this mechanism are taken from the start of the final cipher block produced in the MACing process.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204909"><A NAME="_Toc383864558"><A NAME="_Toc405795034"><A NAME="_Toc410108903">Table 72, General-length General Block Cipher MAC: Key And Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=528>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-blocksize, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-blocksize, depending on parameters</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058052"><A NAME="_Toc405794859"><A NAME="_Toc410109198"><A NAME="_Toc322855328"><A NAME="_Toc322945170"><A NAME="_Toc323000737"><A NAME="_Toc323024188"><A NAME="_Toc323205522"><A NAME="_Toc323610951"><A NAME="_Toc383864968">11.18.6.&#9;General block cipher MAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cipher &lt;NAME&gt; has a MACing mechanism, &quot;&lt;NAME&gt;-MAC&quot;, denoted <B>CKM_&lt;NAME&gt;_MAC</B>.  This mechanism is a special case of the <B>CKM_&lt;NAME&gt;_MAC_GENERAL</B> mechanism described in Section 11.18.5.  It always produces an output of size half as large as &lt;NAME&gt;’s blocksize.</P>
<P ALIGN="JUSTIFY">This mechanism has no parameters.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795035"><A NAME="_Toc410108904">Table 73, General Block Cipher MAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=498>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#235;</FONT>
blocksize/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>&lt;NAME&gt;</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER"><FONT FACE="Symbol">&#235;</FONT>
blocksize/2<FONT FACE="Symbol">&#251;</FONT>
</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058053"><A NAME="_Toc405794860"><A NAME="_Toc410109199">11.19.&#9;Double-length DES mechanisms</A></A></A></P>
<P><A NAME="_Toc385058054"><A NAME="_Toc405794861"><A NAME="_Toc410109200">11.19.1.&#9;Double-length DES key generation</A></A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The double-length DES key generation mechanism, denoted <B>CKM_DES2_KEY_GEN</B>, is a key generation mechanism for double-length DES keys.  The DES keys making up a double-length DES key both have their parity bits set properly, as specified in FIPS PUB 46-2.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the<B> CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key. Other attributes supported by the double-length DES key type (specifically, the flags indicating which functions the key supports) may be specified in the template for the key, or else are assigned default initial values.</P>
<P ALIGN="JUSTIFY">Double-length DES keys can be used with all the same mechanisms as triple-DES keys: <B>CKM_DES_ECB</B>, <B>CKM_DES_CBC</B>, <B>CKM_DES_CBC_PAD</B>, <B>CKM_DES_MAC_GENERAL</B>, and <B>CKM_DES_MAC</B> (these mechanisms are described in templatized form in Section 11.18).  Triple-DES encryption with a double-length DES key consists of three steps: encryption with the first DES key; decryption with the second DES key; and encryption with the first DES key.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc385058055"><A NAME="_Toc322855333"><A NAME="_Toc322945175"><A NAME="_Toc323000742"><A NAME="_Toc323024193">When double-length DES keys are generated, it is token-dependent whether or not it is possible for either of the component DES keys to be &quot;weak&quot; or &quot;semi-weak&quot; keys.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794862"><A NAME="_Toc410109201">11.20.&#9;SKIPJACK mechanism parameters</A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc385058056"><A NAME="_Toc405794863"><A NAME="_Toc410109202">CK_SKIPJACK_PRIVATE_WRAP_PARAMS</A>; CK_SKIPJACK_PRIVATE_WRAP_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SKIPJACK_PRIVATE_WRAP_PARAMS</B> is a structure that provides the parameters to the <B>CKM_SKIPJACK_PRIVATE_WRAP</B>  mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {</P>
<P>  CK_ULONG ulPasswordLen;</P>
<P>  CK_BYTE_PTR pPassword;</P>
<P>  CK_ULONG ulPublicDataLen;</P>
<P>  CK_BYTE_PTR pPublicData;</P>
<P>  CK_ULONG ulPandGLen;</P>
<P>  CK_ULONG ulQLen;</P>
<P>  CK_ULONG ulRandomLen;</P>
<P>  CK_BYTE_PTR pRandomA;</P>
<P>  CK_BYTE_PTR pPrimeP;</P>
<P>  CK_BYTE_PTR pBaseG;</P>
<P>  CK_BYTE_PTR pSubprimeQ;</P>
<P>} CK_SKIPJACK_PRIVATE_WRAP_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulPasswordLen</I>&#9;length of the password</P></ul>
</ul>
</ul>
</ul>
</ul>

<P>&#9;<I>pPassword</I>&#9;pointer to the buffer which contains the user-supplied password</P><ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulPublicDataLen</I> &#9;other party’s key exchange public key size</P>
<P>&#9;<I>pPublicData</I>&#9;pointer to other party’s key exchange public key value</P>
<P>&#9;<I>ulPandGLen</I>&#9;length of prime and base values</P>
<P>&#9;<I>ulQLen</I>&#9;length of subprime value</P>
<P>&#9;<I>ulRandomLen</I>&#9;size of random Ra, in bytes</P>
<P>&#9;<I>pRandomA</I> &#9;pointer to Ra data</P>
<P>&#9;<I>pPrimeP</I>&#9;pointer to Prime, p, value</P>
<P>&#9;<I>pBaseG</I>&#9;pointer to Base, g, value</P></ul>
</ul>
</ul>
</ul>
</ul>

<P>&#9;<I>pSubprimeQ</I>&#9;pointer to Subprime, q, value</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_SKIPJACK_PRIVATE_WRAP_PARAMS_PTR</B> is a pointer to a <B>CK_PRIVATE_WRAP_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc385058058"><A NAME="_Toc405794864"><A NAME="_Toc410109203"></FONT><B><FONT FACE="Palatino">CK_SKIPJACK_RELAYX_PARAMS</A>; CK_SKIPJACK_RELAYX_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SKIPJACK_RELAYX_PARAMS</B> is a structure that provides the parameters to the <B>CKM_SKIPJACK_RELAYX</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SKIPJACK_RELAYX_PARAMS {</P>
<P>  CK_ULONG ulOldWrappedXLen;</P>
<P>  CK_BYTE_PTR pOldWrappedX;</P>
<P>  CK_ULONG ulOldPasswordLen;</P>
<P>  CK_BYTE_PTR pOldPassword;</P>
<P>  CK_ULONG ulOldPublicDataLen;</P>
<P>  CK_BYTE_PTR pOldPublicData;</P>
<P>  CK_ULONG ulOldRandomLen;</P>
<P>  CK_BYTE_PTR pOldRandomA;</P>
<P>  CK_ULONG ulNewPasswordLen;</P>
<P>  CK_BYTE_PTR pNewPassword;</P>
<P>  CK_ULONG ulNewPublicDataLen;</P>
<P>  CK_BYTE_PTR pNewPublicData;</P>
<P>  CK_ULONG ulNewRandomLen;</P>
<P>  CK_BYTE_PTR pNewRandomA;</P>
<P>} CK_SKIPJACK_RELAYX_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulOldWrappedXLen</I>&#9;length of old wrapped key in bytes</P>
<P>&#9;<I>pOldWrappedX</I>&#9;pointer to old wrapper key</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P>&#9;<I>ulOldPasswordLen</I>&#9;length of the old password</P>
<P>&#9;<I>pOldPassword</I>&#9;pointer to the buffer which contains the old user-supplied password</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulOldPublicDataLen</I> &#9;old key exchange public key size</P>
<P>&#9; <I>pOldPublicData</I>&#9;pointer to old key exchange public key value</P>
<P>&#9;<I>ulOldRandomLen</I>&#9;size of old random Ra in bytes</P>
<P>&#9;<I>pOldRandomA</I>&#9;pointer to old Ra data</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<P>&#9;<I>ulNewPasswordLen</I>&#9;length of the new password</P>
<P>&#9;<I>pNewPassword</I>&#9;pointer to the buffer which contains the new user-supplied password</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulNewPublicDataLen</I> &#9;new key exchange public key size</P>
<P>&#9; <I>pNewPublicData</I>&#9;pointer to new key exchange public key value</P>
<P>&#9;<I>ulNewRandomLen</I>&#9;size of new random Ra in bytes</P>
<P>&#9;<I>pNewRandomA</I>&#9;pointer to new Ra data</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_SKIPJACK_RELAYX_PARAMS_PTR</B> is a pointer to a <B>CK_SKIPJACK_RELAYX_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058060"><A NAME="_Toc405794865"><A NAME="_Toc410109204">11.21.&#9;SKIPJACK mechanisms</A></A></A></P>
<P><A NAME="_Toc385058061"><A NAME="_Toc405794866"><A NAME="_Toc410109205">11.21.1.&#9;SKIPJACK key generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SKIPJACK key generation mechanism, denoted <B>CKM_SKIPJACK_KEY_GEN</B>, is a key generation mechanism for SKIPJACK. The output of this mechanism is called a Message Encryption Key (MEK).</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058062"><A NAME="_Toc405794867"><A NAME="_Toc410109206">11.21.2.&#9;SKIPJACK-ECB64</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-ECB64, denoted <B>CKM_SKIPJACK_ECB64</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 64-bit electronic codebook mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795036"><A NAME="_Toc410108905">Table 74, SKIPJACK-ECB64: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058063"><A NAME="_Toc405794868"><A NAME="_Toc410109207">11.21.3.&#9;SKIPJACK-CBC64</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-CBC64, denoted <B>CKM_SKIPJACK_CBC64</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 64-bit cipher-block chaining mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795037"><A NAME="_Toc410108906">Table 75, SKIPJACK-CBC64: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058064"><A NAME="_Toc405794869"><A NAME="_Toc410109208">11.21.4.&#9;SKIPJACK-OFB64</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-OFB64, denoted <B>CKM_SKIPJACK_OFB64</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 64-bit output feedback mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795038"><A NAME="_Toc410108907">Table 76, SKIPJACK-OFB64: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058065"><A NAME="_Toc405794870"><A NAME="_Toc410109209">11.21.5.&#9;SKIPJACK-CFB64</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-CFB64, denoted <B>CKM_SKIPJACK_CFB64</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 64-bit cipher feedback mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795039"><A NAME="_Toc410108908">Table 77, SKIPJACK-CFB64: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 8</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058066"><A NAME="_Toc405794871"><A NAME="_Toc410109210">11.21.6.&#9;SKIPJACK-CFB32</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-CFB32, denoted <B>CKM_SKIPJACK_CFB32</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 32-bit cipher feedback mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795040"><A NAME="_Toc410108909">Table 78, SKIPJACK-CFB32: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058067"><A NAME="_Toc405794872"><A NAME="_Toc410109211">11.21.7.&#9;SKIPJACK-CFB16</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-CFB16, denoted <B>CKM_SKIPJACK_CFB16</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 16-bit cipher feedback mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795041"><A NAME="_Toc410108910">Table 79, SKIPJACK-CFB16: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058068"><A NAME="_Toc405794873"><A NAME="_Toc410109212">11.21.8.&#9;SKIPJACK-CFB8</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SKIPJACK-CFB8, denoted <B>CKM_SKIPJACK_CFB8</B>, is a mechanism for single- and multiple-part encryption and decryption with SKIPJACK in 8-bit cipher feedback mode as defined in FIPS PUB 185.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795042"><A NAME="_Toc410108911">Table 80, SKIPJACK-CFB8: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>SKIPJACK</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 4</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058069"><A NAME="_Toc405794874"><A NAME="_Toc410109213">11.21.9.&#9;SKIPJACK-WRAP</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SKIPJACK-WRAP  mechanism, denoted <B>CKM_SKIPJACK_WRAP</B>, is used to wrap and unwrap a secret key (MEK).  It can wrap or unwrap SKIPJACK, BATON, and JUNIPER keys.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384621453"><A NAME="_Toc385058070"><A NAME="_Toc405794875"><A NAME="_Toc410109214">11.21.10.&#9;SKIPJACK-PRIVATE-WRAP</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SKIPJACK-PRIVATE-WRAP mechanism, denoted <B>CKM_SKIPJACK_PRIVATE_WRAP</B>, is used to wrap and unwrap a private key.  It can wrap KEA and DSA private keys.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_SKIPJACK_PRIVATE_WRAP_PARAMS </B>structure.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058071"><A NAME="_Toc405794876"><A NAME="_Toc410109215">11.21.11.&#9;SKIPJACK-RELAYX</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SKIPJACK-RELAYX mechanism, denoted <B>CKM_SKIPJACK_RELAYX</B>, is used with the <B>C_WrapKey</B> function to &quot;change the wrapping&quot; on a private key which was wrapped with the SKIPJACK-PRIVATE-WRAP mechanism (see Section 11.21.10).</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_SKIPJACK_RELAYX_PARAMS</B> structure.</P>
<P ALIGN="JUSTIFY">Although the SKIPJACK-RELAYX mechanism is used with <B>C_WrapKey</B>, it differs from other key-wrapping mechanisms.  Other key-wrapping mechanisms take a key handle as one of the arguments to <B>C_WrapKey</B>; however, for the SKIPJACK_RELAYX mechanism, the [always invalid] value 0 should be passed as the key handle for <B>C_WrapKey</B>, and the already-wrapped key should be passed in as part of the <B>CK_SKIPJACK_RELAYX_PARAMS</B> structure.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058072"><A NAME="_Toc405794877"><A NAME="_Toc410109216">11.22.&#9;BATON mechanisms</A></A></A></P>
<P><A NAME="_Toc385058073"><A NAME="_Toc405794878"><A NAME="_Toc410109217">11.22.1.&#9;BATON key generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The BATON key generation mechanism, denoted <B>CKM_BATON_KEY_GEN</B>, is a key generation mechanism for BATON. The output of this mechanism is called a Message Encryption Key (MEK).</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">This mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058074"><A NAME="_Toc405794879"><A NAME="_Toc410109218">11.22.2.&#9;BATON-ECB128</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON-ECB128, denoted <B>CKM_BATON_ECB128</B>, is a mechanism for single- and multiple-part encryption and decryption with BATON in 128-bit electronic codebook mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795043"><A NAME="_Toc410108912">Table 81, BATON-ECB128: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="29%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058075"><A NAME="_Toc405794880"><A NAME="_Toc410109219">11.22.3.&#9;BATON-ECB96</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON-ECB96, denoted <B>CKM_BATON_ECB96</B>, is a mechanism for single- and multiple-part encryption and decryption with BATON in 96-bit electronic codebook mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795044"><A NAME="_Toc410108913">Table 82, BATON-ECB96: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=570>
<TR><TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 12</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 12</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058076"><A NAME="_Toc405794881"><A NAME="_Toc410109220">11.22.4.&#9;BATON-CBC128</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON-CBC128, denoted <B>CKM_BATON_CBC128</B>, is a mechanism for single- and multiple-part encryption and decryption with BATON in 128-bit cipher-block chaining mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795045"><A NAME="_Toc410108914">Table 83, BATON-CBC128: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058077"><A NAME="_Toc405794882"><A NAME="_Toc410109221">11.22.5.&#9;BATON-COUNTER</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON-COUNTER, denoted <B>CKM_BATON_COUNTER</B>, is a mechanism for single- and multiple-part encryption and decryption with BATON in counter  mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795046"><A NAME="_Toc410108915">Table 84, BATON-COUNTER: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of  16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058078"><A NAME="_Toc405794883"><A NAME="_Toc410109222">11.22.6.&#9;BATON-SHUFFLE</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">BATON-SHUFFLE, denoted <B>CKM_BATON_SHUFFLE</B>, is a mechanism for single- and multiple-part encryption and decryption with BATON in shuffle mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795047"><A NAME="_Toc410108916">Table 85, BATON-SHUFFLE: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=552>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>BATON</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058079"><A NAME="_Toc405794884"><A NAME="_Toc410109223">11.22.7.&#9;BATON WRAP</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The BATON wrap and unwrap  mechanism, denoted <B>CKM_BATON_WRAP</B>, is a function used to wrap and unwrap a secret key (MEK).  It can wrap and unwrap SKIPJACK, BATON, and JUNIPER keys.</P>
<P ALIGN="JUSTIFY">It has no parameters.</P>
<P ALIGN="JUSTIFY">When used to unwrap a key, this mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to it.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058080"><A NAME="_Toc405794885"><A NAME="_Toc410109224">11.23.&#9;JUNIPER mechanisms</A></A></A></P>
<P><A NAME="_Toc385058081"><A NAME="_Toc405794886"><A NAME="_Toc410109225">11.23.1.&#9;JUNIPER key generation</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The JUNIPER key generation mechanism, denoted <B>CKM_JUNIPER_KEY_GEN</B>, is a key generation mechanism for JUNIPER.  The output of this mechanism is called a Message Encryption Key (MEK).</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058082"><A NAME="_Toc405794887"><A NAME="_Toc410109226">11.23.2.&#9;JUNIPER-ECB128</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">JUNIPER-ECB128, denoted <B>CKM_JUNIPER_ECB128</B>, is a mechanism for single- and multiple-part encryption and decryption with JUNIPER in 128-bit electronic codebook mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table.  For encryption and decryption, the input and output data (parts) may begin at the same location in memory.</P>
<B><P><A NAME="_Toc405795048"><A NAME="_Toc410108917">Table 86, JUNIPER-ECB128: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058083"><A NAME="_Toc405794888"><A NAME="_Toc410109227">11.23.3.&#9;JUNIPER-CBC128</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">JUNIPER-CBC128, denoted <B>CKM_JUNIPER_CBC128</B>, is a mechanism for single- and multiple-part encryption and decryption with JUNIPER in 128-bit cipher-block chaining mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table.  For encryption and decryption, the input and output data (parts) may begin at the same location in memory.</P>
<B><P><A NAME="_Toc405795049"><A NAME="_Toc410108918">Table 87, JUNIPER-CBC128: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058084"><A NAME="_Toc405794889"><A NAME="_Toc410109228">11.23.4.&#9;JUNIPER-COUNTER</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">JUNIPER COUNTER, denoted <B>CKM_JUNIPER_COUNTER</B>, is a mechanism for single- and multiple-part encryption and decryption with JUNIPER in counter mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table.  For encryption and decryption, the input and output data (parts) may begin at the same location in memory.</P>
<B><P><A NAME="_Toc405795050"><A NAME="_Toc410108919">Table 88, JUNIPER-COUNTER: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058085"><A NAME="_Toc405794890"><A NAME="_Toc410109229">11.23.5.&#9;JUNIPER-SHUFFLE</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">JUNIPER-SHUFFLE, denoted <B>CKM_JUNIPER_SHUFFLE</B>, is  a mechanism for single- and multiple-part encryption and decryption with JUNIPER in shuffle mode.</P>
<P ALIGN="JUSTIFY">It has a parameter, a 24-byte initialization vector.  During an encryption operation, this IV is set to some value generated by the token—in other words, the application cannot specify a particular IV when encrypting.  It can, of course, specify a particular IV when decrypting.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of data are summarized in the following table.  For encryption and decryption, the input and output data (parts) may begin at the same location in memory.</P>
<B><P><A NAME="_Toc405795051"><A NAME="_Toc410108920">Table 89, JUNIPER-SHUFFLE: Data and Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=558>
<TR><TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Output length</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Comments</B></FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Encrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Decrypt</FONT></TD>
<TD WIDTH="16%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>JUNIPER</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">multiple of 16</FONT></TD>
<TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">same as input length</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">no final part</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc385058086"><A NAME="_Toc405794891"><A NAME="_Toc410109230">11.23.6.&#9;JUNIPER WRAP</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The JUNIPER wrap and unwrap  mechanism, denoted <B>CKM_JUNIPER_WRAP</B>, is a function used to wrap and unwrap an MEK.  It can wrap or unwrap SKIPJACK, BATON, and JUNIPER keys.</P>
<P ALIGN="JUSTIFY">It has no parameters.</P>
<P ALIGN="JUSTIFY">When used to unwrap a key, this mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to it.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc385058087"><A NAME="_Toc405794892"><A NAME="_Toc410109231"><A NAME="_Toc323205527"><A NAME="_Toc323610956"><A NAME="_Toc383864973">11.24.&#9;MD2 mechanisms</A></A></A></P>
<P><A NAME="_Toc405794893"><A NAME="_Toc410109232">11.24.1.&#9;MD2</A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The MD2 mechanism, denoted <B>CKM_MD2</B>, is a mechanism for message digesting, following the MD2 message-digest algorithm defined in RFC 1319.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on the length of data are summarized in the following table:</P>
<B><P><A NAME="_Toc323204913"><A NAME="_Toc383864562"><A NAME="_Toc405795052"><A NAME="_Toc410108921">Table 90, MD2: Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=281>
<TR><TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Digest length</B></FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Digest</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">16</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384784779"><A NAME="_Toc405794894"><A NAME="_Toc410109233"><A NAME="_Toc322855334"><A NAME="_Toc322945176"><A NAME="_Toc323000743"><A NAME="_Toc323024194">11.24.2.&#9;General-length MD2-HMAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The general-length MD2-HMAC mechanism, denoted <B>CKM_MD2_HMAC_GENERAL</B>, is a mechanism for signatures and verification.  It uses the HMAC construction, based on the MD2 hash function.  The keys it uses are generic secret keys.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which holds the length in bytes of the desired output.  This length should be in the range 0-16 (the output size of MD2 is 16 bytes).  Signatures (MACs) produced by this mechanism will be taken from the start of the full 16-byte HMAC output.</P>
<B><P><A NAME="_Toc405795053"><A NAME="_Toc410108922">Table 91, General-length MD2-HMAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=528>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-16, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-16, depending on parameters</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc405794895"><A NAME="_Toc410109234">11.24.3.&#9;MD2-HMAC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The MD2-HMAC mechanism, denoted <B>CKM_MD2_HMAC</B>, is a special case of the general-length MD2-HMAC mechanism in Section 11.24.2.</P>
<P ALIGN="JUSTIFY">It has no parameter, and always produces an output of length 16.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794896"><A NAME="_Toc410109235">11.24.4.&#9;MD2 key derivation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD2 key derivation, denoted <B>CKM_MD2_KEY_DERIVATION</B>, is a mechanism which provides the capability of deriving a secret key by digesting the value of another secret key with MD2. </P>
<P ALIGN="JUSTIFY">The value of the base key is digested once, and the result is used to make the value of derived secret key.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be 16 bytes (the output size of MD2).</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length was provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more than 16 bytes, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>The <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes in the template for the new key can both be specified to be either TRUE or FALSE.  If omitted, these attributes each take on some default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to FALSE, then the derived key will as well.  If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the derived key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to the same value as its <B>CKA_SENSITIVE</B> attribute.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to FALSE, then the derived key will, too.  If the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the derived key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to the <I>opposite</I> value from its <B>CKA_EXTRACTABLE</B> attribute.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794897"><A NAME="_Toc410109236"><A NAME="_Toc323205528"><A NAME="_Toc323610957"><A NAME="_Toc383864974">11.25.&#9;MD5 mechanisms</A></A></P>
<P><A NAME="_Toc405794898"><A NAME="_Toc410109237">11.25.1.&#9;MD5</A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The MD5 mechanism, denoted <B>CKM_MD5</B>, is a mechanism for message digesting, following the MD5 message-digest algorithm defined in RFC 1321.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on the length of input and output data are summarized in the following table.  For single-part digesting, the data and the digest may begin at the same location in memory.</P>
<B><P><A NAME="_Toc323204914"><A NAME="_Toc383864563"><A NAME="_Toc405795054"><A NAME="_Toc410108923">Table 92, MD5: Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=281>
<TR><TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Digest length</B></FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Digest</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">16</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384784988"><A NAME="_Toc405794899"><A NAME="_Toc410109238"><A NAME="_Toc323624158"><A NAME="_Toc322855335"><A NAME="_Toc322945177"><A NAME="_Toc323000744"><A NAME="_Toc323024195">11.25.2.&#9;General-length MD5-HMAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The general-length MD5-HMAC mechanism, denoted <B>CKM_MD5_HMAC_GENERAL</B>, is a mechanism for signatures and verification.  It uses the HMAC construction, based on the MD5 hash function.  The keys it uses are generic secret keys.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which holds the length in bytes of the desired output.  This length should be in the range 0-16 (the output size of MD5 is 16 bytes).  Signatures (MACs) produced by this mechanism will be taken from the start of the full 16-byte HMAC output.</P>
<B><P><A NAME="_Toc405795055"><A NAME="_Toc410108924">Table 93, General-length MD5-HMAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=528>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-16, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-16, depending on parameters</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc405794900"><A NAME="_Toc410109239">11.25.3.&#9;MD5-HMAC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The MD5-HMAC mechanism, denoted <B>CKM_MD5_HMAC</B>, is a special case of the general-length MD5-HMAC mechanism in Section 11.25.2.</P>
<P ALIGN="JUSTIFY">It has no parameter, and always produces an output of length 16.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794901"><A NAME="_Toc410109240">11.25.4.&#9;MD5 key derivation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5 key derivation, denoted <B>CKM_MD5_KEY_DERIVATION</B>, is a mechanism which provides the capability of deriving a secret key by digesting the value of another secret key with MD5. </P>
<P ALIGN="JUSTIFY"><A NAME="_Toc323205529"><A NAME="_Toc323610958"><A NAME="_Toc383864975"></A>The value of the base key is digested once, and the result is used to make the value of derived secret key.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be 16 bytes (the output size of MD5).</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length was provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more than 16 bytes, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>The <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes in the template for the new key can both be specified to be either TRUE or FALSE.  If omitted, these attributes each take on some default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to FALSE, then the derived key will as well.  If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the derived key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to the same value as its <B>CKA_SENSITIVE</B> attribute.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to FALSE, then the derived key will, too.  If the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the derived key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to the <I>opposite</I> value from its <B>CKA_EXTRACTABLE</B> attribute.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794902"><A NAME="_Toc410109241">11.26.&#9;SHA-1 mechanisms</A></A></P>
<P><A NAME="_Toc405794903"><A NAME="_Toc410109242">11.26.1.&#9;SHA-1</A></A></A></A></A></A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SHA-1 mechanism, denoted <B>CKM_SHA_1</B>, is a mechanism for message digesting, following the Secure Hash Algorithm defined in FIPS PUB 180-1.</P>
<P ALIGN="JUSTIFY"> It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on the length of input and output data are summarized in the following table.  For single-part digesting, the data and the digest may begin at the same location in memory.</P>
<B><P><A NAME="_Toc323204915"><A NAME="_Toc383864564"><A NAME="_Toc405795056"><A NAME="_Toc410108925">Table 94, SHA-1: Data Length</A></A></A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=281>
<TR><TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Digest length</B></FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Digest</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">20</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Ref384785246"><A NAME="_Toc405794904"><A NAME="_Toc410109243"><A NAME="_Toc322855336"><A NAME="_Toc322945178"><A NAME="_Toc323000745"><A NAME="_Toc323024196">11.26.2.&#9;General-length SHA-1-HMAC</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The general-length SHA-1-HMAC mechanism, denoted <B>CKM_SHA_1_HMAC_GENERAL</B>, is a mechanism for signatures and verification.  It uses the HMAC construction, based on the SHA-1 hash function.  The keys it uses are generic secret keys.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which holds the length in bytes of the desired output.  This length should be in the range 0-20 (the output size of SHA-1 is 20 bytes).  Signatures (MACs) produced by this mechanism will be taken from the start of the full 20-byte HMAC output.</P>
<B><P><A NAME="_Toc405795057"><A NAME="_Toc410108926">Table 95, General-length SHA-1-HMAC: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=528>
<TR><TD WIDTH="21%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-20, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="19%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">0-20, depending on parameters</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc405794905"><A NAME="_Toc410109244">11.26.3.&#9;SHA-1-HMAC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The SHA-1-HMAC mechanism, denoted <B>CKM_SHA_1_HMAC</B>, is a special case of the general-length SHA-1-HMAC mechanism in Section 11.26.2.</P>
<P ALIGN="JUSTIFY">It has no parameter, and always produces an output of length 20.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794906"><A NAME="_Toc410109245">11.26.4.&#9;SHA-1 key derivation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1 key derivation, denoted <B>CKM_SHA1_KEY_DERIVATION</B>, is a mechanism which provides the capability of deriving a secret key by digesting the value of another secret key with SHA-1. </P>
<P ALIGN="JUSTIFY">The value of the base key is digested once, and the result is used to make the value of derived secret key.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be 20 bytes (the output size of SHA-1).</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length was provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more than 20 bytes, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>The <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes in the template for the new key can both be specified to be either TRUE or FALSE.  If omitted, these attributes each take on some default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to FALSE, then the derived key will as well.  If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the derived key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to the same value as its <B>CKA_SENSITIVE</B> attribute.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to FALSE, then the derived key will, too.  If the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the derived key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to the <I>opposite</I> value from its <B>CKA_EXTRACTABLE</B> attribute.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794907"><A NAME="_Toc410109246">11.27.&#9;FASTHASH mechanisms</A></A></P>
<P><A NAME="_Toc405794908"><A NAME="_Toc410109247">11.27.1.&#9;FASTHASH</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The FASTHASH mechanism, denoted <B>CKM_FASTHASH</B>, is a mechanism for message digesting, following the U. S. government’s algorithm.</P>
<P ALIGN="JUSTIFY"> It does not have a parameter.</P>
<P ALIGN="JUSTIFY">Constraints on the length of input and output data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795058"><A NAME="_Toc410108927">Table 96, FASTHASH: Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=281>
<TR><TD WIDTH="27%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Input length</B></FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Digest length</B></FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Digest</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">40</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P><A NAME="_Toc405794909"><A NAME="_Toc410109248"><A NAME="_Toc323624156">11.28.&#9;Password-based encryption/authentication mechanism parameters</A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc405794910"><A NAME="_Toc410109249">CK_PBE_PARAMS; CK_PBE_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_PBE_PARAMS</B> is a structure which provides all of the necessary information required by the CKM_PBE mechanisms (see PKCS #5 and PKCS #12 for information on the PBE generation mechanisms) and the CKM_PBA_SHA1_WITH_SHA1_HMAC mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_PBE_PARAMS {</P>
<P>  CK_CHAR_PTR pInitVector;</P>
<P>  CK_CHAR_PTR pPassword;</P>
<P>  CK_ULONG ulPasswordLen;</P>
<P>  CK_CHAR_PTR pSalt;</P>
<P>  CK_ULONG ulSaltLen;</P>
<P>  CK_ULONG ulIteration;</P>
<P>} CK_PBE_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>pInitVector</I>&#9;pointer to the location that receives the 8-byte initialization vector (IV), if an IV is required;</P>
<P>&#9;<I>pPassword</I>&#9;points to the password to be used in the PBE key generation;</P>
<P>&#9;<I>ulPasswordLen</I>&#9;length in bytes of the password information;</P>
<P>&#9;<I>pSalt</I>&#9;points to the salt to be used in the PBE key generation;</P>
<P>&#9;<I>ulSaltLen</I>&#9;length in bytes of the salt information;</P>
<P>&#9;<I>ulIteration</I>&#9;number of iterations required for the generation.</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_PBE_PARAMS_PTR</B> is a pointer to a <B>CK_PBE_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794911"><A NAME="_Toc410109250">11.29.&#9;PKCS #5 and PKCS #5-style password-based encryption mechanisms</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The mechanisms in this section are for generating keys and IVs for performing password-based encryption.  The method used to generate keys and IVs is specified in PKCS #5.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794912"><A NAME="_Toc410109251">11.29.1.&#9;MD2-PBE</A> for DES-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD2-PBE for DES-CBC, denoted <B>CKM_PBE_MD2_DES_CBC</B>, is a mechanism used for generating a DES secret key and an IV from a password and a salt value by using the MD2 digest algorithm and an iteration count. This functionality is defined in PKCS#5.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794913"><A NAME="_Toc410109252"><A NAME="_Toc323624157">11.29.2.&#9;MD5-PBE for DES-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5-PBE for DES-CBC, denoted <B>CKM_PBE_MD5_DES_CBC</B>, is a mechanism used for generating a DES secret key and an IV from a password and a salt value by using the MD5 digest algorithm and an iteration count. This functionality is defined in PKCS#5.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794914"><A NAME="_Toc410109253">11.29.3.&#9;MD5-PBE for CAST-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5-PBE for CAST-CBC, denoted <B>CKM_PBE_MD5_CAST_CBC</B>, is a mechanism used for generating a CAST secret key and an IV from a password and a salt value by using the MD5 digest algorithm and an iteration count. This functionality is analogous to that defined in PKCS#5 for MD5 and DES.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">The length of the CAST key generated by this mechanism may be specified in the supplied template; if it is not present in the template, it defaults to 8 bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794915"><A NAME="_Toc410109254">11.29.4.&#9;MD5-PBE for CAST3-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5-PBE for CAST3-CBC, denoted <B>CKM_PBE_MD5_CAST3_CBC</B>, is a mechanism used for generating a CAST3 secret key and an IV from a password and a salt value by using the MD5 digest algorithm and an iteration count. This functionality is analogous to that defined in PKCS#5 for MD5 and DES.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">The length of the CAST3 key generated by this mechanism may be specified in the supplied template; if it is not present in the template, it defaults to 8 bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794916"><A NAME="_Toc410109255">11.29.5.&#9;MD5-PBE for CAST128-CBC (CAST5-CBC)</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5-PBE for CAST128-CBC (CAST5-CBC), denoted <B>CKM_PBE_MD5_CAST128_CBC</B> or <B>CKM_PBE_MD5_CAST5_CBC</B>, is a mechanism used for generating a CAST128 (CAST5) secret key and an IV from a password and a salt value by using the MD5 digest algorithm and an iteration count. This functionality is analogous to that defined in PKCS#5 for MD5 and DES.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">The length of the CAST128 (CAST5) key generated by this mechanism may be specified in the supplied template; if it is not present in the template, it defaults to 8 bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794917"><A NAME="_Toc410109256">11.29.6.&#9;SHA-1-PBE for CAST128-CBC (CAST5-CBC)</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for CAST128-CBC (CAST5-CBC), denoted <B>CKM_PBE_SHA1_CAST128_CBC</B> or <B>CKM_PBE_SHA1_CAST5_CBC</B>, is a mechanism used for generating a CAST128 (CAST5) secret key and an IV from a password and a salt value by using the SHA-1 digest algorithm and an iteration count. This functionality is analogous to that defined in PKCS#5 for MD5 and DES.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">The length of the CAST128 (CAST5) key generated by this mechanism may be specified in the supplied template; if it is not present in the template, it defaults to 8 bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref397844004"><A NAME="_Toc405794918"><A NAME="_Ref406245166"><A NAME="_Toc410109257">11.30.&#9;PKCS #12 password-based encryption/authentication mechanisms</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The mechanisms in this section are for generating keys and IVs for performing password-based encryption or authentication.  The method used to generate keys and IVs is based on a method that was specified in the original draft of PKCS #12.</P>
<P ALIGN="JUSTIFY">We specify here a general method for producing various types of pseudo-random bits from a password, <I>p</I>; a string of salt bits, <I>s</I>; and an iteration count, <I>c</I>.  The &quot;type&quot; of pseudo-random bits to be produced is identified by an identification byte, <I>ID</I>, the meaning of which will be discussed later.</P>
<P ALIGN="JUSTIFY"><A NAME="PrivacyKeyGen"><A NAME="_Toc365690245"><A NAME="_Toc379096467">Let H be a hash function built around a compression function <I>f: <B>Z</B><SUB>2</SUB><SUP>u <FONT FACE="Symbol">&#180;</FONT>
</SUP> <B>Z</B><SUB>2</SUB><SUP>v</SUP> <FONT FACE="Symbol">&#174;</FONT>
 <B>Z</B><SUB>2</SUB><SUP>u</I></SUP> (that is, H has a chaining variable and output of length <I>u</I> bits, and the message input to the compression function of H is <I>v</I> bits).  For MD2 and MD5, <I>u</I>=128 and <I>v</I>=512; for SHA-1, <I>u</I>=160 and <I>v</I>=512.</P>
<P ALIGN="JUSTIFY">We assume here that <I>u</I> and <I>v</I> are both multiples of 8, as are the lengths in bits of the password and salt strings and the number <I>n</I> of pseudo-random bits required.  In addition, <I>u</I> and <I>v</I> are of course nonzero.</P>
<OL>

<P ALIGN="JUSTIFY"><LI>Construct a string, <I>D</I> (the &quot;diversifier&quot;), by concatenating <I>v</I>/8 copies of <I>ID</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Concatenate copies of the salt together to create a string <I>S</I> of length <I>v<FONT FACE="Symbol">&#215;</FONT>
<FONT FACE="Symbol">&#233;</FONT>
s/v<FONT FACE="Symbol">&#249;</FONT>
</I> bits (the final copy of the salt may be truncated to create <I>S</I>).  Note that if the salt is the empty string, then so is <I>S</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Concatenate copies of the password together to create a string <I>P</I> of length <I>v<FONT FACE="Symbol">&#215;</FONT>
<FONT FACE="Symbol">&#233;</FONT>
p/v<FONT FACE="Symbol">&#249;</FONT>
</I> bits (the final copy of the password may be truncated to create <I>P</I>).  Note that if the password is the empty string, then so is <I>P</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Set <I>I</I>=<I>S</I>||<I>P</I> to be the concatenation of <I>S</I> and <I>P</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Set <I>j</I>=<FONT FACE="Symbol">&#233;</FONT>
<I>n</I>/<I>u<FONT FACE="Symbol">&#249;</FONT>
</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>For <I>i</I>=1, 2, …, <I>j</I>, do the following:</LI></P></OL>

<OL TYPE="a">

<P ALIGN="JUSTIFY"><LI>Set <I>A<SUB>i</I></SUB>=H<I><SUP>c</I></SUP>(<I>D</I>||<I>I</I>), the <I>c</I><SUP>th</SUP> hash of <I>D</I>||<I>I</I>.  That is, compute the hash of <I>D</I>||<I>I</I>; compute the hash of that hash; etc.; continue in this fashion until a total of <I>c</I> hashes have been computed, each on the result of the previous hash.</LI></P>
<P ALIGN="JUSTIFY"><LI>Concatenate copies of <I>A<SUB>i</I></SUB> to create a string <I>B</I> of length <I>v</I> bits (the final copy of <I>A<SUB>i</I></SUB> may be truncated to create <I>B</I>).</LI></P>
<P ALIGN="JUSTIFY"><LI>Treating <I>I</I> as a concatenation <I>I</I><SUB>0</SUB>, <I>I</I><SUB>1</SUB>, …, <I>I<SUB>k</I>-1</SUB> of <I>v</I>-bit blocks, where <I>k</I>=<FONT FACE="Symbol">&#233;</FONT>
<I>s/v<FONT FACE="Symbol">&#249;</FONT>
</I>+<FONT FACE="Symbol">&#233;</FONT>
<I>p/v<FONT FACE="Symbol">&#249;</FONT>
</I>, modify <I>I</I> by setting <I>I<SUB>j</I></SUB>=(<I>I<SUB>j</I></SUB>+<I>B</I>+1) mod 2<I><SUP>v</I></SUP> for each <I>j</I>.  To perform this addition, treat each <I>v</I>-bit block as a binary number represented most-significant bit first.</LI></P></OL>

<OL START=7>

<P ALIGN="JUSTIFY"><LI>Concatenate <I>A</I><SUB>1</SUB>, <I>A</I><SUB>2</SUB>, …, <I>A<SUB>j</I></SUB> together to form a pseudo-random bit string, <I>A</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Use the first <I>n</I> bits of <I>A</I> as the output of this entire process.</LI></P></OL>

<P ALIGN="JUSTIFY">When the password-based encryption mechanisms presented in this section are used to generate a key and IV (if needed) from a password, salt, and an iteration count, the above algorithm is used.  To generate a key, the identifier byte <I>ID</I> is set to the value 1; to generate an IV, the identifier byte <I>ID</I> is set to the value 2.</A></A></A></P>
<P ALIGN="JUSTIFY">When the password based authentication mechanism presented in this section is used to generate a key from a password, salt, and an iteration count, the above algorithm is used.  The identifier byte <I>ID</I> is set to the value 3.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794919"><A NAME="_Toc410109258">11.30.1.&#9;SHA-1-PBE for 128-bit RC4</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 128-bit RC4, denoted <B>CKM_PBE_SHA1_RC4_128</B>, is a mechanism used for generating a 128-bit RC4 secret key from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process.  The parameter also has a field to hold the location of an application-supplied buffer which will receive an IV; for this mechanism, the contents of this field are ignored, since RC4 does not require an IV.</P>
<P ALIGN="JUSTIFY">The key produced by this mechanism will typically be used for performing password-based encryption.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794920"><A NAME="_Toc410109259">11.30.2.&#9;SHA-1-PBE for 40-bit RC4</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 40-bit RC4, denoted <B>CKM_PBE_SHA1_RC4_40</B>, is a mechanism used for generating a 40-bit RC4 secret key from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process.  The parameter also has a field to hold the location of an application-supplied buffer which will receive an IV; for this mechanism, the contents of this field are ignored, since RC4 does not require an IV.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc405794921">The key produced by this mechanism will typically be used for performing password-based encryption.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109260">11.30.3.&#9;SHA-1-PBE for 3-key triple-DES-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 3-key triple-DES-CBC, denoted <B>CKM_PBE_SHA1_DES3_EDE_CBC</B>, is a mechanism used for generating a 3-key triple-DES secret key and IV from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key and IV is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.  Each byte of the key produced will have its low-order bit adjusted, if necessary, so that a valid 3-key triple-DES key with proper parity bits is obtained.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc405794922">The key and IV produced by this mechanism will typically be used for performing password-based encryption.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109261">11.30.4.&#9;SHA-1-PBE for 2-key triple-DES-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 2-key triple-DES-CBC, denoted <B>CKM_PBE_SHA1_DES2_EDE_CBC</B>, is a mechanism used for generating a 2-key triple-DES secret key and IV from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key and IV is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.  Each byte of the key produced will have its low-order bit adjusted, if necessary, so that a valid 2-key triple-DES key with proper parity bits is obtained.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc405794923">The key and IV produced by this mechanism will typically be used for performing password-based encryption.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109262">11.30.5.&#9;SHA-1-PBE for 128-bit RC2-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 128-bit RC2-CBC, denoted <B>CKM_PBE_SHA1_RC2_128_CBC</B>, is a mechanism used for generating a 128-bit RC2 secret key and IV from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key and IV is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">When the key and IV generated by this mechanism are used to encrypt or decrypt, the effective number of bits in the RC2 search space should be set to 128.  This ensures compatibility with the ASN.1 Object Identifier </FONT><FONT FACE="Courier New" SIZE=2>pbeWithSHA1And128BitRC2-CBC</FONT><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY"><A NAME="_Toc405794924">The key and IV produced by this mechanism will typically be used for performing password-based encryption.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109263">11.30.6.&#9;SHA-1-PBE for 40-bit RC2-CBC</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBE for 40-bit RC2-CBC, denoted <B>CKM_PBE_SHA1_RC2_40_CBC</B>, is a mechanism used for generating a 40-bit RC2 secret key and IV from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key and IV is described above on page </FONT><A HREF="#_Ref397844004">*</A><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process and the location of the application-supplied buffer which will receive the 8-byte IV generated by the mechanism.</P>
<P ALIGN="JUSTIFY">When the key and IV generated by this mechanism are used to encrypt or decrypt, the effective number of bits in the RC2 search space should be set to 40.  This ensures compatibility with the ASN.1 Object Identifier </FONT><FONT FACE="Courier New" SIZE=2>pbeWithSHA1And40BitRC2-CBC</FONT><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">The key and IV produced by this mechanism will typically be used for performing password-based encryption.</P>
</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc410109264">11.30.7.&#9;SHA-1-PBA for SHA-1-HMAC</A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1-PBA for SHA-1-HMAC, denoted <B>CKM_PBA_SHA1_WITH_SHA1_HMAC</B>, is a mechanism used for generating a 160-bit generic secret key from a password and a salt value by using the SHA-1 digest algorithm and an iteration count.  The method used to generate the key is described above on page </FONT><A HREF="#_Ref406245166">*</A><FONT FACE="Palatino" SIZE=2>.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_PBE_PARAMS</B> structure.  The parameter specifies the input information for the key generation process. The parameter also has a field to hold the location of an application-supplied buffer which will receive an IV; for this mechanism, the contents of this field are ignored, since authentication with SHA-1-HMAC does not require an IV.</P>
<P ALIGN="JUSTIFY">The key generated by this mechanism will typically be used for computing a SHA-1 HMAC to perform password-based authentication (not <I>password-based encryption</I>).  At the time of this writing, this is primarily done to ensure the integrity of a PKCS #12 PDU.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794925"><A NAME="_Toc410109265">11.31.&#9;SET mechanism parameters</A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc405794926"><A NAME="_Toc410109266">CK_KEY_WRAP_SET_OAEP_PARAMS; CK_KEY_WRAP_SET_OAEP_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_KEY_WRAP_SET_OAEP_PARAMS</B> is a structure that provides the parameters to the <B>CKM_KEY_WRAP_SET_OAEP</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_KEY_WRAP_SET_OAEP_PARAMS {</P>
<P>  CK_BYTE bBC;</P>
<P>  CK_BYTE_PTR pX;</P>
<P>  CK_ULONG ulXLen;</P>
<P>} CK_KEY_WRAP_SET_OAEP_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>bBC</I>&#9;block contents byte</P>
<P>&#9;<I>pX</I>&#9;concatenation of hash of plaintext data (if present) and extra data (if present)</P>
<P>&#9;<I>ulXLen</I>&#9;length in bytes of concatenation of hash of plaintext data (if present) and extra data (if present).  0 if neither is present</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_KEY_WRAP_SET_OAEP_PARAMS_PTR</B> is a pointer to a <B>CK_KEY_WRAP_SET_OAEP_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794927"><A NAME="_Toc410109267">11.32.&#9;SET mechanisms</A></A></P>
<P><A NAME="_Ref384960234"><A NAME="_Toc405794928"><A NAME="_Toc410109268">11.32.1.&#9;OAEP key wrapping for SET</A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The OAEP key wrapping for SET mechanism, denoted <B>CKM_KEY_WRAP_SET_OAEP</B>, is a mechanism for wrapping and unwrapping a DES key with an RSA key.  The hash of some plaintext data and/or some extra data may optionally be wrapped together with the DES key.  This mechanism is defined in the SET protocol specifications.</P>
<P ALIGN="JUSTIFY">It takes a parameter, a <B>CK_KEY_WRAP_SET_OAEP_PARAMS</B> structure.  This structure holds the &quot;Block Contents&quot; byte of the data and the concatenation of the hash of plaintext data (if present) and the extra data to be wrapped (if present).  If neither the hash nor the extra data is present, this is indicated by the <I>ulXLen</I> field having the value 0.</P>
<P ALIGN="JUSTIFY">When this mechanism is used to unwrap a key, the concatenation of the hash of plaintext data (if present) and the extra data (if present) is returned following the convention described in Section 10.2 on producing output.  Note that if the inputs to <B>C_UnwrapKey</B> are such that the extra data is not returned (<I>e.g.</I>, the buffer supplied in the <B>CK_KEY_WRAP_SET_OAEP_PARAMS</B> structure is NULL_PTR), then the unwrapped key object will not be created, either.</P>
<P ALIGN="JUSTIFY">Be aware that when this mechanism is used to unwrap a key, the <I>bBC</I> and <I>pX</I> fields of the parameter supplied to the mechanism may be modified.</P>
<P ALIGN="JUSTIFY">If an application uses <B>C_UnwrapKey</B> with <B>CKM_KEY_WRAP_SET_OAEP</B>, it may be preferable for it simply to allocate a 128-byte buffer for the concatenation of the hash of plaintext data and the extra data (this concatenation is never larger than 128 bytes), rather than calling <B>C_UnwrapKey</B> twice.  Each call of <B>C_UnwrapKey</B> with <B>CKM_KEY_WRAP_SET_OAEP</B> requires an RSA decryption operation to be performed, and this computational overhead can be avoided by this means.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794929"><A NAME="_Toc410109269">11.33.&#9;LYNKS mechanisms</A></A></P>
<P><A NAME="_Toc405794930"><A NAME="_Toc410109270">11.33.1.&#9;LYNKS key wrapping</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The LYNKS key wrapping mechanism, denoted <B>CKM_WRAP_LYNKS</B>, is a mechanism  for wrapping and unwrapping secret keys with DES keys.  It can wrap any 8-byte secret key, and it produces a 10-byte wrapped key, containing a cryptographic checksum.</P>
<P ALIGN="JUSTIFY">It does not have a parameter.</P>
<P ALIGN="JUSTIFY">To wrap a 8-byte secret key <I>K</I> with a DES key <I>W</I>, this mechanism performs the following steps:</P>
<OL>

<P ALIGN="JUSTIFY"><LI>Initialize two 16-bit integers, <I>sum<SUB>1</I></SUB> and <I>sum<SUB>2</I></SUB>, to 0.</LI></P>
<P ALIGN="JUSTIFY"><LI>Loop through the bytes of <I>K</I> from first to last.</LI></P>
<P ALIGN="JUSTIFY"><LI>Set <I>sum<SUB>1</I></SUB>=<I> sum<SUB>1</I></SUB>+the key byte (treat the key byte as a number in the range 0-255).</LI></P>
<P ALIGN="JUSTIFY"><LI>Set <I>sum<SUB>2</I></SUB>=<I> sum<SUB>2</I></SUB>+<I> sum<SUB>1</I></SUB>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Encrypt <I>K</I> with <I>W</I> in ECB mode, obtaining an encrypted key, <I>E</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Concatenate the last 6 bytes of <I>E</I> with <I>sum<SUB>2</I></SUB>, representing <I>sum<SUB>2</I></SUB> most-significant bit first.  The result is an 8-byte block, <I>T</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Encrypt <I>T</I> with <I>W</I> in ECB mode, obtaining an encrypted checksum, <I>C</I>.</LI></P>
<P ALIGN="JUSTIFY"><LI>Concatenate <I>E</I> with the last 2 bytes of <I>C</I> to obtain the wrapped key.</LI></P></OL>

<P ALIGN="JUSTIFY">When unwrapping a key with this mechanism, if the cryptographic checksum does not check out properly, an error is returned.  In addition, if a DES key or CDMF key is unwrapped with this mechanism, the parity bits on the wrapped key must be set appropriately.  If they are not set properly, an error is returned.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Ref384794871"><A NAME="_Ref384794886"><A NAME="_Ref384794928"><A NAME="_Toc405794931"><A NAME="_Toc410109271">11.34.&#9;SSL mechanism parameters</A></A></A></A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc323624052"><A NAME="_Toc405794932"><A NAME="_Toc410109272">CK_</A>SSL3_RANDOM_DATA</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SSL3_RANDOM_DATA</B> is a structure which provides information about the random data of a client and a server in an SSL context. This structure is used by both the <B>CKM_SSL3_MASTER_KEY_DERIVE</B> and the <B>CKM_SSL3_KEY_AND_MAC_DERIVE</B> mechanisms.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SSL3_RANDOM_DATA {</P>
<P>  CK_BYTE_PTR pClientRandom;</P>
<P>  CK_ULONG ulClientRandomLen;</P>
<P>  CK_BYTE_PTR pServerRandom;</P>
<P>  CK_ULONG ulServerRandomLen;</P>
<P>} CK_SSL3_RANDOM_DATA;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>pClientRandom</I>&#9;pointer to the client’s random data</P>
<P>&#9;<I>ulClientRandomLen</I>&#9;length in bytes of the client’s random data</P>
<P>&#9;<I>pServerRandom</I>&#9;pointer to the server’s random data</P>
<P>&#9;<I>ulServerRandomLen</I>&#9;length in bytes of the server’s random data</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>


<UL>
<LI><A NAME="_Toc405794933"><A NAME="_Toc410109273"></FONT><B><FONT FACE="Palatino">CK_SSL3_MASTER_KEY_DERIVE_PARAMS; CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SSL3_MASTER_KEY_DERIVE_PARAMS</B> is a structure that provides the parameters to the  <B>CKM_SSL3_MASTER_KEY_DERIVE</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {</P>
<P>  CK_SSL3_RANDOM_DATA RandomInfo;</P>
<P>  CK_VERSION_PTR pVersion;</P>
<P>} CK_SSL3_MASTER_KEY_DERIVE_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>RandomInfo</I>&#9;client’s and server’s random data information.</P>
<P>&#9;<I>pVersion</I>&#9;pointer to a <B>CK_VERSION </B>structure which receives the SSL protocol version information</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR</B> is a pointer to a <B>CK_SSL3_MASTER_KEY_DERIVE_PARAMS</B>.</P>

<UL>
<LI><A NAME="_Toc405794934"><A NAME="_Toc410109274"></FONT><B><FONT FACE="Palatino">CK_SSL3_KEY_MAT_OUT; CK_SSL3_KEY_MAT_OUT_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SSL3_KEY_MAT_OUT</B> is a structure that contains the resulting key handles and initialization vectors after performing a C_DeriveKey function with the <B>CKM_SSL3_KEY_AND_MAC_DERIVE</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SSL3_KEY_MAT_OUT {</P>
<P>  CK_OBJECT_HANDLE hClientMacSecret;</P>
<P>  CK_OBJECT_HANDLE hServerMacSecret;</P>
<P>  CK_OBJECT_HANDLE hClientKey;</P>
<P>  CK_OBJECT_HANDLE hServerKey;</P>
<P>  CK_BYTE_PTR pIVClient;</P>
<P>  CK_BYTE_PTR pIVServer;</P>
<P>} CK_SSL3_KEY_MAT_OUT;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>hClientMacSecret</I>&#9;key handle for the resulting Client MAC Secret key</P>
<P>&#9;<I>hServerMacSecret</I>&#9;key handle for the resulting Server MAC Secret key</P>
<P>&#9;<I>hClientKey</I>&#9;key handle for the resulting Client Secret key</P>
<P>&#9;<I>hServerKey</I>&#9;key handle for the resulting Server Secret key</P>
<P>&#9;<I>pIVClient</I>&#9;pointer to a location which receives the initialization vector (IV) created for the client (if any)</P>
<P>&#9;<I>pIVServer</I>&#9;pointer to a location which receives the initialization vector (IV) created for the server (if any)</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_SSL3_KEY_MAT_OUT_PTR</B> is a pointer to a <B>CK_SSL3_KEY_MAT_OUT</B>.</P>

<UL>
<LI><A NAME="_Toc405794935"><A NAME="_Toc410109275"></FONT><B><FONT FACE="Palatino">CK_SSL3_KEY_MAT_PARAMS; CK_SSL3_KEY_MAT_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_SSL3_KEY_MAT_PARAMS</B> is a structure that provides the parameters to the  <B>CKM_SSL3_KEY_AND_MAC_DERIVE</B> mechanism.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_SSL3_KEY_MAT_PARAMS {</P>
<P>  CK_ULONG ulMacSizeInBits;</P>
<P>  CK_ULONG ulKeySizeInBits;</P>
<P>  CK_ULONG ulIVSizeInBits;</P>
<P>  CK_BBOOL bIsExport;</P>
<P>  CK_SSL3_RANDOM_DATA RandomInfo;</P>
<P>  CK_SSL3_KEY_MAT_OUT_PTR pReturnedKeyMaterial;</P>
<P>} CK_SSL3_KEY_MAT_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>ulMacSizeInBits</I>&#9;the length (in bits) of the MACing keys agreed upon during the protocol handshake phase</P>
<P>&#9;<I>ulKeySizeInBits</I>&#9;the length (in bits) of the secret keys agreed upon during the protocol handshake phase </P>
<P>&#9;<I>ulIVSizeInBits</I>&#9;the length (in bits) of the IV agreed upon during the protocol handshake phase. If no IV is required, the length should be set to 0 </P>
<P>&#9;<I>bIsExport</I>&#9;a Boolean value which indicates whether the keys have to be derived for an export version of the protocol</P>
<P>&#9;<I>RandomInfo</I>&#9;client’s and server’s random data information.</P>
<P>&#9;<I>pReturnedKeyMaterial</I>&#9;points to a <B>CK_SSL3_KEY_MAT_OUT</B> structures which receives the handles for the keys generated and the IVs </P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_SSL3_KEY_MAT_PARAMS_PTR</B> is a pointer to a <B>CK_SSL3_KEY_MAT_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794936"><A NAME="_Toc410109276">11.35.&#9;SSL mechanisms</A></A></P>
<P><A NAME="_Toc405794937"><A NAME="_Toc410109277"></A>11.35.1.&#9;Pre_master key generation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Pre_master key generation in SSL 3.0, denoted <B>CKM_SSL3_PRE_MASTER_KEY_GEN</B>, is a mechanism which generates a 48-byte generic secret key.  It is used to produce the "pre_master" key used in SSL version 3.0. </P>
<P ALIGN="JUSTIFY">It has one parameter, a <B>CK_VERSION</B> structure, which provides the client’s SSL version number.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key (as well as the <B>CKA_VALUE_LEN</B> attribute, if it is not supplied in the template). Other attributes may be specified in the template, or else are assigned default values.</P>
<P ALIGN="JUSTIFY">The template sent along with this mechanism during a <B>C_GenerateKey</B> call may indicate that the object class is <B>CKO_SECRET_KEY</B>, the key type is <B>CKK_GENERIC_SECRET</B>, and the <B>CKA_VALUE_LEN</B> attribute has value 48.  However, since these facts are all implicit in the mechanism, there is no need to specify any of them.</P>
<P ALIGN="JUSTIFY">For this mechanism, the ulMinKeySize and ulMaxKeySize fields of the <B>CK_MECHANISM_INFO</B> structure both indicate 48 bytes.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794938"><A NAME="_Toc410109278">11.35.2.&#9;Master key derivation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Master key derivation in SSL 3.0, denoted <B>CKM_SSL3_MASTER_KEY_DERIVE</B>, is a mechanism used to derive one 48-byte generic secret key from another 48-byte generic secret key.  It is used to produce the "master_secret" key used in the SSL protocol from the "pre_master" key.  This mechanism returns the value of the client version which is built into the "pre_master" key as well as a handle to the derived "master_secret" key.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_SSL3_MASTER_KEY_DERIVE_PARAMS</B> structure, which allows for the passing of random data to the token as well as the returning of the protocol version number which is part of the pre-master key.  This structure is defined in Section 11.34.</P>
<P ALIGN="JUSTIFY">The mechanism contributes the <B>CKA_CLASS</B>, <B>CKA_KEY_TYPE</B>, and <B>CKA_VALUE</B> attributes to the new key (as well as the <B>CKA_VALUE_LEN</B> attribute, if it is not supplied in the template).  Other attributes may be specified in the template, or else are assigned default values.</P>
<P ALIGN="JUSTIFY">The template sent along with this mechanism during a <B>C_GenerateKey</B> call may indicate that the object class is <B>CKO_SECRET_KEY</B>, the key type is <B>CKK_GENERIC_SECRET</B>, and the <B>CKA_VALUE_LEN</B> attribute has value 48.  However, since these facts are all implicit in the mechanism, there is no need to specify any of them.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>The <B>CKA_SENSITIVE</B> and <B>CKA_EXTRACTABLE</B> attributes in the template for the new key can both be specified to be either TRUE or FALSE.  If omitted, these attributes each take on some default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to FALSE, then the derived key will as well.  If the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE, then the derived key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to the same value as its <B>CKA_SENSITIVE</B> attribute.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to FALSE, then the derived key will, too.  If the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE, then the derived key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to the <I>opposite</I> value from its <B>CKA_EXTRACTABLE</B> attribute.</LI></P></UL>

<P ALIGN="JUSTIFY">For this mechanism, the ulMinKeySize and ulMaxKeySize fields of the <B>CK_MECHANISM_INFO </B>structure both indicate 48 bytes.</P>
<P ALIGN="JUSTIFY">Note that the <B>CK_VERSION</B> structure pointed to by the <B>CK_SSL3_MASTER_KEY_DERIVE_PARAMS</B> structure’s <I>pVersion</I> field will be modified by the <B>C_DeriveKey</B> call.  In particular, when the call returns, this structure will hold the SSL version associated with the supplied pre_master key.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794939"><A NAME="_Toc410109279">11.35.3.&#9;Key and MAC derivation</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Key, MAC and IV derivation in SSL 3.0, denoted <B>CKM_SSL3_KEY_AND_MAC_DERIVE</B>, is a mechanism is used to derive the appropriate cryptographic keying material used by a "CipherSuite" from the "master_secret" key and random data. This mechanism returns the key handles for the keys generated in the process, as well as the IVs created.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_SSL3_KEY_MAT_PARAMS</B> structure, which allows for the passing of random data as well as the characteristic of the cryptographic material for the given CipherSuite and a pointer to a structure which receives the handles and IVs which were generated. This structure is defined in Section 11.34.</P>
<P ALIGN="JUSTIFY">This mechanism contributes to the creation of four distinct keys on the token and returns two IVs (if IVs are requested by the caller) back to the caller. The keys are all given an object class of <B>CKO_SECRET_KEY</B>. </P>
<P ALIGN="JUSTIFY">The two MACing keys ("client_write_MAC_secret" and "server_write_MAC_secret") are always given a type of <B>CKK_GENERIC_SECRET</B>. They are flagged as valid for signing, verification, and derivation operations.</P>
<P ALIGN="JUSTIFY">The other two keys ("client_write_key" and "server_write_key") are typed according to information found in the template sent along with this mechanism during a <B>C_DeriveKey</B> function call.  By default, they are flagged as valid for encryption, decryption, and derivation operations.</P>
<P ALIGN="JUSTIFY">IVs will be generated and returned if the <I>ulIVSizeInBits</I> field of the <B>CK_SSL_KEY_MAT_PARAMS</B> field has a nonzero value.  If they are generated, their length in bits will agree with the value in the <I>ulIVSizeInBits</I> field.</P>
<P ALIGN="JUSTIFY">All four keys inherit the values of the<B> CKA_SENSITIVE</B>, <B>CKA_ALWAYS_SENSITIVE</B>, <B>CKA_EXTRACTABLE</B>, and <B>CKA_NEVER_EXTRACTABLE</B> attributes from the base key.  The template provided to <B>C_DeriveKey</B> may not specify values for any of these attributes which differ from those held by the base key.</P>
<P ALIGN="JUSTIFY">Note that the <B>CK_SSL3_KEY_MAT_OUT</B> structure pointed to by the <B>CK_SSL3_KEY_MAT_PARAMS</B> structure’s <I>pReturnedKeyMaterial</I> field will by modified by the <B>C_DeriveKey</B> call.  In particular, the four key handle fields in the <B>CK_SSL3_KEY_MAT_OUT</B> structure will be modified to hold handles to the newly-created keys; in addition, the buffers pointed to by the <B>CK_SSL3_KEY_MAT_OUT</B> structure’s <I>pIVClient</I> and <I>pIVServer</I> fields will have IVs returned in them (if IVs are requested by the caller).  Therefore, these two fields must point to buffers with sufficient space to hold any IVs that will be returned.</P>
<P ALIGN="JUSTIFY">This mechanism departs from the other key derivation mechanisms in Cryptoki in its returned information. For most key-derivation mechanisms, <B>C_DeriveKey</B> returns a single key handle as a result of a successful completion. However, since the <B>CKM_SSL3_KEY_AND_MAC_DERIVE</B> mechanism returns all of its key handles in the <B>CK_SSL3_KEY_MAT_OUT</B> structure pointed to by the <B>CK_SSL3_KEY_MAT_PARAMS</B> structure specified as the mechanism parameter, the parameter <I>phKey</I> passed to <B>C_DeriveKey</B> is unnecessary, and should be a NULL_PTR.</P>
<P ALIGN="JUSTIFY">If a call to <B>C_DeriveKey</B> with this mechanism fails, then <I>none</I> of the four keys will be created on the token.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794940"><A NAME="_Toc410109280">11.35.4.&#9;MD5 MACing in SSL 3.0</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">MD5 MACing in SSL3.0, denoted <B>CKM_SSL3_MD5_MAC</B>, is a mechanism for single- and multiple-part signatures (data authentication) and verification using MD5, based on the SSL 3.0 protocol. This technique is very similar to the HMAC technique.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which specifies the length in bytes of the signatures produced by this mechanism.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795059"><A NAME="_Toc410108928">Table 97, MD5 MACing in SSL 3.0: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=492>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4-8, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4-8, depending on parameters</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of generic secret key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794941"><A NAME="_Toc410109281">11.35.5.&#9;SHA-1 MACing in SSL 3.0</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">SHA-1 MACing in SSL3.0, denoted <B>CKM_SSL3_SHA1_MAC</B>, is a mechanism for single- and multiple-part signatures (data authentication) and verification using SHA-1, based on the SSL 3.0 protocol. This technique is very similar to the HMAC technique.</P>
<P ALIGN="JUSTIFY">It has a parameter, a <B>CK_MAC_GENERAL_PARAMS</B>, which specifies the length in bytes of the signatures produced by this mechanism.</P>
<P ALIGN="JUSTIFY">Constraints on key types and the length of input and output data are summarized in the following table:</P>
<B><P><A NAME="_Toc405795060"><A NAME="_Toc410108929">Table 98, SHA-1 MACing in SSL 3.0: Key And Data Length</A></A></P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=492>
<TR><TD WIDTH="22%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Function</B></FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Key type</B></FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Data length</B></FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">Signature length</B></FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Sign</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4-8, depending on parameters</FONT></TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Verify</FONT></TD>
<TD WIDTH="20%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">generic secret</FONT></TD>
<TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">any</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P ALIGN="CENTER">4-8, depending on parameters</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">For this mechanism, the <I>ulMinKeySize</I> and <I>ulMaxKeySize</I> fields of the <B>CK_MECHANISM_INFO</B> structure specify the supported range of generic secret key sizes, in bits.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794942"><A NAME="_Toc410109282">11.36.&#9;Parameters for miscellaneous simple key derivation mechanisms</A></A></P></ul>
</ul>


<UL>
<LI><A NAME="_Toc405794943"><A NAME="_Toc410109283">CK_KEY_DERIVATION_STRING_DATA; CK_KEY_DERIVATION_STRING_DATA_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_KEY_DERIVATION_STRING_DATA</B> is a structure that holds a pointer to a byte string and the byte string’s length.  It provides the parameters for the <B>CKM_CONCATENATE_BASE_AND_DATA</B>, <B>CKM_CONCATENATE_DATA_AND_BASE</B>, and <B>CKM_XOR_BASE_AND_DATA</B> mechanisms.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef struct CK_KEY_DERIVATION_STRING_DATA {</P>
<P>  CK_BYTE_PTR pData;</P>
<P>  CK_ULONG ulLen;</P>
<P>} CK_KEY_DERIVATION_STRING_DATA;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The fields of the structure have the following meanings:</P><ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>
<ul>

<P>&#9;<I>pData</I>&#9;pointer to the byte string</P>
<P>&#9;<I>ulLen</I>&#9;length of the byte string</P></ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

<B><P ALIGN="JUSTIFY">CK_KEY_DERIVATION_STRING_DATA_PTR</B> is a pointer to a <B>CK_KEY_DERIVATION_STRING_DATA</B>.</P>

<UL>
<LI><A NAME="_Toc405794944"><A NAME="_Toc410109284"></FONT><B><FONT FACE="Palatino">CK_EXTRACT_PARAMS; CK_EXTRACT_PARAMS_PTR</A></A></LI></UL>

</FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_KEY_EXTRACT_PARAMS</B> provides the parameter to the <B>CKM_EXTRACT_KEY_FROM_KEY</B> mechanism.  It specifies which bit of the base key should be used as the first bit of the derived key.  It is defined as follows:</P><ul>
<ul>
<ul>
<ul>

</FONT><FONT FACE="Courier New" SIZE=2><P>typedef CK_ULONG CK_EXTRACT_PARAMS;</P>
<P>&nbsp;</P></ul>
</ul>
</ul>
</ul>

</FONT><B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">CK_EXTRACT_PARAMS_PTR</B> is a pointer to a <B>CK_EXTRACT_PARAMS</B>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794945"><A NAME="_Toc410109285">11.37.&#9;Miscellaneous simple key derivation mechanisms</A></A></P>
<P><A NAME="_Toc405794946"><A NAME="_Toc410109286">11.37.1.&#9;Concatenation of a base key and another key</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This mechanism, denoted <B>CKM_CONCATENATE_BASE_AND_KEY</B>, derives a secret key from the concatenation of two existing secret keys.  The two keys are specified by handles; the values of the keys specified are concatenated together in a buffer.</P>
<P ALIGN="JUSTIFY">This mechanism takes a parameter, a <B>CK_OBJECT_HANDLE</B>.  This handle produces the key value information which is appended to the end of the base key’s value information (the base key is the key whose handle is supplied as an argument to <B>C_DeriveKey</B>).</P>
<P ALIGN="JUSTIFY">For example, if the value of the base key is </FONT><FONT FACE="Courier New" SIZE=2>0x01234567,</FONT><FONT FACE="Palatino" SIZE=2> and the value of the other key is </FONT><FONT FACE="Courier New" SIZE=2>0x89ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>, then the value of the derived key will be taken from a buffer containing the string </FONT><FONT FACE="Courier New" SIZE=2>0x0123456789ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>.  </P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be equal to the sum of the lengths of the values of the two original keys.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length is provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more bytes than are available by concatenating the two original keys’ values, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If either of the two original keys has its <B>CKA_SENSITIVE</B> attribute set to TRUE, so does the derived key.  If not, then the derived key’s <B>CKA_SENSITIVE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if either of the two original keys has its <B>CKA_EXTRACTABLE</B> attribute set to FALSE, so does the derived key.  If not, then the derived key’s <B>CKA_EXTRACTABLE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>The derived key’s <B>CKA_ALWAYS_SENSITIVE</B> attribute is set to TRUE if and only if both of the original keys have their <B>CKA_ALWAYS_SENSITIVE</B> attributes set to TRUE.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the derived key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute is set to TRUE if and only if both of the original keys have their <B>CKA_NEVER_EXTRACTABLE</B> attributes set to TRUE.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794947"><A NAME="_Toc410109287">11.37.2.&#9;Concatenation of a base key and data</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This mechanism, denoted <B>CKM_CONCATENATE_BASE_AND_DATA</B>, derives a secret key by concatenating data onto the end of a specified secret key.</P>
<P ALIGN="JUSTIFY">This mechanism takes a parameter, a <B>CK_KEY_DERIVATION_STRING_DATA</B> structure, which specifies the length and value of the data which will be appended to the base key to derive another key.</P>
<P ALIGN="JUSTIFY">For example, if the value of the base key is </FONT><FONT FACE="Courier New" SIZE=2>0x01234567,</FONT><FONT FACE="Palatino" SIZE=2> and the value of the data is </FONT><FONT FACE="Courier New" SIZE=2>0x89ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>, then the value of the derived key will be taken from a buffer containing the string </FONT><FONT FACE="Courier New" SIZE=2>0x0123456789ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>.  </P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be equal to the sum of the lengths of the value of the original key and the data.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length is provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more bytes than are available by concatenating the original key’s value and the data, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_SENSITIVE</B> attribute set to TRUE, so does the derived key.  If not, then the derived key’s <B>CKA_SENSITIVE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_EXTRACTABLE</B> attribute set to FALSE, so does the derived key.  If not, then the derived key’s <B>CKA_EXTRACTABLE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>The derived key’s <B>CKA_ALWAYS_SENSITIVE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the derived key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794948"><A NAME="_Toc410109288">11.37.3.&#9;Concatenation of data and a base key</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This mechanism, denoted <B>CKM_CONCATENATE_DATA_AND_BASE</B>, derives a secret key by prepending data to the start of a specified secret key.</P>
<P ALIGN="JUSTIFY">This mechanism takes a parameter, a <B>CK_KEY_DERIVATION_STRING_DATA</B> structure, which specifies the length and value of the data which will be prepended to the base key to derive another key.</P>
<P ALIGN="JUSTIFY">For example, if the value of the base key is </FONT><FONT FACE="Courier New" SIZE=2>0x01234567,</FONT><FONT FACE="Palatino" SIZE=2> and the value of the data is </FONT><FONT FACE="Courier New" SIZE=2>0x89ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>, then the value of the derived key will be taken from a buffer containing the string </FONT><FONT FACE="Courier New" SIZE=2>0x89ABCDEF01234567</FONT><FONT FACE="Palatino" SIZE=2>.  </P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be equal to the sum of the lengths of the data and the value of the original key.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length is provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more bytes than are available by concatenating the data and the original key’s value, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_SENSITIVE</B> attribute set to TRUE, so does the derived key.  If not, then the derived key’s <B>CKA_SENSITIVE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_EXTRACTABLE</B> attribute set to FALSE, so does the derived key.  If not, then the derived key’s <B>CKA_EXTRACTABLE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>The derived key’s <B>CKA_ALWAYS_SENSITIVE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the derived key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794949"><A NAME="_Toc410109289">11.37.4.&#9;XORing of a key and data</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">XORing key derivation, denoted <B>CKM_XOR_BASE_AND_DATA</B>, is a mechanism which provides the capability of deriving a secret key by performing a bit XORing of a key pointed to by a base key handle and some data.</P>
<P ALIGN="JUSTIFY">This mechanism takes a parameter, a <B>CK_KEY_DERIVATION_STRING_DATA</B> structure, which specifies the data with which to XOR the original key’s value.</P>
<P ALIGN="JUSTIFY">For example, if the value of the base key is </FONT><FONT FACE="Courier New" SIZE=2>0x01234567,</FONT><FONT FACE="Palatino" SIZE=2> and the value of the data is </FONT><FONT FACE="Courier New" SIZE=2>0x89ABCDEF</FONT><FONT FACE="Palatino" SIZE=2>, then the value of the derived key will be taken from a buffer containing the string </FONT><FONT FACE="Courier New" SIZE=2>0x88888888</FONT><FONT FACE="Palatino" SIZE=2>.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then the key produced by this mechanism will be a generic secret key.  Its length will be equal to the minimum of the lengths of the data and the value of the original key.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length is provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more bytes than are available by taking the shorter of the data and the original key’s value, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_SENSITIVE</B> attribute set to TRUE, so does the derived key.  If not, then the derived key’s <B>CKA_SENSITIVE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_EXTRACTABLE</B> attribute set to FALSE, so does the derived key.  If not, then the derived key’s <B>CKA_EXTRACTABLE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>The derived key’s <B>CKA_ALWAYS_SENSITIVE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the derived key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE.</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794950"><A NAME="_Toc410109290">11.37.5.&#9;Extraction of one key from another key</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Extraction of one key from another key, denoted <B>CKM_EXTRACT_KEY_FROM_KEY</B>, is a mechanism which provides the capability of creating one secret key from the bits of another secret key.</P>
<P ALIGN="JUSTIFY">This mechanism has a parameter, a <B>CK_EXTRACT_PARAMS</B>, which specifies which bit of the original key should be used as the first bit of the newly-derived key.</P>
<P ALIGN="JUSTIFY">We give an example of how this mechanism works.  Suppose a token has a secret key with the 4-byte value </FONT><FONT FACE="Courier New" SIZE=2>0x329F84A9</FONT><FONT FACE="Palatino" SIZE=2>.  We will derive a 2-byte secret key from this key, starting at bit position 21 (<I>i.e.</I>, the value of the parameter to the <B>CKM_EXTRACT_KEY_FROM_KEY</B> mechanism is 21).</P>
<OL>

<P ALIGN="JUSTIFY"><LI>We write the key’s value in binary: </FONT><FONT FACE="Courier New" SIZE=2>0011 0010 1001 1111 1000 0100 1010 1001</FONT><FONT FACE="Palatino" SIZE=2>.  We regard this binary string as holding the 32 bits of the key, labelled as b<SUB>0</SUB>, b<SUB>1</SUB>, …, b<SUB>31</SUB>.</LI></P>
<P ALIGN="JUSTIFY"><LI>We then extract 16 consecutive bits (<I>i.e.</I>, 2 bytes) from this binary string, starting at bit b<SUB>21</SUB>.  We obtain the binary string </FONT><FONT FACE="Courier New" SIZE=2>1001 0101 0010 0110</FONT><FONT FACE="Palatino" SIZE=2>.</LI></P>
<P ALIGN="JUSTIFY"><LI>The value of the new key is thus </FONT><FONT FACE="Courier New" SIZE=2>0x9526</FONT><FONT FACE="Palatino" SIZE=2>.</LI></P></OL>

<P ALIGN="JUSTIFY"></A></A></A></A>Note that when constructing the value of the derived key, it is permissible to wrap around the end of the binary string representing the original key’s value.</P>
<P ALIGN="JUSTIFY">If the original key used in this process is sensitive, then the derived key must also be sensitive for the derivation to succeed.</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If no length or key type is provided in the template, then an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no key type is provided in the template, but a length is, then the key produced by this mechanism will be a generic secret key of the specified length.</LI></P>
<P ALIGN="JUSTIFY"><LI>If no length is provided in the template, but a key type is, then that key type must have a well-defined length.  If it does, then the key produced by this mechanism will be of the type specified in the template.  If it doesn’t, an error will be returned.</LI></P>
<P ALIGN="JUSTIFY"><LI>If both a key type and a length are provided in the template, the length must be compatible with that key type.  The key produced by this mechanism will be of the specified type and length.</LI></P></UL>

<P ALIGN="JUSTIFY">If a DES, DES2, DES3, or CDMF key is derived with this mechanism, the parity bits of the key will be set properly.</P>
<P ALIGN="JUSTIFY">If the requested type of key requires more bytes than the original key has, an error is generated.</P>
<P ALIGN="JUSTIFY">This mechanism has the following rules about key sensitivity and extractability:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>If the base key has its <B>CKA_SENSITIVE</B> attribute set to TRUE, so does the derived key.  If not, then the derived key’s <B>CKA_SENSITIVE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, if the base key has its <B>CKA_EXTRACTABLE</B> attribute set to FALSE, so does the derived key.  If not, then the derived key’s <B>CKA_EXTRACTABLE</B> attribute is set either from the supplied template or from a default value.</LI></P>
<P ALIGN="JUSTIFY"><LI>The derived key’s <B>CKA_ALWAYS_SENSITIVE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_ALWAYS_SENSITIVE</B> attribute set to TRUE.</LI></P>
<P ALIGN="JUSTIFY"><LI>Similarly, the derived key’s <B>CKA_NEVER_EXTRACTABLE</B> attribute is set to TRUE if and only if the base key has its <B>CKA_NEVER_EXTRACTABLE</B> attribute set to TRUE.</LI></P></UL>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc405794951"><A NAME="_Toc410109291">12.&#9;Cryptoki tips and reminders</A></A></P>
</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In this section, we clarify, review, and/or emphasize a few odds and ends about how Cryptoki works.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794952"><A NAME="_Toc410109292">12.1.&#9;Operations, sessions</A>, and threads</A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In Cryptoki, there are several different types of operations which can be &quot;active&quot; in a session.  An active operation is essentially one which takes more than one Cryptoki function call to perform.  The types of active operations are object searching; encryption; decryption; message-digesting; signature with appendix; signature with recovery; verification with appendix; and verification with recovery.</P>
<P ALIGN="JUSTIFY">A given session can have 0, 1, or 2 operations active at a time.  It can only have 2 operations active simultaneously if the token supports this; moreover, those two operations must be one of the four following pairs of operations: digesting and encryption; decryption and digesting; signing and encryption; decryption and verification.</P>
<P ALIGN="JUSTIFY">If an application attempts to initialize an operation (make it active) in a session, but this cannot be accomplished because of some other active operation(s), the application receives the error value CKR_OPERATION_ACTIVE.  This error value can also be received if a session has an active operation and the application attempts to use that session to perform any of various operations which do not become &quot;active&quot;, but which require cryptographic processing, such as using the token’s random number generator, or generating/wrapping/unwrapping/deriving a key.</P>
<P ALIGN="JUSTIFY">Different threads of an application should never share sessions, unless they are extremely careful not to make function calls at the same time.  This is true even if the Cryptoki library was initialized with locking enabled for thread-safety.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794953"><A NAME="_Toc410109293">12.2.&#9;Objects, attributes, and templates</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">In Cryptoki, every object (with the possible exception of RSA private keys) always possesses <I>all</I> possible attributes specified by Cryptoki for an object of its type.  This means, for example, that a Diffie-Hellman private key object <I>always</I> possesses a <B>CKA_VALUE_BITS</B> attribute, <I>even if that attribute wasn’t specified when the key was generated</I> (in such a case, the proper value for the attribute is computed during the key generation process).</P>
<P ALIGN="JUSTIFY">In general, a Cryptoki function which requires a template for an object needs the template to specify—either explicitly or implicitly—any attributes that are not specified elsewhere.  If a template specifies a particular attribute more than once, the function can return CKR_TEMPLATE_INVALID or it can choose a particular value of the attribute from among those specified and use that value.  In any event, object attributes are always single-valued.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P><A NAME="_Toc405794954"><A NAME="_Toc410109294">12.3.&#9;Signing with recovery</A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Signing with recovery is a general alternative to ordinary digital signatures (&quot;signing with appendix&quot;) which is supported by certain mechanisms.  Recall that for ordinary digital signatures, a signature of a message is computed as some function of the message and the signer’s private key; this signature can then be used (together with the message and the signer’s public key) as input to the verification process, which yields a simple &quot;signature valid/signature invalid&quot; decision.</P>
<P ALIGN="JUSTIFY">Signing with recovery also creates a signature from a message and the signer’s private key.  However, to verify this signature, no message is required as input.  Only the signature and the signer’s public key are input to the verification process, and the verification process outputs either &quot;signature invalid&quot; or—if the signature is valid—the original message.</P>
<P ALIGN="JUSTIFY">Consider a simple example with the <B>CKM_RSA_X_509</B> mechanism.  Here, a message is a byte string which we will consider to be a number modulo <I>n</I> (the signer’s RSA modulus).  When this mechanism is used for ordinary digital signatures (signatures with appendix), a signature is computed by raising the message to the signer’s private exponent modulo <I>n</I>.  To verify this signature, a verifier raises the signature to the signer’s public exponent modulo <I>n</I>, and accepts the signature as valid if and only if the result matches the original message.</P>
<P ALIGN="JUSTIFY">If <B>CKM_RSA_X_509</B> is used to create signatures with recovery, the signatures are produced in exactly the same fashion.  For this particular mechanism, <I>any</I> number modulo <I>n</I> is a valid signature.  To recover the message from a signature, the signature is raised to the signer’s public exponent modulo <I>n</I>.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc323610960"><A NAME="_Toc383864976"><A NAME="_Toc405794955"><A NAME="_Toc410109295">Appendix A: Token Profiles</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This appendix describes &quot;profiles,&quot; <I>i.e.</I>, sets of mechanisms, which a token should support for various common types of application. It is expected that these sets would be standardized as parts of the various applications, for instance within a list of requirements on the module that provides cryptographic services to the application (which may be a Cryptoki token in some cases). Thus, these profiles are intended for reference only at this point, and are not part of this standard.</P>
<P ALIGN="JUSTIFY">The following table summarizes the mechanisms relevant to two common types of application:</P>
<B><P>Table A-1, Mechanisms and profiles</P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=443>
<TR><TD WIDTH="43%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="57%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Application</B></FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1>
<P>Mechanism</B></FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Government Authentication-only</B></FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER">Cellular Digital Packet Data</B></FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DSA_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DSA</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DH_PKCS_KEY_PAIR_GEN</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_DH_PKCS_DERIVE</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC4_KEY_GEN</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_RC4</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P>CKM_SHA_1</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=1><P ALIGN="CENTER"><FONT FACE="Wingdings">&#252;</FONT>
</FONT></TD>
<TD WIDTH="28%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P>A.1 Government authentication-only</P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">The U.S. government has standardized on the Digital Signature Algorithm as defined in FIPS PUB 186 for signatures and the Secure Hash Algorithm as defined in FIPS PUB 180-1 for message digesting. The relevant mechanisms include the following:</P><ul>
<ul>

<P ALIGN="JUSTIFY">DSA key generation (512-1024 bits)</P>
<P ALIGN="JUSTIFY">DSA (512-1024 bits)</P>
<P ALIGN="JUSTIFY">SHA-1</P></ul>
</ul>

<P ALIGN="JUSTIFY">Note that this version of Cryptoki does not have a mechanism for generating DSA parameters.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P>A.2 Cellular Digital Packet Data </P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">Cellular Digital Packet Data (CDPD) is a set of protocols for wireless communication. The basic set of mechanisms to support CDPD applications includes the following:</P><ul>
<ul>

<P ALIGN="JUSTIFY">Diffie-Hellman key generation (256-1024 bits)</P>
<P ALIGN="JUSTIFY">Diffie-Hellman key derivation (256-1024 bits)</P>
<P ALIGN="JUSTIFY">RC4 key generation (40-128 bits)</P>
<P ALIGN="JUSTIFY">RC4 (40-128 bits)</P></ul>
</ul>

<P ALIGN="JUSTIFY">(The initial CDPD security specification limits the size of the Diffie-Hellman key to 256 bits, but it has been recommended that the size be increased to at least 512 bits.)</P>
<P ALIGN="JUSTIFY">Note that this version of Cryptoki does not have a mechanism for generating Diffie-Hellman parameters.</P><ul>
<ul>

</FONT><B><FONT FACE="Palatino" SIZE=4><P><A NAME="_Toc323610961"><A NAME="_Toc383864977"><A NAME="_Toc405794956"><A NAME="_Toc410109296">Appendix B: Comparison of Cryptoki and Other APIs</A></A></A></A></P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This appendix compares Cryptoki with the following cryptographic APIs:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>ANSI N13-94 - Guideline X9.TG-12-199X, Using Tessera in Financial Systems:  An Application Programming Interface, April 29, 1994</LI></P>
<P ALIGN="JUSTIFY"><LI>X/Open GCS-API - Generic Cryptographic Service API, Draft 2, February 14, 1995</LI></P></UL>
<ul>
<ul>

</FONT><B><FONT FACE="Palatino"><P>B.1 FORTEZZA CIPG, Rev. 1.52</P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This document defines an API to the FORTEZZA PCMCIA Crypto Card.  It is at a level similar to Cryptoki.  The following table lists the FORTEZZA CIPG functions, together with the equivalent Cryptoki functions:</P>
<B><P>Table B-1, FORTEZZA CIPG vs. Cryptoki</P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=583>
<TR><TD WIDTH="34%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>FORTEZZA CIPG</B></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Equivalent Cryptoki</B></FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_ChangePIN</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_InitPIN, C_SetPIN</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_CheckPIN</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Login</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Close</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CloseSession</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Decrypt</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptInit, C_Decrypt, C_DecryptUpdate, C_DecryptFinal</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_DeleteCertificate</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DestroyObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_DeleteKey</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DestroyObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Encrypt</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit, C_Encrypt, C_EncryptUpdate, C_EncryptFinal</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_ExtractX</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateIV</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateRandom</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateMEK</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateRa</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateRandom</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateRandom</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateRandom</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateTEK</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GenerateX</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKeyPair</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetCertificate</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_FindObjects</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Configuration</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetTokenInfo</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetHash</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestInit, C_Digest, C_DigestUpdate, and C_DigestFinal</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetIV</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>No equivalent</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetPersonalityList</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_FindObjects</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetState</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetSessionInfo</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetStatus</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetTokenInfo</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_GetTime</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GetTokenInfo</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Hash</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestInit, C_Digest, C_DigestUpdate, and C_DigestFinal</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Initialize</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_Initialize</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_InitializeHash</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestInit</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_InstallX</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadCertificate</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadDSAParameters</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadInitValues</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SeedRandom</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadIV</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit, C_DecryptInit</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadK</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignInit</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadPublicKeyParameters</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadPIN</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SetPIN</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_LoadX</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Lock</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Implicit in session management</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Open</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_OpenSession</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_RelayX</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Reset</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CloseAllSessions</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Restore</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Implicit in session management</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Save</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Implicit in session management</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Select</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_OpenSession</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_SetConfiguration</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>No equivalent</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_SetKey</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit, C_DecryptInit</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_SetMode</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit, C_DecryptInit</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_SetPersonality</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CreateObject</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_SetTime</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>No equivalent</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Sign</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignInit, C_Sign</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Terminate</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_CloseAllSessions</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Timestamp</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignInit, C_Sign</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Unlock</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>Implicit in session management</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_UnwrapKey</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_VerifySignature</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyInit, C_Verify</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_VerifyTimestamp</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyInit, C_Verify</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_WrapKey</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>CI_Zeroize</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_InitToken</FONT></TD>
</TR>
</TABLE>
<ul>
<ul>

<B><FONT FACE="Palatino"><P>B.2 GCS-API</P></ul>
</ul>

</B></FONT><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY">This proposed standard defines an API to high-level security services such as authentication of identities and data-origin, non-repudiation, and separation and protection. It is at a higher level than Cryptoki.  The following table lists the GCS-API functions with the Cryptoki functions used to implement the functions. Note that full support of GCS-API is left for future versions of Cryptoki.</P>
<B><P>Table B-2, GCS-API vs. Cryptoki</P></B></FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=576>
<TR><TD WIDTH="41%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>GCS-API</B></FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<B><FONT FACE="Palatino" SIZE=2><P>Cryptoki implementation</B></FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>retrieve_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>release_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_hash</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DigestInit, C_Digest</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_random_number</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateRandom</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_checkvalue</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SignInit, C_Sign, C_SignUpdate, C_SignFinal</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>verify_checkvalue</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_VerifyInit, C_Verify, C_VerifyUpdate, C_VerifyFinal</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>data_encipher</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_EncryptInit, C_Encrypt, C_EncryptUpdate, C_EncryptFinal</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>data_decipher</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DecryptInit, C_Decrypt, C_DecryptUpdate, C_DecryptFinal</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>create_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>derive_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DeriveKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>store_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>delete_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>replicate_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>export_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>import_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>archive_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>restore_CC</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>set_key_state</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_key_pattern</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>verify_key_pattern</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>derive_clear_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_DeriveKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_clear_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_GenerateKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>load_key_parts</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>clear_key_encipher</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_WrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>clear_key_decipher</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_UnwrapKey</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>change_key_context</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>load_initial_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>generate_initial_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>set_current_master_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>protect_under_new_master_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>protect_under_current_master_key</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>initialise_random_number_generator</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>C_SeedRandom</FONT></TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>install_algorithm</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>de_install_algorithm</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>disable_algorithm</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>enable_algorithm</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="41%" VALIGN="TOP">
<FONT FACE="Palatino" SIZE=2><P>set_defaults</FONT></TD>
<TD WIDTH="59%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<B><FONT FACE="Palatino" SIZE=2><P ALIGN="JUSTIFY"></P></B></FONT></BODY>
</HTML>
